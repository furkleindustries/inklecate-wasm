module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/mono.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/async-limiter/index.js":
/*!*********************************************!*\
  !*** ./node_modules/async-limiter/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction Queue(options) {\n  if (!(this instanceof Queue)) {\n    return new Queue(options);\n  }\n\n  options = options || {};\n  this.concurrency = options.concurrency || Infinity;\n  this.pending = 0;\n  this.jobs = [];\n  this.cbs = [];\n  this._done = done.bind(this);\n}\n\nvar arrayAddMethods = [\n  'push',\n  'unshift',\n  'splice'\n];\n\narrayAddMethods.forEach(function(method) {\n  Queue.prototype[method] = function() {\n    var methodResult = Array.prototype[method].apply(this.jobs, arguments);\n    this._run();\n    return methodResult;\n  };\n});\n\nObject.defineProperty(Queue.prototype, 'length', {\n  get: function() {\n    return this.pending + this.jobs.length;\n  }\n});\n\nQueue.prototype._run = function() {\n  if (this.pending === this.concurrency) {\n    return;\n  }\n  if (this.jobs.length) {\n    var job = this.jobs.shift();\n    this.pending++;\n    job(this._done);\n    this._run();\n  }\n\n  if (this.pending === 0) {\n    while (this.cbs.length !== 0) {\n      var cb = this.cbs.pop();\n      process.nextTick(cb);\n    }\n  }\n};\n\nQueue.prototype.onDone = function(cb) {\n  if (typeof cb === 'function') {\n    this.cbs.push(cb);\n    this._run();\n  }\n};\n\nfunction done() {\n  this.pending--;\n  this._run();\n}\n\nmodule.exports = Queue;\n\n\n//# sourceURL=webpack:///./node_modules/async-limiter/index.js?");

/***/ }),

/***/ "./node_modules/bufferutil/fallback.js":
/*!*********************************************!*\
  !*** ./node_modules/bufferutil/fallback.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nconst mask = (source, mask, output, offset, length) => {\n  for (var i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n};\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nconst unmask = (buffer, mask) => {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (var i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n};\n\nmodule.exports = { mask, unmask };\n\n\n//# sourceURL=webpack:///./node_modules/bufferutil/fallback.js?");

/***/ }),

/***/ "./node_modules/bufferutil/index.js":
/*!******************************************!*\
  !*** ./node_modules/bufferutil/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\ntry {\n  module.exports = __webpack_require__(/*! node-gyp-build */ \"./node_modules/node-gyp-build/index.js\")(__dirname);\n} catch (e) {\n  module.exports = __webpack_require__(/*! ./fallback */ \"./node_modules/bufferutil/fallback.js\");\n}\n\n\n//# sourceURL=webpack:///./node_modules/bufferutil/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/copy-sync/copy-sync.js":
/*!**********************************************************!*\
  !*** ./node_modules/fs-extra/lib/copy-sync/copy-sync.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdirpSync = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\").mkdirsSync\nconst utimesSync = __webpack_require__(/*! ../util/utimes.js */ \"./node_modules/fs-extra/lib/util/utimes.js\").utimesMillisSync\nconst stat = __webpack_require__(/*! ../util/stat */ \"./node_modules/fs-extra/lib/util/stat.js\")\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  return handleFilterAndCopy(destStat, src, dest, opts)\n}\n\nfunction handleFilterAndCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirpSync(destParent)\n  return startCopy(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  if (typeof fs.copyFileSync === 'function') {\n    fs.copyFileSync(src, dest)\n    fs.chmodSync(dest, srcStat.mode)\n    if (opts.preserveTimestamps) {\n      return utimesSync(dest, srcStat.atime, srcStat.mtime)\n    }\n    return\n  }\n  return copyFileFallback(srcStat, src, dest, opts)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts) {\n  const BUF_LENGTH = 64 * 1024\n  const _buff = __webpack_require__(/*! ../util/buffer */ \"./node_modules/fs-extra/lib/util/buffer.js\")(BUF_LENGTH)\n\n  const fdr = fs.openSync(src, 'r')\n  const fdw = fs.openSync(dest, 'w', srcStat.mode)\n  let pos = 0\n\n  while (pos < srcStat.size) {\n    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts)\n  if (destStat && !destStat.isDirectory()) {\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n  }\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return fs.chmodSync(dest, srcStat.mode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy')\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/copy-sync/copy-sync.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/copy-sync/index.js":
/*!******************************************************!*\
  !*** ./node_modules/fs-extra/lib/copy-sync/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  copySync: __webpack_require__(/*! ./copy-sync */ \"./node_modules/fs-extra/lib/copy-sync/copy-sync.js\")\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/copy-sync/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/copy/copy.js":
/*!************************************************!*\
  !*** ./node_modules/fs-extra/lib/copy/copy.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdirp = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\").mkdirs\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists\nconst utimes = __webpack_require__(/*! ../util/utimes */ \"./node_modules/fs-extra/lib/util/utimes.js\").utimesMillis\nconst stat = __webpack_require__(/*! ../util/stat */ \"./node_modules/fs-extra/lib/util/stat.js\")\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  stat.checkPaths(src, dest, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {\n      if (err) return cb(err)\n      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\n      return checkParentDir(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return startCopy(destStat, src, dest, opts, cb)\n    mkdirp(destParent, err => {\n      if (err) return cb(err)\n      return startCopy(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) return onInclude(destStat, src, dest, opts, cb)\n    return cb()\n  }, error => cb(error))\n}\n\nfunction startCopy (destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\n  return getStats(destStat, src, dest, opts, cb)\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  if (typeof fs.copyFile === 'function') {\n    return fs.copyFile(src, dest, err => {\n      if (err) return cb(err)\n      return setDestModeAndTimestamps(srcStat, dest, opts, cb)\n    })\n  }\n  return copyFileFallback(srcStat, src, dest, opts, cb)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts, cb) {\n  const rs = fs.createReadStream(src)\n  rs.on('error', err => cb(err)).once('open', () => {\n    const ws = fs.createWriteStream(dest, { mode: srcStat.mode })\n    ws.on('error', err => cb(err))\n      .on('open', () => rs.pipe(ws))\n      .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb))\n  })\n}\n\nfunction setDestModeAndTimestamps (srcStat, dest, opts, cb) {\n  fs.chmod(dest, srcStat.mode, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) {\n      return utimes(dest, srcStat.atime, srcStat.mtime, cb)\n    }\n    return cb()\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts, cb)\n  if (destStat && !destStat.isDirectory()) {\n    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n  }\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return fs.chmod(dest, srcStat.mode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { destStat } = stats\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err)\n      return copyDirItems(items, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (!destStat) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\nmodule.exports = copy\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/copy/copy.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/copy/index.js":
/*!*************************************************!*\
  !*** ./node_modules/fs-extra/lib/copy/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nmodule.exports = {\n  copy: u(__webpack_require__(/*! ./copy */ \"./node_modules/fs-extra/lib/copy/copy.js\"))\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/copy/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/empty/index.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/empty/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst remove = __webpack_require__(/*! ../remove */ \"./node_modules/fs-extra/lib/remove/index.js\")\n\nconst emptyDir = u(function emptyDir (dir, callback) {\n  callback = callback || function () {}\n  fs.readdir(dir, (err, items) => {\n    if (err) return mkdir.mkdirs(dir, callback)\n\n    items = items.map(item => path.join(dir, item))\n\n    deleteItem()\n\n    function deleteItem () {\n      const item = items.pop()\n      if (!item) return callback()\n      remove.remove(item, err => {\n        if (err) return callback(err)\n        deleteItem()\n      })\n    }\n  })\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch (err) {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/empty/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/file.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/file.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', err => {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err\n    if (!err && stats.isFile()) return callback()\n    const dir = path.dirname(file)\n    pathExists(dir, (err, dirExists) => {\n      if (err) return callback(err)\n      if (dirExists) return makeFile()\n      mkdir.mkdirs(dir, err => {\n        if (err) return callback(err)\n        makeFile()\n      })\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch (e) {}\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/ensure/file.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst file = __webpack_require__(/*! ./file */ \"./node_modules/fs-extra/lib/ensure/file.js\")\nconst link = __webpack_require__(/*! ./link */ \"./node_modules/fs-extra/lib/ensure/link.js\")\nconst symlink = __webpack_require__(/*! ./symlink */ \"./node_modules/fs-extra/lib/ensure/symlink.js\")\n\nmodule.exports = {\n  // file\n  createFile: file.createFile,\n  createFileSync: file.createFileSync,\n  ensureFile: file.createFile,\n  ensureFileSync: file.createFileSync,\n  // link\n  createLink: link.createLink,\n  createLinkSync: link.createLinkSync,\n  ensureLink: link.createLink,\n  ensureLinkSync: link.createLinkSync,\n  // symlink\n  createSymlink: symlink.createSymlink,\n  createSymlinkSync: symlink.createSymlinkSync,\n  ensureSymlink: symlink.createSymlink,\n  ensureSymlinkSync: symlink.createSymlinkSync\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/ensure/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/link.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/link.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, err => {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, err => {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  try {\n    fs.lstatSync(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/ensure/link.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/symlink-paths.js":
/*!***********************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/symlink-paths.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        'toCwd': srcpath,\n        'toDst': srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err)\n      if (exists) {\n        return callback(null, {\n          'toCwd': relativeToDst,\n          'toDst': srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            'toCwd': srcpath,\n            'toDst': path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      'toCwd': srcpath,\n      'toDst': srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        'toCwd': relativeToDst,\n        'toDst': srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        'toCwd': srcpath,\n        'toDst': path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/ensure/symlink-paths.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/symlink-type.js":
/*!**********************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/symlink-type.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, (err, stats) => {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  let stats\n\n  if (type) return type\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch (e) {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType,\n  symlinkTypeSync\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/ensure/symlink-type.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/symlink.js":
/*!*****************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/symlink.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\nconst _mkdirs = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst mkdirs = _mkdirs.mkdirs\nconst mkdirsSync = _mkdirs.mkdirsSync\n\nconst _symlinkPaths = __webpack_require__(/*! ./symlink-paths */ \"./node_modules/fs-extra/lib/ensure/symlink-paths.js\")\nconst symlinkPaths = _symlinkPaths.symlinkPaths\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nconst _symlinkType = __webpack_require__(/*! ./symlink-type */ \"./node_modules/fs-extra/lib/ensure/symlink-type.js\")\nconst symlinkType = _symlinkType.symlinkType\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    symlinkPaths(srcpath, dstpath, (err, relative) => {\n      if (err) return callback(err)\n      srcpath = relative.toDst\n      symlinkType(relative.toCwd, type, (err, type) => {\n        if (err) return callback(err)\n        const dir = path.dirname(dstpath)\n        pathExists(dir, (err, dirExists) => {\n          if (err) return callback(err)\n          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n          mkdirs(dir, err => {\n            if (err) return callback(err)\n            fs.symlink(srcpath, dstpath, type, callback)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/ensure/symlink.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/fs/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fs-extra/lib/fs/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchown',\n  'lchmod',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'readFile',\n  'readdir',\n  'readlink',\n  'realpath',\n  'rename',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.copyFile was added in Node.js v8.5.0\n  // fs.mkdtemp was added in Node.js v5.10.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export all keys:\nObject.keys(fs).forEach(key => {\n  if (key === 'promises') {\n    // fs.promises is a getter property that triggers ExperimentalWarning\n    // Don't re-export it here, the getter is defined in \"lib/index.js\"\n    return\n  }\n  exports[key] = fs[key]\n})\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read() & fs.write need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n\n// fs.realpath.native only available in Node v9.2+\nif (typeof fs.realpath.native === 'function') {\n  exports.realpath.native = u(fs.realpath.native)\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/fs/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/fs-extra/lib/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = Object.assign(\n  {},\n  // Export promiseified graceful-fs:\n  __webpack_require__(/*! ./fs */ \"./node_modules/fs-extra/lib/fs/index.js\"),\n  // Export extra methods:\n  __webpack_require__(/*! ./copy-sync */ \"./node_modules/fs-extra/lib/copy-sync/index.js\"),\n  __webpack_require__(/*! ./copy */ \"./node_modules/fs-extra/lib/copy/index.js\"),\n  __webpack_require__(/*! ./empty */ \"./node_modules/fs-extra/lib/empty/index.js\"),\n  __webpack_require__(/*! ./ensure */ \"./node_modules/fs-extra/lib/ensure/index.js\"),\n  __webpack_require__(/*! ./json */ \"./node_modules/fs-extra/lib/json/index.js\"),\n  __webpack_require__(/*! ./mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\"),\n  __webpack_require__(/*! ./move-sync */ \"./node_modules/fs-extra/lib/move-sync/index.js\"),\n  __webpack_require__(/*! ./move */ \"./node_modules/fs-extra/lib/move/index.js\"),\n  __webpack_require__(/*! ./output */ \"./node_modules/fs-extra/lib/output/index.js\"),\n  __webpack_require__(/*! ./path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\"),\n  __webpack_require__(/*! ./remove */ \"./node_modules/fs-extra/lib/remove/index.js\")\n)\n\n// Export fs.promises as a getter property so that we don't trigger\n// ExperimentalWarning before fs.promises is actually accessed.\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nif (Object.getOwnPropertyDescriptor(fs, 'promises')) {\n  Object.defineProperty(module.exports, 'promises', {\n    get () { return fs.promises }\n  })\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/json/index.js":
/*!*************************************************!*\
  !*** ./node_modules/fs-extra/lib/json/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst jsonFile = __webpack_require__(/*! ./jsonfile */ \"./node_modules/fs-extra/lib/json/jsonfile.js\")\n\njsonFile.outputJson = u(__webpack_require__(/*! ./output-json */ \"./node_modules/fs-extra/lib/json/output-json.js\"))\njsonFile.outputJsonSync = __webpack_require__(/*! ./output-json-sync */ \"./node_modules/fs-extra/lib/json/output-json-sync.js\")\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/json/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/json/jsonfile.js":
/*!****************************************************!*\
  !*** ./node_modules/fs-extra/lib/json/jsonfile.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst jsonFile = __webpack_require__(/*! jsonfile */ \"./node_modules/jsonfile/index.js\")\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: u(jsonFile.readFile),\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: u(jsonFile.writeFile),\n  writeJsonSync: jsonFile.writeFileSync\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/json/jsonfile.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/json/output-json-sync.js":
/*!************************************************************!*\
  !*** ./node_modules/fs-extra/lib/json/output-json-sync.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst jsonFile = __webpack_require__(/*! ./jsonfile */ \"./node_modules/fs-extra/lib/json/jsonfile.js\")\n\nfunction outputJsonSync (file, data, options) {\n  const dir = path.dirname(file)\n\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  jsonFile.writeJsonSync(file, data, options)\n}\n\nmodule.exports = outputJsonSync\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/json/output-json-sync.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/json/output-json.js":
/*!*******************************************************!*\
  !*** ./node_modules/fs-extra/lib/json/output-json.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists\nconst jsonFile = __webpack_require__(/*! ./jsonfile */ \"./node_modules/fs-extra/lib/json/jsonfile.js\")\n\nfunction outputJson (file, data, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  const dir = path.dirname(file)\n\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return jsonFile.writeJson(file, data, options, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n      jsonFile.writeJson(file, data, options, callback)\n    })\n  })\n}\n\nmodule.exports = outputJson\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/json/output-json.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/mkdirs/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/mkdirs/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst mkdirs = u(__webpack_require__(/*! ./mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/mkdirs.js\"))\nconst mkdirsSync = __webpack_require__(/*! ./mkdirs-sync */ \"./node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js\")\n\nmodule.exports = {\n  mkdirs,\n  mkdirsSync,\n  // alias\n  mkdirp: mkdirs,\n  mkdirpSync: mkdirsSync,\n  ensureDir: mkdirs,\n  ensureDirSync: mkdirsSync\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/mkdirs/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js":
/*!*********************************************************!*\
  !*** ./node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst invalidWin32Path = __webpack_require__(/*! ./win32 */ \"./node_modules/fs-extra/lib/mkdirs/win32.js\").invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirsSync (p, opts, made) {\n  if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    throw errInval\n  }\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  p = path.resolve(p)\n\n  try {\n    xfs.mkdirSync(p, mode)\n    made = made || p\n  } catch (err0) {\n    if (err0.code === 'ENOENT') {\n      if (path.dirname(p) === p) throw err0\n      made = mkdirsSync(path.dirname(p), opts, made)\n      mkdirsSync(p, opts, made)\n    } else {\n      // In the case of any other error, just see if there's a dir there\n      // already. If so, then hooray!  If not, then something is borked.\n      let stat\n      try {\n        stat = xfs.statSync(p)\n      } catch (err1) {\n        throw err0\n      }\n      if (!stat.isDirectory()) throw err0\n    }\n  }\n\n  return made\n}\n\nmodule.exports = mkdirsSync\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/mkdirs/mkdirs.js":
/*!****************************************************!*\
  !*** ./node_modules/fs-extra/lib/mkdirs/mkdirs.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst invalidWin32Path = __webpack_require__(/*! ./win32 */ \"./node_modules/fs-extra/lib/mkdirs/win32.js\").invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirs (p, opts, callback, made) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  } else if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    return callback(errInval)\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  callback = callback || function () {}\n  p = path.resolve(p)\n\n  xfs.mkdir(p, mode, er => {\n    if (!er) {\n      made = made || p\n      return callback(null, made)\n    }\n    switch (er.code) {\n      case 'ENOENT':\n        if (path.dirname(p) === p) return callback(er)\n        mkdirs(path.dirname(p), opts, (er, made) => {\n          if (er) callback(er, made)\n          else mkdirs(p, opts, callback, made)\n        })\n        break\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        xfs.stat(p, (er2, stat) => {\n          // if the stat fails, then that's super weird.\n          // let the original error be the failure reason.\n          if (er2 || !stat.isDirectory()) callback(er, made)\n          else callback(null, made)\n        })\n        break\n    }\n  })\n}\n\nmodule.exports = mkdirs\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/mkdirs/mkdirs.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/mkdirs/win32.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/mkdirs/win32.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\n\n// get drive on windows\nfunction getRootPath (p) {\n  p = path.normalize(path.resolve(p)).split(path.sep)\n  if (p.length > 0) return p[0]\n  return null\n}\n\n// http://stackoverflow.com/a/62888/10333 contains more accurate\n// TODO: expand to include the rest\nconst INVALID_PATH_CHARS = /[<>:\"|?*]/\n\nfunction invalidWin32Path (p) {\n  const rp = getRootPath(p)\n  p = p.replace(rp, '')\n  return INVALID_PATH_CHARS.test(p)\n}\n\nmodule.exports = {\n  getRootPath,\n  invalidWin32Path\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/mkdirs/win32.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/move-sync/index.js":
/*!******************************************************!*\
  !*** ./node_modules/fs-extra/lib/move-sync/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  moveSync: __webpack_require__(/*! ./move-sync */ \"./node_modules/fs-extra/lib/move-sync/move-sync.js\")\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/move-sync/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/move-sync/move-sync.js":
/*!**********************************************************!*\
  !*** ./node_modules/fs-extra/lib/move-sync/move-sync.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst copySync = __webpack_require__(/*! ../copy-sync */ \"./node_modules/fs-extra/lib/copy-sync/index.js\").copySync\nconst removeSync = __webpack_require__(/*! ../remove */ \"./node_modules/fs-extra/lib/remove/index.js\").removeSync\nconst mkdirpSync = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\").mkdirpSync\nconst stat = __webpack_require__(/*! ../util/stat */ \"./node_modules/fs-extra/lib/util/stat.js\")\n\nfunction moveSync (src, dest, opts) {\n  opts = opts || {}\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  const { srcStat } = stat.checkPathsSync(src, dest, 'move')\n  stat.checkParentPathsSync(src, srcStat, dest, 'move')\n  mkdirpSync(path.dirname(dest))\n  return doRename(src, dest, overwrite)\n}\n\nfunction doRename (src, dest, overwrite) {\n  if (overwrite) {\n    removeSync(dest)\n    return rename(src, dest, overwrite)\n  }\n  if (fs.existsSync(dest)) throw new Error('dest already exists.')\n  return rename(src, dest, overwrite)\n}\n\nfunction rename (src, dest, overwrite) {\n  try {\n    fs.renameSync(src, dest)\n  } catch (err) {\n    if (err.code !== 'EXDEV') throw err\n    return moveAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveAcrossDevice (src, dest, overwrite) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copySync(src, dest, opts)\n  return removeSync(src)\n}\n\nmodule.exports = moveSync\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/move-sync/move-sync.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/move/index.js":
/*!*************************************************!*\
  !*** ./node_modules/fs-extra/lib/move/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nmodule.exports = {\n  move: u(__webpack_require__(/*! ./move */ \"./node_modules/fs-extra/lib/move/move.js\"))\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/move/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/move/move.js":
/*!************************************************!*\
  !*** ./node_modules/fs-extra/lib/move/move.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst copy = __webpack_require__(/*! ../copy */ \"./node_modules/fs-extra/lib/copy/index.js\").copy\nconst remove = __webpack_require__(/*! ../remove */ \"./node_modules/fs-extra/lib/remove/index.js\").remove\nconst mkdirp = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\").mkdirp\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists\nconst stat = __webpack_require__(/*! ../util/stat */ \"./node_modules/fs-extra/lib/util/stat.js\")\n\nfunction move (src, dest, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  stat.checkPaths(src, dest, 'move', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'move', err => {\n      if (err) return cb(err)\n      mkdirp(path.dirname(dest), err => {\n        if (err) return cb(err)\n        return doRename(src, dest, overwrite, cb)\n      })\n    })\n  })\n}\n\nfunction doRename (src, dest, overwrite, cb) {\n  if (overwrite) {\n    return remove(dest, err => {\n      if (err) return cb(err)\n      return rename(src, dest, overwrite, cb)\n    })\n  }\n  pathExists(dest, (err, destExists) => {\n    if (err) return cb(err)\n    if (destExists) return cb(new Error('dest already exists.'))\n    return rename(src, dest, overwrite, cb)\n  })\n}\n\nfunction rename (src, dest, overwrite, cb) {\n  fs.rename(src, dest, err => {\n    if (!err) return cb()\n    if (err.code !== 'EXDEV') return cb(err)\n    return moveAcrossDevice(src, dest, overwrite, cb)\n  })\n}\n\nfunction moveAcrossDevice (src, dest, overwrite, cb) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copy(src, dest, opts, err => {\n    if (err) return cb(err)\n    return remove(src, cb)\n  })\n}\n\nmodule.exports = move\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/move/move.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/output/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/output/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  const dir = path.dirname(file)\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync(file, ...args)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/output/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/path-exists/index.js":
/*!********************************************************!*\
  !*** ./node_modules/fs-extra/lib/path-exists/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromPromise\nconst fs = __webpack_require__(/*! ../fs */ \"./node_modules/fs-extra/lib/fs/index.js\")\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/path-exists/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/remove/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/remove/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst rimraf = __webpack_require__(/*! ./rimraf */ \"./node_modules/fs-extra/lib/remove/rimraf.js\")\n\nmodule.exports = {\n  remove: u(rimraf),\n  removeSync: rimraf.sync\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/remove/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/remove/rimraf.js":
/*!****************************************************!*\
  !*** ./node_modules/fs-extra/lib/remove/rimraf.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        const time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    } else if (er.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now()\n    do {\n      try {\n        const ret = options.rmdirSync(p, options)\n        return ret\n      } catch (er) { }\n    } while (Date.now() - startTime < 500) // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options)\n    return ret\n  }\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/remove/rimraf.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/util/buffer.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/util/buffer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable node/no-deprecated-api */\nmodule.exports = function (size) {\n  if (typeof Buffer.allocUnsafe === 'function') {\n    try {\n      return Buffer.allocUnsafe(size)\n    } catch (e) {\n      return new Buffer(size)\n    }\n  }\n  return new Buffer(size)\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/util/buffer.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/util/stat.js":
/*!************************************************!*\
  !*** ./node_modules/fs-extra/lib/util/stat.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\nconst NODE_VERSION_MAJOR_WITH_BIGINT = 10\nconst NODE_VERSION_MINOR_WITH_BIGINT = 5\nconst NODE_VERSION_PATCH_WITH_BIGINT = 0\nconst nodeVersion = process.versions.node.split('.')\nconst nodeVersionMajor = Number.parseInt(nodeVersion[0], 10)\nconst nodeVersionMinor = Number.parseInt(nodeVersion[1], 10)\nconst nodeVersionPatch = Number.parseInt(nodeVersion[2], 10)\n\nfunction nodeSupportsBigInt () {\n  if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {\n    return true\n  } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {\n    if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {\n      return true\n    } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {\n      if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfunction getStats (src, dest, cb) {\n  if (nodeSupportsBigInt()) {\n    fs.stat(src, { bigint: true }, (err, srcStat) => {\n      if (err) return cb(err)\n      fs.stat(dest, { bigint: true }, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\n          return cb(err)\n        }\n        return cb(null, { srcStat, destStat })\n      })\n    })\n  } else {\n    fs.stat(src, (err, srcStat) => {\n      if (err) return cb(err)\n      fs.stat(dest, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\n          return cb(err)\n        }\n        return cb(null, { srcStat, destStat })\n      })\n    })\n  }\n}\n\nfunction getStatsSync (src, dest) {\n  let srcStat, destStat\n  if (nodeSupportsBigInt()) {\n    srcStat = fs.statSync(src, { bigint: true })\n  } else {\n    srcStat = fs.statSync(src)\n  }\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(dest, { bigint: true })\n    } else {\n      destStat = fs.statSync(dest)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, cb) {\n  getStats(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName) {\n  const { srcStat, destStat } = getStatsSync(src, dest)\n  if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  if (nodeSupportsBigInt()) {\n    fs.stat(destParent, { bigint: true }, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb()\n        return cb(err)\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)))\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\n    })\n  } else {\n    fs.stat(destParent, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb()\n        return cb(err)\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)))\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\n    })\n  }\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(destParent, { bigint: true })\n    } else {\n      destStat = fs.statSync(destParent)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/util/stat.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/util/utimes.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/util/utimes.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js\")\nconst os = __webpack_require__(/*! os */ \"os\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\n// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not\nfunction hasMillisResSync () {\n  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')\n  const fd = fs.openSync(tmpfile, 'r+')\n  fs.futimesSync(fd, d, d)\n  fs.closeSync(fd)\n  return fs.statSync(tmpfile).mtime > 1435410243000\n}\n\nfunction hasMillisRes (callback) {\n  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {\n    if (err) return callback(err)\n    fs.open(tmpfile, 'r+', (err, fd) => {\n      if (err) return callback(err)\n      fs.futimes(fd, d, d, err => {\n        if (err) return callback(err)\n        fs.close(fd, err => {\n          if (err) return callback(err)\n          fs.stat(tmpfile, (err, stats) => {\n            if (err) return callback(err)\n            callback(null, stats.mtime > 1435410243000)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction timeRemoveMillis (timestamp) {\n  if (typeof timestamp === 'number') {\n    return Math.floor(timestamp / 1000) * 1000\n  } else if (timestamp instanceof Date) {\n    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)\n  } else {\n    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')\n  }\n}\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', (err, fd) => {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, futimesErr => {\n      fs.close(fd, closeErr => {\n        if (callback) callback(futimesErr || closeErr)\n      })\n    })\n  })\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  hasMillisRes,\n  hasMillisResSync,\n  timeRemoveMillis,\n  utimesMillis,\n  utimesMillisSync\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/lib/util/utimes.js?");

/***/ }),

/***/ "./node_modules/fs-extra/node_modules/graceful-fs/clone.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fs-extra/node_modules/graceful-fs/clone.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = clone\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/node_modules/graceful-fs/clone.js?");

/***/ }),

/***/ "./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js":
/*!***********************************************************************!*\
  !*** ./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fs = __webpack_require__(/*! fs */ \"fs\")\nvar polyfills = __webpack_require__(/*! ./polyfills.js */ \"./node_modules/fs-extra/node_modules/graceful-fs/polyfills.js\")\nvar legacy = __webpack_require__(/*! ./legacy-streams.js */ \"./node_modules/fs-extra/node_modules/graceful-fs/legacy-streams.js\")\nvar clone = __webpack_require__(/*! ./clone.js */ \"./node_modules/fs-extra/node_modules/graceful-fs/clone.js\")\n\nvar queue = []\n\nvar util = __webpack_require__(/*! util */ \"util\")\n\nfunction noop () {}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\nif (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n  process.on('exit', function() {\n    debug(queue)\n    __webpack_require__(/*! assert */ \"assert\").equal(queue.length, 0)\n  })\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\n// Always patch fs.close/closeSync, because we want to\n// retry() whenever a close happens *anywhere* in the program.\n// This is essential when multiple graceful-fs instances are\n// in play at the same time.\nmodule.exports.close = (function (fs$close) { return function (fd, cb) {\n  return fs$close.call(fs, fd, function (err) {\n    if (!err)\n      retry()\n\n    if (typeof cb === 'function')\n      cb.apply(this, arguments)\n  })\n}})(fs.close)\n\nmodule.exports.closeSync = (function (fs$closeSync) { return function (fd) {\n  // Note that graceful-fs also retries when fs.closeSync() fails.\n  // Looks like a bug to me, although it's probably a harmless one.\n  var rval = fs$closeSync.apply(fs, arguments)\n  retry()\n  return rval\n}})(fs.closeSync)\n\n// Only patch fs once, otherwise we'll run into a memory leak if\n// graceful-fs is loaded multiple times, such as in test environments that\n// reset the loaded modules between tests.\n// We look for the string `graceful-fs` from the comment above. This\n// way we are not adding any extra properties and it will detect if older\n// versions of graceful-fs are installed.\nif (!/\\bgraceful-fs\\b/.test(fs.closeSync.toString())) {\n  fs.closeSync = module.exports.closeSync;\n  fs.close = module.exports.close;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n  fs.FileReadStream = ReadStream;  // Legacy name.\n  fs.FileWriteStream = WriteStream;  // Legacy name.\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  fs.ReadStream = ReadStream\n  fs.WriteStream = WriteStream\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  queue.push(elem)\n}\n\nfunction retry () {\n  var elem = queue.shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js?");

/***/ }),

/***/ "./node_modules/fs-extra/node_modules/graceful-fs/legacy-streams.js":
/*!**************************************************************************!*\
  !*** ./node_modules/fs-extra/node_modules/graceful-fs/legacy-streams.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Stream = __webpack_require__(/*! stream */ \"stream\").Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/node_modules/graceful-fs/legacy-streams.js?");

/***/ }),

/***/ "./node_modules/fs-extra/node_modules/graceful-fs/polyfills.js":
/*!*********************************************************************!*\
  !*** ./node_modules/fs-extra/node_modules/graceful-fs/polyfills.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var constants = __webpack_require__(/*! constants */ \"constants\")\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {\n    var callback\n    if (callback_ && typeof callback_ === 'function') {\n      var eagCounter = 0\n      callback = function (er, _, __) {\n        if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n        }\n        callback_.apply(this, arguments)\n      }\n    }\n    return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n  }})(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options, cb) {\n      if (typeof options === 'function') {\n        cb = options\n        options = null\n      }\n      function callback (er, stats) {\n        if (stats) {\n          if (stats.uid < 0) stats.uid += 0x100000000\n          if (stats.gid < 0) stats.gid += 0x100000000\n        }\n        if (cb) cb.apply(this, arguments)\n      }\n      return options ? orig.call(fs, target, options, callback)\n        : orig.call(fs, target, callback)\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options) {\n      var stats = options ? orig.call(fs, target, options)\n        : orig.call(fs, target)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/fs-extra/node_modules/graceful-fs/polyfills.js?");

/***/ }),

/***/ "./node_modules/graceful-fs/clone.js":
/*!*******************************************!*\
  !*** ./node_modules/graceful-fs/clone.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = clone\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n\n\n//# sourceURL=webpack:///./node_modules/graceful-fs/clone.js?");

/***/ }),

/***/ "./node_modules/graceful-fs/graceful-fs.js":
/*!*************************************************!*\
  !*** ./node_modules/graceful-fs/graceful-fs.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fs = __webpack_require__(/*! fs */ \"fs\")\nvar polyfills = __webpack_require__(/*! ./polyfills.js */ \"./node_modules/graceful-fs/polyfills.js\")\nvar legacy = __webpack_require__(/*! ./legacy-streams.js */ \"./node_modules/graceful-fs/legacy-streams.js\")\nvar clone = __webpack_require__(/*! ./clone.js */ \"./node_modules/graceful-fs/clone.js\")\n\nvar queue = []\n\nvar util = __webpack_require__(/*! util */ \"util\")\n\nfunction noop () {}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\nif (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n  process.on('exit', function() {\n    debug(queue)\n    __webpack_require__(/*! assert */ \"assert\").equal(queue.length, 0)\n  })\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\n// Always patch fs.close/closeSync, because we want to\n// retry() whenever a close happens *anywhere* in the program.\n// This is essential when multiple graceful-fs instances are\n// in play at the same time.\nmodule.exports.close = (function (fs$close) { return function (fd, cb) {\n  return fs$close.call(fs, fd, function (err) {\n    if (!err)\n      retry()\n\n    if (typeof cb === 'function')\n      cb.apply(this, arguments)\n  })\n}})(fs.close)\n\nmodule.exports.closeSync = (function (fs$closeSync) { return function (fd) {\n  // Note that graceful-fs also retries when fs.closeSync() fails.\n  // Looks like a bug to me, although it's probably a harmless one.\n  var rval = fs$closeSync.apply(fs, arguments)\n  retry()\n  return rval\n}})(fs.closeSync)\n\n// Only patch fs once, otherwise we'll run into a memory leak if\n// graceful-fs is loaded multiple times, such as in test environments that\n// reset the loaded modules between tests.\n// We look for the string `graceful-fs` from the comment above. This\n// way we are not adding any extra properties and it will detect if older\n// versions of graceful-fs are installed.\nif (!/\\bgraceful-fs\\b/.test(fs.closeSync.toString())) {\n  fs.closeSync = module.exports.closeSync;\n  fs.close = module.exports.close;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n  fs.FileReadStream = ReadStream;  // Legacy name.\n  fs.FileWriteStream = WriteStream;  // Legacy name.\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  fs.ReadStream = ReadStream\n  fs.WriteStream = WriteStream\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  queue.push(elem)\n}\n\nfunction retry () {\n  var elem = queue.shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/graceful-fs/graceful-fs.js?");

/***/ }),

/***/ "./node_modules/graceful-fs/legacy-streams.js":
/*!****************************************************!*\
  !*** ./node_modules/graceful-fs/legacy-streams.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Stream = __webpack_require__(/*! stream */ \"stream\").Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/graceful-fs/legacy-streams.js?");

/***/ }),

/***/ "./node_modules/graceful-fs/polyfills.js":
/*!***********************************************!*\
  !*** ./node_modules/graceful-fs/polyfills.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var constants = __webpack_require__(/*! constants */ \"constants\")\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {\n    var callback\n    if (callback_ && typeof callback_ === 'function') {\n      var eagCounter = 0\n      callback = function (er, _, __) {\n        if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n        }\n        callback_.apply(this, arguments)\n      }\n    }\n    return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n  }})(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, cb) {\n      return orig.call(fs, target, function (er, stats) {\n        if (!stats) return cb.apply(this, arguments)\n        if (stats.uid < 0) stats.uid += 0x100000000\n        if (stats.gid < 0) stats.gid += 0x100000000\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target) {\n      var stats = orig.call(fs, target)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/graceful-fs/polyfills.js?");

/***/ }),

/***/ "./node_modules/jsonfile/index.js":
/*!****************************************!*\
  !*** ./node_modules/jsonfile/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _fs\ntry {\n  _fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\n} catch (_) {\n  _fs = __webpack_require__(/*! fs */ \"fs\")\n}\n\nfunction readFile (file, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  fs.readFile(file, options, function (err, data) {\n    if (err) return callback(err)\n\n    data = stripBom(data)\n\n    var obj\n    try {\n      obj = JSON.parse(data, options ? options.reviver : null)\n    } catch (err2) {\n      if (shouldThrow) {\n        err2.message = file + ': ' + err2.message\n        return callback(err2)\n      } else {\n        return callback(null, null)\n      }\n    }\n\n    callback(null, obj)\n  })\n}\n\nfunction readFileSync (file, options) {\n  options = options || {}\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  try {\n    var content = fs.readFileSync(file, options)\n    content = stripBom(content)\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = file + ': ' + err.message\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nfunction stringify (obj, options) {\n  var spaces\n  var EOL = '\\n'\n  if (typeof options === 'object' && options !== null) {\n    if (options.spaces) {\n      spaces = options.spaces\n    }\n    if (options.EOL) {\n      EOL = options.EOL\n    }\n  }\n\n  var str = JSON.stringify(obj, options ? options.replacer : null, spaces)\n\n  return str.replace(/\\n/g, EOL) + EOL\n}\n\nfunction writeFile (file, obj, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var str = ''\n  try {\n    str = stringify(obj, options)\n  } catch (err) {\n    // Need to return whether a callback was passed or not\n    if (callback) callback(err, null)\n    return\n  }\n\n  fs.writeFile(file, str, options, callback)\n}\n\nfunction writeFileSync (file, obj, options) {\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var str = stringify(obj, options)\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  content = content.replace(/^\\uFEFF/, '')\n  return content\n}\n\nvar jsonfile = {\n  readFile: readFile,\n  readFileSync: readFileSync,\n  writeFile: writeFile,\n  writeFileSync: writeFileSync\n}\n\nmodule.exports = jsonfile\n\n\n//# sourceURL=webpack:///./node_modules/jsonfile/index.js?");

/***/ }),

/***/ "./node_modules/node-gyp-build/index.js":
/*!**********************************************!*\
  !*** ./node_modules/node-gyp-build/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fs = __webpack_require__(/*! fs */ \"fs\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar os = __webpack_require__(/*! os */ \"os\")\n\n// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'\nvar runtimeRequire =  true ? require : undefined // eslint-disable-line\n\nvar abi = process.versions.modules // TODO: support old node where this is undef\nvar runtime = isElectron() ? 'electron' : 'node'\nvar arch = os.arch()\nvar platform = os.platform()\n\nmodule.exports = load\n\nfunction load (dir) {\n  return runtimeRequire(load.path(dir))\n}\n\nload.path = function (dir) {\n  dir = path.resolve(dir || '.')\n\n  try {\n    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')\n    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']\n  } catch (err) {}\n\n  var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n  if (release) return release\n\n  var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n  if (debug) return debug\n\n  var prebuild = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchPrebuild)\n  if (prebuild) return prebuild\n\n  var napiRuntime = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchNapiRuntime)\n  if (napiRuntime) return napiRuntime\n\n  var napi = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchNapi)\n  if (napi) return napi\n\n  throw new Error('No native build was found for runtime=' + runtime + ' abi=' + abi + ' platform=' + platform + ' arch=' + arch)\n}\n\nfunction getFirst (dir, filter) {\n  try {\n    var files = fs.readdirSync(dir).filter(filter)\n    return files[0] && path.join(dir, files[0])\n  } catch (err) {\n    return null\n  }\n}\n\nfunction matchNapiRuntime (name) {\n  return name === runtime + '-napi.node'\n}\n\nfunction matchNapi (name) {\n  return name === 'node-napi.node'\n}\n\nfunction matchPrebuild (name) {\n  var parts = name.split('-')\n  return parts[0] === runtime && parts[1] === abi + '.node'\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n\n\n//# sourceURL=webpack:///./node_modules/node-gyp-build/index.js?");

/***/ }),

/***/ "./node_modules/universalify/index.js":
/*!********************************************!*\
  !*** ./node_modules/universalify/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function () {\n    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)\n    else {\n      return new Promise((resolve, reject) => {\n        arguments[arguments.length] = (err, res) => {\n          if (err) return reject(err)\n          resolve(res)\n        }\n        arguments.length++\n        fn.apply(this, arguments)\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function () {\n    const cb = arguments[arguments.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, arguments)\n    else fn.apply(this, arguments).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n\n\n//# sourceURL=webpack:///./node_modules/universalify/index.js?");

/***/ }),

/***/ "./node_modules/utf-8-validate/fallback.js":
/*!*************************************************!*\
  !*** ./node_modules/utf-8-validate/fallback.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nconst isValidUTF8 = (buf) => {\n  var len = buf.length;\n  var i = 0;\n\n  while (i < len) {\n    if (buf[i] < 0x80) {  // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {  // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0  // overlong\n      ) {\n        return false;\n      } else {\n        i += 2;\n      }\n    } else if ((buf[i] & 0xf0) === 0xe0) {  // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||  // overlong\n        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0     // surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      } else {\n        i += 3;\n      }\n    } else if ((buf[i] & 0xf8) === 0xf0) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||  // overlong\n        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4  // > U+10FFFF\n      ) {\n        return false;\n      } else {\n        i += 4;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = isValidUTF8;\n\n\n//# sourceURL=webpack:///./node_modules/utf-8-validate/fallback.js?");

/***/ }),

/***/ "./node_modules/utf-8-validate/index.js":
/*!**********************************************!*\
  !*** ./node_modules/utf-8-validate/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\ntry {\n  module.exports = __webpack_require__(/*! node-gyp-build */ \"./node_modules/node-gyp-build/index.js\")(__dirname);\n} catch (e) {\n  module.exports = __webpack_require__(/*! ./fallback */ \"./node_modules/utf-8-validate/fallback.js\");\n}\n\n\n//# sourceURL=webpack:///./node_modules/utf-8-validate/index.js?");

/***/ }),

/***/ "./node_modules/ws/index.js":
/*!**********************************!*\
  !*** ./node_modules/ws/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"./node_modules/ws/lib/websocket.js\");\n\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"./node_modules/ws/lib/websocket-server.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"./node_modules/ws/lib/receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"./node_modules/ws/lib/sender.js\");\n\nmodule.exports = WebSocket;\n\n\n//# sourceURL=webpack:///./node_modules/ws/index.js?");

/***/ }),

/***/ "./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    buf.copy(target, offset);\n    offset += buf.length;\n  }\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (let i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = viewToBuffer(data);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\n/**\n * Converts an `ArrayBuffer` view into a buffer.\n *\n * @param {(DataView|TypedArray)} view The view to convert\n * @return {Buffer} Converted view\n * @private\n */\nfunction viewToBuffer(view) {\n  const buf = Buffer.from(view.buffer);\n\n  if (view.byteLength !== view.buffer.byteLength) {\n    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);\n  }\n\n  return buf;\n}\n\ntry {\n  const bufferUtil = __webpack_require__(/*! bufferutil */ \"./node_modules/bufferutil/index.js\");\n  const bu = bufferUtil.BufferUtil || bufferUtil;\n\n  module.exports = {\n    concat,\n    mask(source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bu.mask(source, mask, output, offset, length);\n    },\n    toArrayBuffer,\n    toBuffer,\n    unmask(buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bu.unmask(buffer, mask);\n    }\n  };\n} catch (e) /* istanbul ignore next */ {\n  module.exports = {\n    concat,\n    mask: _mask,\n    toArrayBuffer,\n    toBuffer,\n    unmask: _unmask\n  };\n}\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/buffer-util.js?");

/***/ }),

/***/ "./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  EMPTY_BUFFER: Buffer.alloc(0),\n  NOOP: () => {}\n};\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/constants.js?");

/***/ }),

/***/ "./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Class representing an event.\n *\n * @private\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} target A reference to the target to which the event was dispatched\n   */\n  constructor(type, target) {\n    this.target = target;\n    this.type = type;\n  }\n}\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n * @private\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(data, target) {\n    super('message', target);\n\n    this.data = data;\n  }\n}\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n * @private\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {Number} code The status code explaining why the connection is being closed\n   * @param {String} reason A human-readable string explaining why the connection is closing\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(code, reason, target) {\n    super('close', target);\n\n    this.wasClean = target._closeFrameReceived && target._closeFrameSent;\n    this.reason = reason;\n    this.code = code;\n  }\n}\n\n/**\n * Class representing an open event.\n *\n * @extends Event\n * @private\n */\nclass OpenEvent extends Event {\n  /**\n   * Create a new `OpenEvent`.\n   *\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(target) {\n    super('open', target);\n  }\n}\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n * @private\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {Object} error The error that generated this event\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(error, target) {\n    super('error', target);\n\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} method A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @public\n   */\n  addEventListener(method, listener) {\n    if (typeof listener !== 'function') return;\n\n    function onMessage(data) {\n      listener.call(this, new MessageEvent(data, this));\n    }\n\n    function onClose(code, message) {\n      listener.call(this, new CloseEvent(code, message, this));\n    }\n\n    function onError(error) {\n      listener.call(this, new ErrorEvent(error, this));\n    }\n\n    function onOpen() {\n      listener.call(this, new OpenEvent(this));\n    }\n\n    if (method === 'message') {\n      onMessage._listener = listener;\n      this.on(method, onMessage);\n    } else if (method === 'close') {\n      onClose._listener = listener;\n      this.on(method, onClose);\n    } else if (method === 'error') {\n      onError._listener = listener;\n      this.on(method, onError);\n    } else if (method === 'open') {\n      onOpen._listener = listener;\n      this.on(method, onOpen);\n    } else {\n      this.on(method, listener);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} method A string representing the event type to remove\n   * @param {Function} listener The listener to remove\n   * @public\n   */\n  removeEventListener(method, listener) {\n    const listeners = this.listeners(method);\n\n    for (let i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener || listeners[i]._listener === listener) {\n        this.removeListener(method, listeners[i]);\n      }\n    }\n  }\n};\n\nmodule.exports = EventTarget;\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/event-target.js?");

/***/ }),

/***/ "./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n\n  if (header === undefined || header === '') return offers;\n\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\\t' */) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/extension.js?");

/***/ }),

/***/ "./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Limiter = __webpack_require__(/*! async-limiter */ \"./node_modules/async-limiter/index.js\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\nconst { kStatusCode, NOOP } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst EMPTY_BLOCK = Buffer.from([0x00]);\n\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\n   *     of server context takeover\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\n   *     disabling of client context takeover\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\n   *     use of a custom server window size\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\n   *     for, or request, a custom client window size\n   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate\n   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate\n   * @param {Number} options.threshold Size (in bytes) below which messages\n   *     should not be compressed\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\n   *     zlib\n   * @param {Boolean} isServer Create the instance in either server or client\n   *     mode\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter({ concurrency });\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      this._deflate.close();\n      this._deflate = null;\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited by async-limiter.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.push((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited by async-limiter.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.push((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    if (!data || data.length === 0) {\n      process.nextTick(callback, null, EMPTY_BLOCK);\n      return;\n    }\n\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      //\n      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the\n      // `zlib.DeflateRaw` instance is closed while data is being processed.\n      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong\n      // time due to an abnormal WebSocket closure.\n      //\n      this._deflate.on('error', NOOP);\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // This `if` statement is only needed for Node.js < 10.0.0 because as of\n        // commit https://github.com/nodejs/node/commit/5e3f5164, the flush\n        // callback is no longer called if the deflate stream is closed while\n        // data is being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) data = data.slice(0, data.length - 4);\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.close();\n        this._deflate = null;\n      } else {\n        this._deflate[kTotalLength] = 0;\n        this._deflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/permessage-deflate.js?");

/***/ }),

/***/ "./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends stream.Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {String} binaryType The type for binary data\n   * @param {Object} extensions An object containing the negotiated extensions\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor(binaryType, extensions, maxPayload) {\n    super();\n\n    this._binaryType = binaryType || BINARY_TYPES[0];\n    this[kWebSocket] = undefined;\n    this._extensions = extensions || {};\n    this._maxPayload = maxPayload | 0;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = buf.slice(n);\n      return buf.slice(0, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n\n      if (n >= buf.length) {\n        this._buffers.shift().copy(dst, dst.length - n);\n      } else {\n        buf.copy(dst, dst.length - n, 0, n);\n        this._buffers[0] = buf.slice(n);\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          // `INFLATING`\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    cb(err);\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this._loop = false;\n      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this._loop = false;\n      return error(RangeError, 'RSV1 must be clear', true, 1002);\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\n      }\n\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(RangeError, 'invalid opcode 0', true, 1002);\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(RangeError, 'FIN must be set', true, 1002);\n      }\n\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002\n        );\n      }\n    } else {\n      this._loop = false;\n      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009\n      );\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(RangeError, 'Max payload size exceeded', false, 1009);\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n      if (this._masked) unmask(data, this._mask);\n    }\n\n    if (this._opcode > 0x07) return this.controlMessage(data);\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its lenght is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    return this.dataMessage();\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(\n            error(RangeError, 'Max payload size exceeded', false, 1009)\n          );\n        }\n\n        this._fragments.push(buf);\n      }\n\n      const er = this.dataMessage();\n      if (er) return cb(er);\n\n      this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        let data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.emit('message', data);\n      } else {\n        const buf = concat(fragments, messageLength);\n\n        if (!isValidUTF8(buf)) {\n          this._loop = false;\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n        }\n\n        this.emit('message', buf.toString());\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      this._loop = false;\n\n      if (data.length === 0) {\n        this.emit('conclude', 1005, '');\n        this.end();\n      } else if (data.length === 1) {\n        return error(RangeError, 'invalid payload length 1', true, 1002);\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          return error(RangeError, `invalid status code ${code}`, true, 1002);\n        }\n\n        const buf = data.slice(2);\n\n        if (!isValidUTF8(buf)) {\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n        }\n\n        this.emit('conclude', code, buf.toString());\n        this.end();\n      }\n    } else if (this._opcode === 0x09) {\n      this.emit('ping', data);\n    } else {\n      this.emit('pong', data);\n    }\n\n    this._state = GET_INFO;\n  }\n}\n\nmodule.exports = Receiver;\n\n/**\n * Builds an error object.\n *\n * @param {(Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @return {(Error|RangeError)} The error\n * @private\n */\nfunction error(ErrorCtor, message, prefix, statusCode) {\n  const err = new ErrorCtor(\n    prefix ? `Invalid WebSocket frame: ${message}` : message\n  );\n\n  Error.captureStackTrace(err, error);\n  err[kStatusCode] = statusCode;\n  return err;\n}\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/receiver.js?");

/***/ }),

/***/ "./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst { isValidStatusCode } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\n\nconst mask = Buffer.alloc(4);\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {net.Socket} socket The connection socket\n   * @param {Object} extensions An object containing the negotiated extensions\n   */\n  constructor(socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n  static frame(data, options) {\n    const merge = options.mask && options.readOnly;\n    let offset = options.mask ? 6 : 2;\n    let payloadLength = data.length;\n\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2);\n      target.writeUInt32BE(data.length, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    randomFillSync(mask, 0, 4);\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, data.length);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {(Number|undefined)} code The status code component of the body\n   * @param {String} data The message component of the body\n   * @param {Boolean} mask Specifies whether or not to mask the message\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || data === '') {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));\n      buf.writeUInt16BE(code, 0);\n      buf.write(data, 2);\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @private\n   */\n  doClose(data, mask, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x08,\n        mask,\n        readOnly: false\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (this._deflating) {\n      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPing(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n  doPing(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x09,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (this._deflating) {\n      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPong(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n  doPong(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x0a,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const buf = toBuffer(data);\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate) {\n        rsv1 = buf.length >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);\n      } else {\n        this.dispatch(buf, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(buf, {\n          fin: options.fin,\n          rsv1: false,\n          opcode,\n          mask: options.mask,\n          readOnly: toBuffer.readOnly\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} compress Specifies whether or not to compress `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @param {Function} cb Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[1].length;\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[1].length;\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} cb Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/sender.js?");

/***/ }),

/***/ "./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\ntry {\n  const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"./node_modules/utf-8-validate/index.js\");\n\n  exports.isValidUTF8 =\n    typeof isValidUTF8 === 'object'\n      ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0\n      : isValidUTF8;\n} catch (e) /* istanbul ignore next */ {\n  exports.isValidUTF8 = () => true;\n}\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nexports.isValidStatusCode = (code) => {\n  return (\n    (code >= 1000 &&\n      code <= 1013 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n};\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/validation.js?");

/***/ }),

/***/ "./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { createServer, STATUS_CODES } = __webpack_require__(/*! http */ \"http\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"./node_modules/ws/lib/websocket.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"./node_modules/ws/lib/extension.js\");\nconst { GUID } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} options.backlog The maximum length of the queue of pending\n   *     connections\n   * @param {Boolean} options.clientTracking Specifies whether or not to track\n   *     clients\n   * @param {Function} options.handleProtocols An hook to handle protocols\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {String} options.path Accept only connections matching this path\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable\n   *     permessage-deflate\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient An hook to reject connections\n   * @param {Function} callback A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      ...options\n    };\n\n    if (options.port == null && !options.server && !options.noServer) {\n      throw new TypeError(\n        'One of the \"port\", \"server\", or \"noServer\" options must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = createServer((req, res) => {\n        const body = STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, (ws) => {\n            this.emit('connection', ws, req);\n          });\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) this.clients = new Set();\n    this.options = options;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(cb) {\n    if (cb) this.once('close', cb);\n\n    //\n    // Terminate all associated clients.\n    //\n    if (this.clients) {\n      for (const client of this.clients) client.terminate();\n    }\n\n    const server = this._server;\n\n    if (server) {\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // Close the http server if it was internally created.\n      //\n      if (this.options.port != null) {\n        server.close(() => this.emit('close'));\n        return;\n      }\n    }\n\n    process.nextTick(emitClose, this);\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key =\n      req.headers['sec-websocket-key'] !== undefined\n        ? req.headers['sec-websocket-key'].trim()\n        : false;\n    const version = +req.headers['sec-websocket-version'];\n    const extensions = {};\n\n    if (\n      req.method !== 'GET' ||\n      req.headers.upgrade.toLowerCase() !== 'websocket' ||\n      !key ||\n      !keyRegex.test(key) ||\n      (version !== 8 && version !== 13) ||\n      !this.shouldHandle(req)\n    ) {\n      return abortHandshake(socket, 400);\n    }\n\n    if (this.options.perMessageDeflate) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = parse(req.headers['sec-websocket-extensions']);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.connection.authorized || req.connection.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(key, extensions, req, socket, head, cb);\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(key, extensions, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Object} extensions The accepted extensions\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @private\n   */\n  completeUpgrade(key, extensions, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new WebSocket(null);\n    let protocol = req.headers['sec-websocket-protocol'];\n\n    if (protocol) {\n      protocol = protocol.trim().split(/ *, */);\n\n      //\n      // Optionally call external protocol selection handler.\n      //\n      if (this.options.handleProtocols) {\n        protocol = this.options.handleProtocols(protocol, req);\n      } else {\n        protocol = protocol[0];\n      }\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws.protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, this.options.maxPayload);\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => this.clients.delete(ws));\n    }\n\n    cb(ws);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server.emit('close');\n}\n\n/**\n * Handle premature socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  if (socket.writable) {\n    message = message || STATUS_CODES[code];\n    headers = {\n      Connection: 'close',\n      'Content-type': 'text/html',\n      'Content-Length': Buffer.byteLength(message),\n      ...headers\n    };\n\n    socket.write(\n      `HTTP/1.1 ${code} ${STATUS_CODES[code]}\\r\\n` +\n        Object.keys(headers)\n          .map((h) => `${h}: ${headers[h]}`)\n          .join('\\r\\n') +\n        '\\r\\n\\r\\n' +\n        message\n    );\n  }\n\n  socket.removeListener('error', socketOnError);\n  socket.destroy();\n}\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/websocket-server.js?");

/***/ }),

/***/ "./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"./node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"./node_modules/ws/lib/sender.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst { addEventListener, removeEventListener } = __webpack_require__(/*! ./event-target */ \"./node_modules/ws/lib/event-target.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"./node_modules/ws/lib/extension.js\");\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|url.URL)} address The URL to which to connect\n   * @param {(String|String[])} protocols The subprotocols\n   * @param {Object} options Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this.readyState = WebSocket.CONNECTING;\n    this.protocol = '';\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = '';\n    this._closeTimer = null;\n    this._closeCode = 1006;\n    this._extensions = {};\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (Array.isArray(protocols)) {\n        protocols = protocols.join(', ');\n      } else if (typeof protocols === 'object' && protocols !== null) {\n        options = protocols;\n        protocols = undefined;\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  get CONNECTING() {\n    return WebSocket.CONNECTING;\n  }\n  get CLOSING() {\n    return WebSocket.CLOSING;\n  }\n  get CLOSED() {\n    return WebSocket.CLOSED;\n  }\n  get OPEN() {\n    return WebSocket.OPEN;\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    //\n    // `socket.bufferSize` is `undefined` if the socket is closed.\n    //\n    return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Number} maxPayload The maximum allowed message size\n   * @private\n   */\n  setSocket(socket, head, maxPayload) {\n    const receiver = new Receiver(\n      this._binaryType,\n      this._extensions,\n      maxPayload\n    );\n\n    this._sender = new Sender(socket, this._extensions);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this.readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    this.readyState = WebSocket.CLOSED;\n\n    if (!this._socket) {\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} code Status code explaining why the connection is closing\n   * @param {String} data A string explaining why the connection is closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\n      return;\n    }\n\n    this.readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n      if (this._closeFrameReceived) this._socket.end();\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this.readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\nreadyStates.forEach((readyState, i) => {\n  WebSocket[readyState] = i;\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    /**\n     * Return the listener of the event.\n     *\n     * @return {(Function|undefined)} The event listener or `undefined`\n     * @public\n     */\n    get() {\n      const listeners = this.listeners(method);\n      for (let i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n\n      return undefined;\n    },\n    /**\n     * Add a listener for the event.\n     *\n     * @param {Function} listener The listener to add\n     * @public\n     */\n    set(listener) {\n      const listeners = this.listeners(method);\n      for (let i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n      this.addEventListener(method, listener);\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|url.URL)} address The URL to which to connect\n * @param {String} protocols The subprotocols\n * @param {Object} options Connection options\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable\n *     permessage-deflate\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the\n *     handshake request\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version`\n *     header\n * @param {String} options.origin Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {Number} options.maxPayload The maximum allowed message size\n * @param {Boolean} options.followRedirects Whether or not to follow redirects\n * @param {Number} options.maxRedirects The maximum number of redirects allowed\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    auth: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket.url = address.href;\n  } else {\n    parsedUrl = new URL(address);\n    websocket.url = address;\n  }\n\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n\n  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {\n    throw new Error(`Invalid URL: ${websocket.url}`);\n  }\n\n  const isSecure =\n    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const get = isSecure ? https.get : http.get;\n  let perMessageDeflate;\n\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket',\n    ...opts.headers\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols) {\n    opts.headers['Sec-WebSocket-Protocol'] = protocols;\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req = (websocket._req = get(opts));\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (websocket._req.aborted) return;\n\n    req = websocket._req = null;\n    websocket.readyState = WebSocket.CLOSING;\n    websocket.emit('error', err);\n    websocket.emitClose();\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      const addr = new URL(location, address);\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    const protList = (protocols || '').split(/, */);\n    let protError;\n\n    if (!protocols && serverProt) {\n      protError = 'Server sent a subprotocol but none was requested';\n    } else if (protocols && !serverProt) {\n      protError = 'Server sent no subprotocol';\n    } else if (serverProt && !protList.includes(serverProt)) {\n      protError = 'Server sent an invalid subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket.protocol = serverProt;\n\n    if (perMessageDeflate) {\n      try {\n        const extensions = parse(res.headers['sec-websocket-extensions']);\n\n        if (extensions[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n          websocket._extensions[\n            PerMessageDeflate.extensionName\n          ] = perMessageDeflate;\n        }\n      } catch (err) {\n        abortHandshake(\n          websocket,\n          socket,\n          'Invalid Sec-WebSocket-Extensions header'\n        );\n        return;\n      }\n    }\n\n    websocket.setSocket(socket, head, opts.maxPayload);\n  });\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n  options.servername = options.servername || options.host;\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the\n *     socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket.readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} data The data to send\n * @param {Function} cb Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    cb(err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {String} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n  websocket._socket.resume();\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  this[kWebSocket]._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._closeCode = err[kStatusCode];\n  websocket.emit('error', err);\n  websocket._socket.destroy();\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message\n * @private\n */\nfunction receiverOnMessage(data) {\n  this[kWebSocket].emit('message', data);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('end', socketOnEnd);\n\n  websocket.readyState = WebSocket.CLOSING;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk and emitted synchronously in a single\n  // `'data'` event.\n  //\n  websocket._socket.read();\n  websocket._receiver.end();\n\n  this.removeListener('data', socketOnData);\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  websocket.readyState = WebSocket.CLOSING;\n  this.destroy();\n}\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/websocket.js?");

/***/ }),

/***/ "./src/mono.js":
/*!*********************!*\
  !*** ./src/mono.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Adapted from Ooui v0.10.222. */\r\nconst debug = false;\r\n\r\nlet ENVIRONMENT_IS_WEB = typeof window === \"object\";\r\nlet ENVIRONMENT_IS_WORKER = typeof importScripts === \"function\";\r\nlet ENVIRONMENT_IS_NODE = typeof process === \"object\" && \"function\" === \"function\" && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\r\nlet ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\r\n\r\nlet ___errno_location;\r\nlet _emscripten_replace_memory;\r\nlet _free;\r\nlet _htonl;\r\nlet _htons;\r\nlet _malloc;\r\nlet _memalign;\r\nlet _memset;\r\nlet _mono_background_exec;\r\nlet _mono_print_method_from_ip;\r\nlet _mono_set_timeout_exec;\r\nlet _mono_wasm_assembly_find_class;\r\nlet _mono_wasm_assembly_find_method;\r\nlet _mono_wasm_assembly_load;\r\nlet _mono_wasm_current_bp_id;\r\nlet _mono_wasm_enum_frames;\r\nlet _mono_wasm_get_var_info;\r\nlet _mono_wasm_invoke_method;\r\nlet _mono_wasm_load_runtime;\r\nlet _mono_wasm_set_breakpoint;\r\nlet _mono_wasm_string_from_js;\r\nlet _mono_wasm_string_get_utf8;\r\nlet _ntohs;\r\nlet _wasm_get_stack_base;\r\nlet _wasm_get_stack_size;\r\nlet stackAlloc;\r\nlet stackRestore;\r\nlet stackSave;\r\nlet dynCall_v;\r\nlet dynCall_vi;\r\n\r\nconst Module = {\r\n  assemblies: [\r\n    'ink_compiler.dll',\r\n    'ink-engine-runtime.dll',\r\n    'inklecate_wasm.dll',\r\n    'mscorlib.dll',\r\n    'System.Core.dll',\r\n    'System.dll',\r\n  ],\r\n\r\n  entryPoint: {\r\n    assemblyName: 'inklecate_wasm',\r\n    nsName: 'inklecate_wasm',\r\n    className: 'Program',\r\n    mainMethodName: 'Main',\r\n  },\r\n\r\n  /* Do not change the below to an arrow function! It needs the scope. */\r\n  onRuntimeInitialized: function (resolve) {\r\n    if (debug) console.log('Done with WASM module instantiation.');\r\n\r\n    Module.FS_createPath('/', 'managed', true, true);\r\n\r\n    var pending = 0;\r\n    this.assemblies.forEach((asmName) => {\r\n      if (debug) console.log('Loading '  + asmName + '.');\r\n      ++pending;\r\n\r\n      let prom;\r\n      if (ENVIRONMENT_IS_NODE) {\r\n        const {\r\n          readFile,\r\n        } = __webpack_require__(/*! fs-extra */ \"./node_modules/fs-extra/lib/index.js\");\r\n        const path = __webpack_require__(/*! path */ \"path\");\r\n        prom = readFile(path.join(__dirname, 'managed', asmName));\r\n      } else {\r\n        prom = fetch(\r\n          'managed/' + asmName,\r\n          {\r\n            contentType: 'application/wasm',\r\n            credentials: 'same-origin',\r\n          },\r\n        );\r\n      }\r\n\r\n      prom.then((data) => {\r\n        const asm = new Uint8Array(data);\r\n        Module.FS_createDataFile('managed/' + asmName, null, asm, true, true, true);\r\n        --pending;\r\n        if (pending === 0) {\r\n          Module.bclLoadingDone(resolve);\r\n        }\r\n      });\r\n    });\r\n  },\r\n\r\n  bclLoadingDone: (resolve) => {\r\n    if (debug) console.log('Done loading the Mono Base Class Library.');\r\n    MonoRuntime.init();\r\n    const compile = (inputStr) => {\r\n      const moduleName = Module.entryPoint.assemblyName;\r\n      const modulePtr = MonoRuntime.assembly_load()(moduleName);\r\n      const nsName = Module.entryPoint.nsName;\r\n      const className = Module.entryPoint.className;\r\n      const classPtr = MonoRuntime.find_class()(modulePtr, nsName, className);\r\n      const methodPtr = MonoRuntime.find_method()(classPtr, 'CompileToString', 1);\r\n      const ret = MonoRuntime.call_method(\r\n        methodPtr,\r\n        classPtr,\r\n        [ inputStr ],\r\n      );\r\n\r\n      const retStr = MonoRuntime.conv_string(ret);\r\n      return JSON.parse(retStr);\r\n    };\r\n\r\n    return resolve(compile);\r\n  },\r\n};\r\n\r\nconst MonoRuntime = {\r\n  load_runtime() {\r\n    return Module.cwrap('mono_wasm_load_runtime', null, [ 'string', 'number', ]);\r\n  },\r\n\r\n  assembly_load() {\r\n    return Module.cwrap('mono_wasm_assembly_load', 'number', [ 'string' ]);\r\n  },\r\n\r\n  find_class() {\r\n    return Module.cwrap('mono_wasm_assembly_find_class', 'number', [ 'number', 'string', 'string', ]);\r\n  },\r\n\r\n  find_method() {\r\n    return Module.cwrap('mono_wasm_assembly_find_method', 'number', [ 'number', 'string', 'number', ]);\r\n  },\r\n\r\n  invoke_method() {\r\n    return Module.cwrap('mono_wasm_invoke_method', 'number', [ 'number', 'number', 'number', ]);\r\n  },\r\n\r\n  mono_string_get_utf8() {\r\n    return Module.cwrap('mono_wasm_string_get_utf8', 'number', [ 'number' ]);\r\n  },\r\n\r\n  mono_string() {\r\n    return Module.cwrap('mono_wasm_string_from_js', 'number', [ 'string' ]);\r\n  },\r\n\r\n  init() {\r\n    this.load_runtime()('managed', 1);\r\n    if (debug) console.log('Done initializing the runtime.');\r\n    WebAssemblyApp.init();\r\n  },\r\n  \r\n  call_method(method, this_arg, args) {\r\n    debugger;\r\n    const args_mem = Module._malloc(args.length * 4);\r\n    const eh_throw = Module._malloc(4);\r\n    for (let ii = 0; ii < args.length; ++ii) {\r\n      Module.setValue(args_mem + ii * 4, args [ii], \"i32\");\r\n    }\r\n\r\n    Module.setValue(eh_throw, 0, \"i32\");\r\n\r\n    var res = this.invoke_method()(method, this_arg, args_mem, eh_throw);\r\n\r\n    var eh_res = Module.getValue(eh_throw, \"i32\");\r\n\r\n    Module._free(args_mem);\r\n    Module._free(eh_throw);\r\n\r\n    debugger;\r\n    if (eh_res !== 0) {\r\n      const msg = this.conv_string(res);\r\n      throw new Error(msg);\r\n    }\r\n\r\n    return res;\r\n  },\r\n\r\n  conv_string(mono_obj) {\r\n    if (mono_obj === 0) {\r\n      return null;\r\n    }\r\n\r\n    const raw = this.mono_string_get_utf8()(mono_obj);\r\n    const res = Module.UTF8ToString(raw);\r\n    Module._free(raw);\r\n\r\n    return res;\r\n  },\r\n};\r\n\r\nconst WebAssemblyApp = {\r\n  init() {\r\n    this.findMethods();\r\n    MonoRuntime.call_method(this.main_method, null, []);\r\n  },\r\n  \r\n  findMethods() {\r\n    this.main_module = MonoRuntime.assembly_load()(Module.entryPoint.assemblyName);\r\n    if (!this.main_module) {\r\n      throw new Error('Could not find Main Module ' + Module.entryPoint.assemblyName + '.dll.');\r\n    }\r\n\r\n    this.main_class = MonoRuntime.find_class()(this.main_module, Module.entryPoint.nsName, Module.entryPoint.className);\r\n    if (!this.main_class) {\r\n      throw new Error('Could not find Program class in main module.');\r\n    }\r\n\r\n    this.main_method = MonoRuntime.find_method()(this.main_class, Module.entryPoint.mainMethodName, -1);\r\n    if (!this.main_method) {\r\n      throw new Error('Could not find Main method.');\r\n    }\r\n  },\r\n};\r\n\r\n/* End Ooui.js-derived section. */\r\n\r\nconst initializeMonoEnvironment = () => new Promise((resolve, reject) => {\r\n  var moduleOverrides = {};\r\n  var key;\r\n  for (key in Module) {\r\n    if (Module.hasOwnProperty(key)) {\r\n      moduleOverrides[key] = Module[key]\r\n    }\r\n  }\r\n  Module[\"arguments\"] = [];\r\n  Module[\"thisProgram\"] = \"./this.program\";\r\n  Module[\"quit\"] = (function(status, toThrow) {\r\n    const err = new Error();\r\n    err.code = status;\r\n    throw err;\r\n  });\r\n\r\n  Module[\"preRun\"] = [];\r\n  Module[\"postRun\"] = [];\r\n\r\n  if (Module[\"ENVIRONMENT\"]) {\r\n    if (Module[\"ENVIRONMENT\"] === \"WEB\") {\r\n      ENVIRONMENT_IS_WEB = true;\r\n    } else if (Module[\"ENVIRONMENT\"] === \"WORKER\") {\r\n      ENVIRONMENT_IS_WORKER = true;\r\n    } else if (Module[\"ENVIRONMENT\"] === \"NODE\") {\r\n      ENVIRONMENT_IS_NODE = true;\r\n    } else if (Module[\"ENVIRONMENT\"] === \"SHELL\") {\r\n      ENVIRONMENT_IS_SHELL = true;\r\n    } else {\r\n      throw new Error(\"Module['ENVIRONMENT'] value is not valid. must be one of: WEB|WORKER|NODE|SHELL.\");\r\n    }\r\n  }\r\n\r\n  if (ENVIRONMENT_IS_NODE) {\r\n    var nodeFS;\r\n    var nodePath;\r\n    Module[\"read\"] = function shell_read(filename, binary) {\r\n      var ret;\r\n      if (!nodeFS) nodeFS = __webpack_require__(/*! fs */ \"fs\");\r\n      if (!nodePath) nodePath = __webpack_require__(/*! path */ \"path\");\r\n      filename = nodePath[\"normalize\"](filename);\r\n      ret = nodeFS[\"readFileSync\"](filename);\r\n      return binary ? ret : ret.toString()\r\n    };\r\n    Module[\"readBinary\"] = function readBinary(filename) {\r\n      var ret = Module[\"read\"](filename, true);\r\n      if (!ret.buffer) {\r\n        ret = new Uint8Array(ret)\r\n      }\r\n      assert(ret.buffer);\r\n      return ret\r\n    };\r\n    if (process[\"argv\"].length > 1) {\r\n      Module[\"thisProgram\"] = process[\"argv\"][1].replace(/\\\\/g, \"/\")\r\n    }\r\n    Module[\"arguments\"] = process[\"argv\"].slice(2);\r\n    Module[\"inspect\"] = (function() {\r\n      return \"[Emscripten Module object]\"\r\n    })\r\n  } else if (ENVIRONMENT_IS_SHELL) {\r\n    if (typeof read != \"undefined\") {\r\n      Module[\"read\"] = function shell_read(f) {\r\n        return read(f)\r\n      }\r\n    }\r\n    Module[\"readBinary\"] = function readBinary(f) {\r\n      var data;\r\n      if (typeof readbuffer === \"function\") {\r\n        return new Uint8Array(readbuffer(f))\r\n      }\r\n      data = read(f, \"binary\");\r\n      assert(typeof data === \"object\");\r\n      return data\r\n    };\r\n    if (typeof scriptArgs != \"undefined\") {\r\n      Module[\"arguments\"] = scriptArgs\r\n    } else if (typeof arguments != \"undefined\") {\r\n      Module[\"arguments\"] = arguments\r\n    }\r\n    if (typeof quit === \"function\") {\r\n      Module[\"quit\"] = (function(status, toThrow) {\r\n        quit(status, toThrow);\r\n      })\r\n    }\r\n  } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\r\n    Module[\"read\"] = function shell_read(url) {\r\n      var xhr = new XMLHttpRequest;\r\n      xhr.open(\"GET\", url, false);\r\n      xhr.send(null);\r\n      return xhr.responseText\r\n    };\r\n    if (ENVIRONMENT_IS_WORKER) {\r\n      Module[\"readBinary\"] = function readBinary(url) {\r\n        var xhr = new XMLHttpRequest;\r\n        xhr.open(\"GET\", url, false);\r\n        xhr.responseType = \"arraybuffer\";\r\n        xhr.send(null);\r\n        return new Uint8Array(xhr.response)\r\n      }\r\n    }\r\n    Module[\"readAsync\"] = function readAsync(url, onload, onerror) {\r\n      var xhr = new XMLHttpRequest;\r\n      xhr.open(\"GET\", url, true);\r\n      xhr.responseType = \"arraybuffer\";\r\n      xhr.onload = function xhr_onload() {\r\n        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\r\n          onload(xhr.response);\r\n          return\r\n        }\r\n        onerror()\r\n      };\r\n      xhr.onerror = onerror;\r\n      xhr.send(null)\r\n    };\r\n    if (typeof arguments != \"undefined\") {\r\n      Module[\"arguments\"] = arguments\r\n    }\r\n    Module[\"setWindowTitle\"] = (function(title) {\r\n      document.title = title\r\n    })\r\n  }\r\n  Module[\"print\"] = typeof console !== \"undefined\" ? console.log.bind(console) : typeof print !== \"undefined\" ? print : null;\r\n  Module[\"printErr\"] = typeof printErr !== \"undefined\" ? printErr : typeof console !== \"undefined\" && console.warn.bind(console) || Module[\"print\"];\r\n  Module.print = Module[\"print\"];\r\n  Module.printErr = Module[\"printErr\"];\r\n  for (key in moduleOverrides) {\r\n    if (moduleOverrides.hasOwnProperty(key)) {\r\n      Module[key] = moduleOverrides[key]\r\n    }\r\n  }\r\n  moduleOverrides = undefined;\r\n  var STACK_ALIGN = 16;\r\n\r\n  function staticAlloc(size) {\r\n    assert(!staticSealed);\r\n    var ret = STATICTOP;\r\n    STATICTOP = STATICTOP + size + 15 & -16;\r\n    return ret\r\n  }\r\n\r\n  function dynamicAlloc(size) {\r\n    assert(DYNAMICTOP_PTR);\r\n    var ret = HEAP32[DYNAMICTOP_PTR >> 2];\r\n    var end = ret + size + 15 & -16;\r\n    HEAP32[DYNAMICTOP_PTR >> 2] = end;\r\n    if (end >= TOTAL_MEMORY) {\r\n      var success = enlargeMemory();\r\n      if (!success) {\r\n        HEAP32[DYNAMICTOP_PTR >> 2] = ret;\r\n        return 0\r\n      }\r\n    }\r\n    return ret\r\n  }\r\n\r\n  function alignMemory(size, factor) {\r\n    if (!factor) factor = STACK_ALIGN;\r\n    var ret = size = Math.ceil(size / factor) * factor;\r\n    return ret\r\n  }\r\n\r\n  function getNativeTypeSize(type) {\r\n    switch (type) {\r\n      case \"i1\":\r\n      case \"i8\":\r\n        return 1;\r\n      case \"i16\":\r\n        return 2;\r\n      case \"i32\":\r\n        return 4;\r\n      case \"i64\":\r\n        return 8;\r\n      case \"float\":\r\n        return 4;\r\n      case \"double\":\r\n        return 8;\r\n      default: {\r\n        if (type[type.length - 1] === \"*\") {\r\n          return 4\r\n        } else if (type[0] === \"i\") {\r\n          var bits = parseInt(type.substr(1));\r\n          assert(bits % 8 === 0);\r\n          return bits / 8\r\n        } else {\r\n          return 0\r\n        }\r\n      }\r\n    }\r\n  }\r\n  var functionPointers = new Array(0);\r\n  var GLOBAL_BASE = 1024;\r\n  var ABORT = 0;\r\n  var EXITSTATUS = 0;\r\n\r\n  function assert(condition, text) {\r\n    if (!condition) {\r\n      abort(\"Assertion failed: \" + text)\r\n    }\r\n  }\r\n\r\n  function getCFunc(ident) {\r\n    var func = Module[\"_\" + ident];\r\n    assert(func, \"Cannot call unknown function \" + ident + \", make sure it is exported\");\r\n    return func\r\n  }\r\n  var JSfuncs = {\r\n    \"stackSave\": (function() {\r\n      stackSave()\r\n    }),\r\n    \"stackRestore\": (function() {\r\n      stackRestore()\r\n    }),\r\n    \"arrayToC\": (function(arr) {\r\n      var ret = stackAlloc(arr.length);\r\n      writeArrayToMemory(arr, ret);\r\n      return ret\r\n    }),\r\n    \"stringToC\": (function(str) {\r\n      var ret = 0;\r\n      if (str !== null && str !== undefined && str !== 0) {\r\n        var len = (str.length << 2) + 1;\r\n        ret = stackAlloc(len);\r\n        stringToUTF8(str, ret, len)\r\n      }\r\n      return ret\r\n    })\r\n  };\r\n  var toC = {\r\n    \"string\": JSfuncs[\"stringToC\"],\r\n    \"array\": JSfuncs[\"arrayToC\"]\r\n  };\r\n\r\n  function ccall(ident, returnType, argTypes, args, opts) {\r\n    var func = getCFunc(ident);\r\n    var cArgs = [];\r\n    var stack = 0;\r\n    if (args) {\r\n      for (var i = 0; i < args.length; i++) {\r\n        var converter = toC[argTypes[i]];\r\n        if (converter) {\r\n          if (stack === 0) stack = stackSave();\r\n          cArgs[i] = converter(args[i])\r\n        } else {\r\n          cArgs[i] = args[i]\r\n        }\r\n      }\r\n    }\r\n    var ret = func.apply(null, cArgs);\r\n    if (returnType === \"string\") ret = Pointer_stringify(ret);\r\n    if (stack !== 0) {\r\n      stackRestore(stack)\r\n    }\r\n    return ret\r\n  }\r\n\r\n  function cwrap(ident, returnType, argTypes) {\r\n    argTypes = argTypes || [];\r\n    var cfunc = getCFunc(ident);\r\n    var numericArgs = argTypes.every((function(type) {\r\n      return type === \"number\"\r\n    }));\r\n    var numericRet = returnType !== \"string\";\r\n    if (numericRet && numericArgs) {\r\n      return cfunc\r\n    }\r\n    return (function() {\r\n      return ccall(ident, returnType, argTypes, arguments)\r\n    })\r\n  }\r\n\r\n  function setValue(ptr, value, type, noSafe) {\r\n    type = type || \"i8\";\r\n    if (type.charAt(type.length - 1) === \"*\") type = \"i32\";\r\n    switch (type) {\r\n      case \"i1\":\r\n        HEAP8[ptr >> 0] = value;\r\n        break;\r\n      case \"i8\":\r\n        HEAP8[ptr >> 0] = value;\r\n        break;\r\n      case \"i16\":\r\n        HEAP16[ptr >> 1] = value;\r\n        break;\r\n      case \"i32\":\r\n        HEAP32[ptr >> 2] = value;\r\n        break;\r\n      case \"i64\":\r\n        tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\r\n        break;\r\n      case \"float\":\r\n        HEAPF32[ptr >> 2] = value;\r\n        break;\r\n      case \"double\":\r\n        HEAPF64[ptr >> 3] = value;\r\n        break;\r\n      default:\r\n        abort(\"invalid type for setValue: \" + type)\r\n    }\r\n  }\r\n\r\n  function getValue(ptr, type, noSafe) {\r\n    type = type || \"i8\";\r\n    if (type.charAt(type.length - 1) === \"*\") type = \"i32\";\r\n    switch (type) {\r\n      case \"i1\":\r\n        return HEAP8[ptr >> 0];\r\n      case \"i8\":\r\n        return HEAP8[ptr >> 0];\r\n      case \"i16\":\r\n        return HEAP16[ptr >> 1];\r\n      case \"i32\":\r\n        return HEAP32[ptr >> 2];\r\n      case \"i64\":\r\n        return HEAP32[ptr >> 2];\r\n      case \"float\":\r\n        return HEAPF32[ptr >> 2];\r\n      case \"double\":\r\n        return HEAPF64[ptr >> 3];\r\n      default:\r\n        abort(\"invalid type for getValue: \" + type)\r\n    }\r\n    return null\r\n  }\r\n  var ALLOC_NORMAL = 0;\r\n  var ALLOC_STATIC = 2;\r\n  var ALLOC_NONE = 4;\r\n\r\n  function allocate(slab, types, allocator, ptr) {\r\n    var zeroinit, size;\r\n    if (typeof slab === \"number\") {\r\n      zeroinit = true;\r\n      size = slab\r\n    } else {\r\n      zeroinit = false;\r\n      size = slab.length\r\n    }\r\n    var singleType = typeof types === \"string\" ? types : null;\r\n    var ret;\r\n    if (allocator == ALLOC_NONE) {\r\n      ret = ptr\r\n    } else {\r\n      ret = [typeof _malloc === \"function\" ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length))\r\n    }\r\n    if (zeroinit) {\r\n      var stop;\r\n      ptr = ret;\r\n      assert((ret & 3) == 0);\r\n      stop = ret + (size & ~3);\r\n      for (; ptr < stop; ptr += 4) {\r\n        HEAP32[ptr >> 2] = 0\r\n      }\r\n      stop = ret + size;\r\n      while (ptr < stop) {\r\n        HEAP8[ptr++ >> 0] = 0\r\n      }\r\n      return ret\r\n    }\r\n    if (singleType === \"i8\") {\r\n      if (slab.subarray || slab.slice) {\r\n        HEAPU8.set(slab, ret)\r\n      } else {\r\n        HEAPU8.set(new Uint8Array(slab), ret)\r\n      }\r\n      return ret\r\n    }\r\n    var i = 0,\r\n      type, typeSize, previousType;\r\n    while (i < size) {\r\n      var curr = slab[i];\r\n      type = singleType || types[i];\r\n      if (type === 0) {\r\n        i++;\r\n        continue\r\n      }\r\n      if (type == \"i64\") type = \"i32\";\r\n      setValue(ret + i, curr, type);\r\n      if (previousType !== type) {\r\n        typeSize = getNativeTypeSize(type);\r\n        previousType = type\r\n      }\r\n      i += typeSize\r\n    }\r\n    return ret\r\n  }\r\n\r\n  function Pointer_stringify(ptr, length) {\r\n    if (length === 0 || !ptr) return \"\";\r\n    var hasUtf = 0;\r\n    var t;\r\n    var i = 0;\r\n    while (1) {\r\n      t = HEAPU8[ptr + i >> 0];\r\n      hasUtf |= t;\r\n      if (t == 0 && !length) break;\r\n      i++;\r\n      if (length && i == length) break\r\n    }\r\n    if (!length) length = i;\r\n    var ret = \"\";\r\n    if (hasUtf < 128) {\r\n      var MAX_CHUNK = 1024;\r\n      var curr;\r\n      while (length > 0) {\r\n        curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));\r\n        ret = ret ? ret + curr : curr;\r\n        ptr += MAX_CHUNK;\r\n        length -= MAX_CHUNK\r\n      }\r\n      return ret\r\n    }\r\n    return UTF8ToString(ptr)\r\n  }\r\n  var UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\r\n\r\n  function UTF8ArrayToString(u8Array, idx) {\r\n    var endPtr = idx;\r\n    while (u8Array[endPtr]) ++endPtr;\r\n    if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\r\n      return UTF8Decoder.decode(u8Array.subarray(idx, endPtr))\r\n    } else {\r\n      var u0, u1, u2, u3, u4, u5;\r\n      var str = \"\";\r\n      while (1) {\r\n        u0 = u8Array[idx++];\r\n        if (!u0) return str;\r\n        if (!(u0 & 128)) {\r\n          str += String.fromCharCode(u0);\r\n          continue\r\n        }\r\n        u1 = u8Array[idx++] & 63;\r\n        if ((u0 & 224) == 192) {\r\n          str += String.fromCharCode((u0 & 31) << 6 | u1);\r\n          continue\r\n        }\r\n        u2 = u8Array[idx++] & 63;\r\n        if ((u0 & 240) == 224) {\r\n          u0 = (u0 & 15) << 12 | u1 << 6 | u2\r\n        } else {\r\n          u3 = u8Array[idx++] & 63;\r\n          if ((u0 & 248) == 240) {\r\n            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3\r\n          } else {\r\n            u4 = u8Array[idx++] & 63;\r\n            if ((u0 & 252) == 248) {\r\n              u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4\r\n            } else {\r\n              u5 = u8Array[idx++] & 63;\r\n              u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5\r\n            }\r\n          }\r\n        }\r\n        if (u0 < 65536) {\r\n          str += String.fromCharCode(u0)\r\n        } else {\r\n          var ch = u0 - 65536;\r\n          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function UTF8ToString(ptr) {\r\n    return UTF8ArrayToString(HEAPU8, ptr)\r\n  }\r\n\r\n  function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\r\n    if (!(maxBytesToWrite > 0)) return 0;\r\n    var startIdx = outIdx;\r\n    var endIdx = outIdx + maxBytesToWrite - 1;\r\n    for (var i = 0; i < str.length; ++i) {\r\n      var u = str.charCodeAt(i);\r\n      if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\r\n      if (u <= 127) {\r\n        if (outIdx >= endIdx) break;\r\n        outU8Array[outIdx++] = u\r\n      } else if (u <= 2047) {\r\n        if (outIdx + 1 >= endIdx) break;\r\n        outU8Array[outIdx++] = 192 | u >> 6;\r\n        outU8Array[outIdx++] = 128 | u & 63\r\n      } else if (u <= 65535) {\r\n        if (outIdx + 2 >= endIdx) break;\r\n        outU8Array[outIdx++] = 224 | u >> 12;\r\n        outU8Array[outIdx++] = 128 | u >> 6 & 63;\r\n        outU8Array[outIdx++] = 128 | u & 63\r\n      } else if (u <= 2097151) {\r\n        if (outIdx + 3 >= endIdx) break;\r\n        outU8Array[outIdx++] = 240 | u >> 18;\r\n        outU8Array[outIdx++] = 128 | u >> 12 & 63;\r\n        outU8Array[outIdx++] = 128 | u >> 6 & 63;\r\n        outU8Array[outIdx++] = 128 | u & 63\r\n      } else if (u <= 67108863) {\r\n        if (outIdx + 4 >= endIdx) break;\r\n        outU8Array[outIdx++] = 248 | u >> 24;\r\n        outU8Array[outIdx++] = 128 | u >> 18 & 63;\r\n        outU8Array[outIdx++] = 128 | u >> 12 & 63;\r\n        outU8Array[outIdx++] = 128 | u >> 6 & 63;\r\n        outU8Array[outIdx++] = 128 | u & 63\r\n      } else {\r\n        if (outIdx + 5 >= endIdx) break;\r\n        outU8Array[outIdx++] = 252 | u >> 30;\r\n        outU8Array[outIdx++] = 128 | u >> 24 & 63;\r\n        outU8Array[outIdx++] = 128 | u >> 18 & 63;\r\n        outU8Array[outIdx++] = 128 | u >> 12 & 63;\r\n        outU8Array[outIdx++] = 128 | u >> 6 & 63;\r\n        outU8Array[outIdx++] = 128 | u & 63\r\n      }\r\n    }\r\n    outU8Array[outIdx] = 0;\r\n    return outIdx - startIdx\r\n  }\r\n\r\n  function stringToUTF8(str, outPtr, maxBytesToWrite) {\r\n    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite)\r\n  }\r\n\r\n  function lengthBytesUTF8(str) {\r\n    var len = 0;\r\n    for (var i = 0; i < str.length; ++i) {\r\n      var u = str.charCodeAt(i);\r\n      if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\r\n      if (u <= 127) {\r\n        ++len\r\n      } else if (u <= 2047) {\r\n        len += 2\r\n      } else if (u <= 65535) {\r\n        len += 3\r\n      } else if (u <= 2097151) {\r\n        len += 4\r\n      } else if (u <= 67108863) {\r\n        len += 5\r\n      } else {\r\n        len += 6\r\n      }\r\n    }\r\n    return len\r\n  }\r\n  var UTF16Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\r\n\r\n  function stringToUTF16(str, outPtr, maxBytesToWrite) {\r\n    if (maxBytesToWrite === undefined) {\r\n      maxBytesToWrite = 2147483647\r\n    }\r\n    if (maxBytesToWrite < 2) return 0;\r\n    maxBytesToWrite -= 2;\r\n    var startPtr = outPtr;\r\n    var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\r\n    for (var i = 0; i < numCharsToWrite; ++i) {\r\n      var codeUnit = str.charCodeAt(i);\r\n      HEAP16[outPtr >> 1] = codeUnit;\r\n      outPtr += 2\r\n    }\r\n    HEAP16[outPtr >> 1] = 0;\r\n    return outPtr - startPtr\r\n  }\r\n\r\n  function allocateUTF8(str) {\r\n    var size = lengthBytesUTF8(str) + 1;\r\n    var ret = _malloc(size);\r\n    if (ret) stringToUTF8Array(str, HEAP8, ret, size);\r\n    return ret\r\n  }\r\n\r\n  function demangle(func) {\r\n    return func\r\n  }\r\n\r\n  function demangleAll(text) {\r\n    var regex = /__Z[\\w\\d_]+/g;\r\n    return text.replace(regex, (function(x) {\r\n      var y = demangle(x);\r\n      return x === y ? x : x + \" [\" + y + \"]\"\r\n    }))\r\n  }\r\n\r\n  function jsStackTrace() {\r\n    var err = new Error;\r\n    if (!err.stack) {\r\n      try {\r\n        throw new Error(0)\r\n      } catch (e) {\r\n        err = e\r\n      }\r\n      if (!err.stack) {\r\n        return \"(no stack trace available)\"\r\n      }\r\n    }\r\n    return err.stack.toString()\r\n  }\r\n\r\n  function stackTrace() {\r\n    var js = jsStackTrace();\r\n    if (Module[\"extraStackTrace\"]) js += \"\\n\" + Module[\"extraStackTrace\"]();\r\n    return demangleAll(js)\r\n  }\r\n  var PAGE_SIZE = 16384;\r\n  var WASM_PAGE_SIZE = 65536;\r\n  var ASMJS_PAGE_SIZE = 16777216;\r\n  var MIN_TOTAL_MEMORY = 16777216;\r\n\r\n  function alignUp(x, multiple) {\r\n    if (x % multiple > 0) {\r\n      x += multiple - x % multiple\r\n    }\r\n    return x\r\n  }\r\n  var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\r\n\r\n  function updateGlobalBuffer(buf) {\r\n    Module[\"buffer\"] = buffer = buf\r\n  }\r\n\r\n  function updateGlobalBufferViews() {\r\n    Module[\"HEAP8\"] = HEAP8 = new Int8Array(buffer);\r\n    Module[\"HEAP16\"] = HEAP16 = new Int16Array(buffer);\r\n    Module[\"HEAP32\"] = HEAP32 = new Int32Array(buffer);\r\n    Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buffer);\r\n    Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buffer);\r\n    Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buffer);\r\n    Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buffer);\r\n    Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buffer)\r\n  }\r\n  var STATIC_BASE, STATICTOP, staticSealed;\r\n  var STACK_BASE, STACKTOP, STACK_MAX;\r\n  var DYNAMIC_BASE, DYNAMICTOP_PTR;\r\n  STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;\r\n  staticSealed = false;\r\n\r\n  function abortOnCannotGrowMemory() {\r\n    abort(\"Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value \" + TOTAL_MEMORY + \", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 \")\r\n  }\r\n  if (!Module[\"reallocBuffer\"]) Module[\"reallocBuffer\"] = (function(size) {\r\n    var ret;\r\n    try {\r\n      if (ArrayBuffer.transfer) {\r\n        ret = ArrayBuffer.transfer(buffer, size)\r\n      } else {\r\n        var oldHEAP8 = HEAP8;\r\n        ret = new ArrayBuffer(size);\r\n        var temp = new Int8Array(ret);\r\n        temp.set(oldHEAP8)\r\n      }\r\n    } catch (e) {\r\n      return false\r\n    }\r\n    var success = _emscripten_replace_memory(ret);\r\n    if (!success) return false;\r\n    return ret\r\n  });\r\n\r\n  function enlargeMemory() {\r\n    var PAGE_MULTIPLE = Module[\"usingWasm\"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE;\r\n    var LIMIT = 2147483648 - PAGE_MULTIPLE;\r\n    if (HEAP32[DYNAMICTOP_PTR >> 2] > LIMIT) {\r\n      return false\r\n    }\r\n    var OLD_TOTAL_MEMORY = TOTAL_MEMORY;\r\n    TOTAL_MEMORY = Math.max(TOTAL_MEMORY, MIN_TOTAL_MEMORY);\r\n    while (TOTAL_MEMORY < HEAP32[DYNAMICTOP_PTR >> 2]) {\r\n      if (TOTAL_MEMORY <= 536870912) {\r\n        TOTAL_MEMORY = alignUp(2 * TOTAL_MEMORY, PAGE_MULTIPLE)\r\n      } else {\r\n        TOTAL_MEMORY = Math.min(alignUp((3 * TOTAL_MEMORY + 2147483648) / 4, PAGE_MULTIPLE), LIMIT)\r\n      }\r\n    }\r\n    var replacement = Module[\"reallocBuffer\"](TOTAL_MEMORY);\r\n    if (!replacement || replacement.byteLength != TOTAL_MEMORY) {\r\n      TOTAL_MEMORY = OLD_TOTAL_MEMORY;\r\n      return false\r\n    }\r\n    updateGlobalBuffer(replacement);\r\n    updateGlobalBufferViews();\r\n    return true\r\n  }\r\n  var byteLength;\r\n  try {\r\n    byteLength = Function.prototype.call.bind(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, \"byteLength\").get);\r\n    byteLength(new ArrayBuffer(4))\r\n  } catch (e) {\r\n    byteLength = (function(buffer) {\r\n      return buffer.byteLength\r\n    })\r\n  }\r\n  var TOTAL_STACK = Module[\"TOTAL_STACK\"] || 5242880;\r\n  var TOTAL_MEMORY = Module[\"TOTAL_MEMORY\"] || 134217728;\r\n  if (TOTAL_MEMORY < TOTAL_STACK) Module.printErr(\"TOTAL_MEMORY should be larger than TOTAL_STACK, was \" + TOTAL_MEMORY + \"! (TOTAL_STACK=\" + TOTAL_STACK + \")\");\r\n  if (Module[\"buffer\"]) {\r\n    buffer = Module[\"buffer\"]\r\n  } else {\r\n    if (typeof WebAssembly === \"object\" && typeof WebAssembly.Memory === \"function\") {\r\n      Module[\"wasmMemory\"] = new WebAssembly.Memory({\r\n        \"initial\": TOTAL_MEMORY / WASM_PAGE_SIZE\r\n      });\r\n      buffer = Module[\"wasmMemory\"].buffer\r\n    } else {\r\n      buffer = new ArrayBuffer(TOTAL_MEMORY)\r\n    }\r\n    Module[\"buffer\"] = buffer\r\n  }\r\n  updateGlobalBufferViews();\r\n\r\n  function getTotalMemory() {\r\n    return TOTAL_MEMORY\r\n  }\r\n  HEAP32[0] = 1668509029;\r\n  HEAP16[1] = 25459;\r\n  if (HEAPU8[2] !== 115 || HEAPU8[3] !== 99) throw \"Runtime error: expected the system to be little-endian!\";\r\n\r\n  function callRuntimeCallbacks(callbacks) {\r\n    while (callbacks.length > 0) {\r\n      var callback = callbacks.shift();\r\n      if (typeof callback == \"function\") {\r\n        callback();\r\n        continue\r\n      }\r\n      var func = callback.func;\r\n      if (typeof func === \"number\") {\r\n        if (callback.arg === undefined) {\r\n          Module[\"dynCall_v\"](func)\r\n        } else {\r\n          Module[\"dynCall_vi\"](func, callback.arg)\r\n        }\r\n      } else {\r\n        func(callback.arg === undefined ? null : callback.arg)\r\n      }\r\n    }\r\n  }\r\n  var __ATPRERUN__ = [];\r\n  var __ATINIT__ = [];\r\n  var __ATMAIN__ = [];\r\n  var __ATEXIT__ = [];\r\n  var __ATPOSTRUN__ = [];\r\n  var runtimeInitialized = false;\r\n  var runtimeExited = false;\r\n\r\n  function preRun() {\r\n    if (Module[\"preRun\"]) {\r\n      if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [Module[\"preRun\"]];\r\n      while (Module[\"preRun\"].length) {\r\n        addOnPreRun(Module[\"preRun\"].shift())\r\n      }\r\n    }\r\n    callRuntimeCallbacks(__ATPRERUN__)\r\n  }\r\n\r\n  function ensureInitRuntime() {\r\n    if (runtimeInitialized) return;\r\n    runtimeInitialized = true;\r\n    callRuntimeCallbacks(__ATINIT__)\r\n  }\r\n\r\n  function preMain() {\r\n    callRuntimeCallbacks(__ATMAIN__)\r\n  }\r\n\r\n  function exitRuntime() {\r\n    callRuntimeCallbacks(__ATEXIT__);\r\n    runtimeExited = true\r\n  }\r\n\r\n  function postRun() {\r\n    if (Module[\"postRun\"]) {\r\n      if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [Module[\"postRun\"]];\r\n      while (Module[\"postRun\"].length) {\r\n        addOnPostRun(Module[\"postRun\"].shift())\r\n      }\r\n    }\r\n    callRuntimeCallbacks(__ATPOSTRUN__)\r\n  }\r\n\r\n  function addOnPreRun(cb) {\r\n    __ATPRERUN__.unshift(cb)\r\n  }\r\n\r\n  function addOnPostRun(cb) {\r\n    __ATPOSTRUN__.unshift(cb)\r\n  }\r\n\r\n  function writeArrayToMemory(array, buffer) {\r\n    HEAP8.set(array, buffer)\r\n  }\r\n\r\n  function writeAsciiToMemory(str, buffer, dontAddNull) {\r\n    for (var i = 0; i < str.length; ++i) {\r\n      HEAP8[buffer++ >> 0] = str.charCodeAt(i)\r\n    }\r\n    if (!dontAddNull) HEAP8[buffer >> 0] = 0\r\n  }\r\n  var Math_abs = Math.abs;\r\n  var Math_cos = Math.cos;\r\n  var Math_sin = Math.sin;\r\n  var Math_tan = Math.tan;\r\n  var Math_acos = Math.acos;\r\n  var Math_asin = Math.asin;\r\n  var Math_atan = Math.atan;\r\n  var Math_atan2 = Math.atan2;\r\n  var Math_exp = Math.exp;\r\n  var Math_log = Math.log;\r\n  var Math_sqrt = Math.sqrt;\r\n  var Math_ceil = Math.ceil;\r\n  var Math_floor = Math.floor;\r\n  var Math_pow = Math.pow;\r\n  var Math_imul = Math.imul;\r\n  var Math_fround = Math.fround;\r\n  var Math_round = Math.round;\r\n  var Math_min = Math.min;\r\n  var Math_max = Math.max;\r\n  var Math_clz32 = Math.clz32;\r\n  var Math_trunc = Math.trunc;\r\n  var runDependencies = 0;\r\n  var runDependencyWatcher = null;\r\n  var dependenciesFulfilled = null;\r\n\r\n  function getUniqueRunDependency(id) {\r\n    return id\r\n  }\r\n\r\n  function addRunDependency(id) {\r\n    runDependencies++;\r\n    if (Module[\"monitorRunDependencies\"]) {\r\n      Module[\"monitorRunDependencies\"](runDependencies)\r\n    }\r\n  }\r\n\r\n  function removeRunDependency(id) {\r\n    runDependencies--;\r\n    if (Module[\"monitorRunDependencies\"]) {\r\n      Module[\"monitorRunDependencies\"](runDependencies)\r\n    }\r\n    if (runDependencies == 0) {\r\n      if (runDependencyWatcher !== null) {\r\n        clearInterval(runDependencyWatcher);\r\n        runDependencyWatcher = null\r\n      }\r\n      if (dependenciesFulfilled) {\r\n        var callback = dependenciesFulfilled;\r\n        dependenciesFulfilled = null;\r\n        callback()\r\n      }\r\n    }\r\n  }\r\n  Module[\"preloadedImages\"] = {};\r\n  Module[\"preloadedAudios\"] = {};\r\n  var dataURIPrefix = \"data:application/octet-stream;base64,\";\r\n\r\n  function isDataURI(filename) {\r\n    return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0\r\n  }\r\n\r\n  function integrateWasmJS() {\r\n    var wasmBinaryFile = \"mono.wasm\";\r\n    var wasmTextFile = \"mono.wast\";\r\n    var asmjsCodeFile = \"mono.temp.asm.js\";\r\n    if (ENVIRONMENT_IS_NODE) {\r\n      const path = __webpack_require__(/*! path */ \"path\");\r\n      wasmBinaryFile = path.join(__dirname, 'mono.wasm');\r\n      wasmTextFile = path.join(__dirname, 'mono.wast');\r\n      asmjsCodeFile = path.join(__dirname, 'mono.temp.asm.js');\r\n    }\r\n\r\n    if (typeof Module[\"locateFile\"] === \"function\") {\r\n      if (!isDataURI(wasmTextFile)) {\r\n        wasmTextFile = Module[\"locateFile\"](wasmTextFile)\r\n      }\r\n      if (!isDataURI(wasmBinaryFile)) {\r\n        wasmBinaryFile = Module[\"locateFile\"](wasmBinaryFile)\r\n      }\r\n      if (!isDataURI(asmjsCodeFile)) {\r\n        asmjsCodeFile = Module[\"locateFile\"](asmjsCodeFile)\r\n      }\r\n    }\r\n    var wasmPageSize = 64 * 1024;\r\n    var info = {\r\n      \"global\": null,\r\n      \"env\": null,\r\n      \"asm2wasm\": {\r\n        \"f64-rem\": (function(x, y) {\r\n          return x % y\r\n        }),\r\n        \"debugger\": (function() {\r\n          debugger\r\n        })\r\n      },\r\n      \"parent\": Module\r\n    };\r\n    var exports = null;\r\n\r\n    function mergeMemory(newBuffer) {\r\n      var oldBuffer = Module[\"buffer\"];\r\n      if (newBuffer.byteLength < oldBuffer.byteLength) {\r\n        Module[\"printErr\"](\"the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here\")\r\n      }\r\n      var oldView = new Int8Array(oldBuffer);\r\n      var newView = new Int8Array(newBuffer);\r\n      newView.set(oldView);\r\n      updateGlobalBuffer(newBuffer);\r\n      updateGlobalBufferViews()\r\n    }\r\n\r\n    function fixImports(imports) {\r\n      return imports\r\n    }\r\n\r\n    function getBinary() {\r\n      try {\r\n        if (Module[\"wasmBinary\"]) {\r\n          return new Uint8Array(Module[\"wasmBinary\"])\r\n        }\r\n        if (Module[\"readBinary\"]) {\r\n          return Module[\"readBinary\"](wasmBinaryFile)\r\n        } else {\r\n          throw \"on the web, we need the wasm binary to be preloaded and set on Module['wasmBinary']. emcc.py will do that for you when generating HTML (but not JS)\"\r\n        }\r\n      } catch (err) {\r\n        abort(err)\r\n      }\r\n    }\r\n\r\n    function getBinaryPromise() {\r\n      if (!Module[\"wasmBinary\"] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === \"function\") {\r\n        return fetch(wasmBinaryFile, {\r\n          credentials: \"same-origin\"\r\n        }).then((function(response) {\r\n          if (!response[\"ok\"]) {\r\n            throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\"\r\n          }\r\n          return response[\"arrayBuffer\"]()\r\n        })).catch((function() {\r\n          return getBinary()\r\n        }))\r\n      }\r\n      return new Promise((function(resolve, reject) {\r\n        resolve(getBinary())\r\n      }))\r\n    }\r\n\r\n    function doNativeWasm(global, env, providedBuffer) {\r\n      if (typeof WebAssembly !== \"object\") {\r\n        Module[\"printErr\"](\"no native wasm support detected\");\r\n        return false\r\n      }\r\n      if (!(Module[\"wasmMemory\"] instanceof WebAssembly.Memory)) {\r\n        Module[\"printErr\"](\"no native wasm Memory in use\");\r\n        return false\r\n      }\r\n      env[\"memory\"] = Module[\"wasmMemory\"];\r\n      info[\"global\"] = {\r\n        \"NaN\": NaN,\r\n        \"Infinity\": Infinity\r\n      };\r\n      info[\"global.Math\"] = Math;\r\n      info[\"env\"] = env;\r\n\r\n      function receiveInstance(instance, module) {\r\n        exports = instance.exports;\r\n        if (exports.memory) mergeMemory(exports.memory);\r\n        Module[\"asm\"] = exports;\r\n        Module[\"usingWasm\"] = true;\r\n        removeRunDependency(\"wasm-instantiate\")\r\n      }\r\n      addRunDependency(\"wasm-instantiate\");\r\n      if (Module[\"instantiateWasm\"]) {\r\n        try {\r\n          return Module[\"instantiateWasm\"](info, receiveInstance)\r\n        } catch (e) {\r\n          Module[\"printErr\"](\"Module.instantiateWasm callback failed with error: \" + e);\r\n          return false\r\n        }\r\n      }\r\n\r\n      function receiveInstantiatedSource(output) {\r\n        receiveInstance(output[\"instance\"], output[\"module\"])\r\n      }\r\n\r\n      function instantiateArrayBuffer(receiver) {\r\n        getBinaryPromise().then((function(binary) {\r\n          return WebAssembly.instantiate(binary, info)\r\n        })).then(receiver).catch((function(reason) {\r\n          Module[\"printErr\"](\"failed to asynchronously prepare wasm: \" + reason);\r\n          abort(reason)\r\n        }))\r\n      }\r\n      if (!Module[\"wasmBinary\"] && typeof WebAssembly.instantiateStreaming === \"function\" && !isDataURI(wasmBinaryFile) && typeof fetch === \"function\") {\r\n        WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, {\r\n          credentials: \"same-origin\"\r\n        }), info).then(receiveInstantiatedSource).catch((function(reason) {\r\n          Module[\"printErr\"](\"wasm streaming compile failed: \" + reason);\r\n          Module[\"printErr\"](\"falling back to ArrayBuffer instantiation\");\r\n          instantiateArrayBuffer(receiveInstantiatedSource)\r\n        }))\r\n      } else {\r\n        instantiateArrayBuffer(receiveInstantiatedSource)\r\n      }\r\n      return {}\r\n    }\r\n    Module[\"asmPreload\"] = Module[\"asm\"];\r\n    var asmjsReallocBuffer = Module[\"reallocBuffer\"];\r\n    var wasmReallocBuffer = (function(size) {\r\n      var PAGE_MULTIPLE = Module[\"usingWasm\"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE;\r\n      size = alignUp(size, PAGE_MULTIPLE);\r\n      var old = Module[\"buffer\"];\r\n      var oldSize = old.byteLength;\r\n      if (Module[\"usingWasm\"]) {\r\n        try {\r\n          var result = Module[\"wasmMemory\"].grow((size - oldSize) / wasmPageSize);\r\n          if (result !== (-1 | 0)) {\r\n            return Module[\"buffer\"] = Module[\"wasmMemory\"].buffer\r\n          } else {\r\n            return null\r\n          }\r\n        } catch (e) {\r\n          return null\r\n        }\r\n      }\r\n    });\r\n    Module[\"reallocBuffer\"] = (function(size) {\r\n      if (finalMethod === \"asmjs\") {\r\n        return asmjsReallocBuffer(size)\r\n      } else {\r\n        return wasmReallocBuffer(size)\r\n      }\r\n    });\r\n    var finalMethod = \"\";\r\n    Module[\"asm\"] = (function(global, env, providedBuffer) {\r\n      env = fixImports(env);\r\n      if (!env[\"table\"]) {\r\n        var TABLE_SIZE = Module[\"wasmTableSize\"];\r\n        if (TABLE_SIZE === undefined) TABLE_SIZE = 1024;\r\n        var MAX_TABLE_SIZE = Module[\"wasmMaxTableSize\"];\r\n        if (typeof WebAssembly === \"object\" && typeof WebAssembly.Table === \"function\") {\r\n          if (MAX_TABLE_SIZE !== undefined) {\r\n            env[\"table\"] = new WebAssembly.Table({\r\n              \"initial\": TABLE_SIZE,\r\n              \"maximum\": MAX_TABLE_SIZE,\r\n              \"element\": \"anyfunc\"\r\n            })\r\n          } else {\r\n            env[\"table\"] = new WebAssembly.Table({\r\n              \"initial\": TABLE_SIZE,\r\n              element: \"anyfunc\"\r\n            })\r\n          }\r\n        } else {\r\n          env[\"table\"] = new Array(TABLE_SIZE)\r\n        }\r\n        Module[\"wasmTable\"] = env[\"table\"]\r\n      }\r\n      if (!env[\"memoryBase\"]) {\r\n        env[\"memoryBase\"] = Module[\"STATIC_BASE\"]\r\n      }\r\n      if (!env[\"tableBase\"]) {\r\n        env[\"tableBase\"] = 0\r\n      }\r\n      var exports;\r\n      exports = doNativeWasm(global, env, providedBuffer);\r\n      if (!exports) abort(\"no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/WebAssembly#binaryen-methods\");\r\n      return exports\r\n    })\r\n  }\r\n  integrateWasmJS();\r\n  var ASM_CONSTS = [(function($0, $1) {\r\n    var str = UTF8ToString($0);\r\n    try {\r\n      var res = eval(str);\r\n      if (res === null) return 0;\r\n      res = res.toString();\r\n      setValue($1, 0, \"i32\")\r\n    } catch (e) {\r\n      res = e.toString();\r\n      setValue($1, 1, \"i32\");\r\n      if (res === null) res = \"unknown exception\"\r\n    }\r\n    var buff = Module._malloc((res.length + 1) * 2);\r\n    stringToUTF16(res, buff, (res.length + 1) * 2);\r\n    return buff\r\n  }), (function() {\r\n    return STACK_BASE\r\n  }), (function() {\r\n    return TOTAL_STACK\r\n  })];\r\n\r\n  function _emscripten_asm_const_i(code) {\r\n    return ASM_CONSTS[code]()\r\n  }\r\n\r\n  function _emscripten_asm_const_iii(code, a0, a1) {\r\n    return ASM_CONSTS[code](a0, a1)\r\n  }\r\n  STATIC_BASE = GLOBAL_BASE;\r\n  STATICTOP = STATIC_BASE + 635680;\r\n  __ATINIT__.push();\r\n  var STATIC_BUMP = 635680;\r\n  Module[\"STATIC_BASE\"] = STATIC_BASE;\r\n  Module[\"STATIC_BUMP\"] = STATIC_BUMP;\r\n  STATICTOP += 16;\r\n\r\n  function _emscripten_get_now() {\r\n    abort()\r\n  }\r\n\r\n  function _emscripten_get_now_is_monotonic() {\r\n    return ENVIRONMENT_IS_NODE || typeof dateNow !== \"undefined\" || (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && self[\"performance\"] && self[\"performance\"][\"now\"]\r\n  }\r\n  var ERRNO_CODES = {\r\n    EPERM: 1,\r\n    ENOENT: 2,\r\n    ESRCH: 3,\r\n    EINTR: 4,\r\n    EIO: 5,\r\n    ENXIO: 6,\r\n    E2BIG: 7,\r\n    ENOEXEC: 8,\r\n    EBADF: 9,\r\n    ECHILD: 10,\r\n    EAGAIN: 11,\r\n    EWOULDBLOCK: 11,\r\n    ENOMEM: 12,\r\n    EACCES: 13,\r\n    EFAULT: 14,\r\n    ENOTBLK: 15,\r\n    EBUSY: 16,\r\n    EEXIST: 17,\r\n    EXDEV: 18,\r\n    ENODEV: 19,\r\n    ENOTDIR: 20,\r\n    EISDIR: 21,\r\n    EINVAL: 22,\r\n    ENFILE: 23,\r\n    EMFILE: 24,\r\n    ENOTTY: 25,\r\n    ETXTBSY: 26,\r\n    EFBIG: 27,\r\n    ENOSPC: 28,\r\n    ESPIPE: 29,\r\n    EROFS: 30,\r\n    EMLINK: 31,\r\n    EPIPE: 32,\r\n    EDOM: 33,\r\n    ERANGE: 34,\r\n    ENOMSG: 42,\r\n    EIDRM: 43,\r\n    ECHRNG: 44,\r\n    EL2NSYNC: 45,\r\n    EL3HLT: 46,\r\n    EL3RST: 47,\r\n    ELNRNG: 48,\r\n    EUNATCH: 49,\r\n    ENOCSI: 50,\r\n    EL2HLT: 51,\r\n    EDEADLK: 35,\r\n    ENOLCK: 37,\r\n    EBADE: 52,\r\n    EBADR: 53,\r\n    EXFULL: 54,\r\n    ENOANO: 55,\r\n    EBADRQC: 56,\r\n    EBADSLT: 57,\r\n    EDEADLOCK: 35,\r\n    EBFONT: 59,\r\n    ENOSTR: 60,\r\n    ENODATA: 61,\r\n    ETIME: 62,\r\n    ENOSR: 63,\r\n    ENONET: 64,\r\n    ENOPKG: 65,\r\n    EREMOTE: 66,\r\n    ENOLINK: 67,\r\n    EADV: 68,\r\n    ESRMNT: 69,\r\n    ECOMM: 70,\r\n    EPROTO: 71,\r\n    EMULTIHOP: 72,\r\n    EDOTDOT: 73,\r\n    EBADMSG: 74,\r\n    ENOTUNIQ: 76,\r\n    EBADFD: 77,\r\n    EREMCHG: 78,\r\n    ELIBACC: 79,\r\n    ELIBBAD: 80,\r\n    ELIBSCN: 81,\r\n    ELIBMAX: 82,\r\n    ELIBEXEC: 83,\r\n    ENOSYS: 38,\r\n    ENOTEMPTY: 39,\r\n    ENAMETOOLONG: 36,\r\n    ELOOP: 40,\r\n    EOPNOTSUPP: 95,\r\n    EPFNOSUPPORT: 96,\r\n    ECONNRESET: 104,\r\n    ENOBUFS: 105,\r\n    EAFNOSUPPORT: 97,\r\n    EPROTOTYPE: 91,\r\n    ENOTSOCK: 88,\r\n    ENOPROTOOPT: 92,\r\n    ESHUTDOWN: 108,\r\n    ECONNREFUSED: 111,\r\n    EADDRINUSE: 98,\r\n    ECONNABORTED: 103,\r\n    ENETUNREACH: 101,\r\n    ENETDOWN: 100,\r\n    ETIMEDOUT: 110,\r\n    EHOSTDOWN: 112,\r\n    EHOSTUNREACH: 113,\r\n    EINPROGRESS: 115,\r\n    EALREADY: 114,\r\n    EDESTADDRREQ: 89,\r\n    EMSGSIZE: 90,\r\n    EPROTONOSUPPORT: 93,\r\n    ESOCKTNOSUPPORT: 94,\r\n    EADDRNOTAVAIL: 99,\r\n    ENETRESET: 102,\r\n    EISCONN: 106,\r\n    ENOTCONN: 107,\r\n    ETOOMANYREFS: 109,\r\n    EUSERS: 87,\r\n    EDQUOT: 122,\r\n    ESTALE: 116,\r\n    ENOTSUP: 95,\r\n    ENOMEDIUM: 123,\r\n    EILSEQ: 84,\r\n    EOVERFLOW: 75,\r\n    ECANCELED: 125,\r\n    ENOTRECOVERABLE: 131,\r\n    EOWNERDEAD: 130,\r\n    ESTRPIPE: 86\r\n  };\r\n\r\n  function ___setErrNo(value) {\r\n    if (Module[\"___errno_location\"]) HEAP32[Module[\"___errno_location\"]() >> 2] = value;\r\n    return value\r\n  }\r\n\r\n  function _clock_gettime(clk_id, tp) {\r\n    var now;\r\n    if (clk_id === 0) {\r\n      now = Date.now()\r\n    } else if (clk_id === 1 && _emscripten_get_now_is_monotonic()) {\r\n      now = _emscripten_get_now()\r\n    } else {\r\n      ___setErrNo(ERRNO_CODES.EINVAL);\r\n      return -1\r\n    }\r\n    HEAP32[tp >> 2] = now / 1e3 | 0;\r\n    HEAP32[tp + 4 >> 2] = now % 1e3 * 1e3 * 1e3 | 0;\r\n    return 0\r\n  }\r\n\r\n  function ___clock_gettime() {\r\n    return _clock_gettime.apply(null, arguments)\r\n  }\r\n\r\n  function ___lock() {}\r\n  var ERRNO_MESSAGES = {\r\n    0: \"Success\",\r\n    1: \"Not super-user\",\r\n    2: \"No such file or directory\",\r\n    3: \"No such process\",\r\n    4: \"Interrupted system call\",\r\n    5: \"I/O error\",\r\n    6: \"No such device or address\",\r\n    7: \"Arg list too long\",\r\n    8: \"Exec format error\",\r\n    9: \"Bad file number\",\r\n    10: \"No children\",\r\n    11: \"No more processes\",\r\n    12: \"Not enough core\",\r\n    13: \"Permission denied\",\r\n    14: \"Bad address\",\r\n    15: \"Block device required\",\r\n    16: \"Mount device busy\",\r\n    17: \"File exists\",\r\n    18: \"Cross-device link\",\r\n    19: \"No such device\",\r\n    20: \"Not a directory\",\r\n    21: \"Is a directory\",\r\n    22: \"Invalid argument\",\r\n    23: \"Too many open files in system\",\r\n    24: \"Too many open files\",\r\n    25: \"Not a typewriter\",\r\n    26: \"Text file busy\",\r\n    27: \"File too large\",\r\n    28: \"No space left on device\",\r\n    29: \"Illegal seek\",\r\n    30: \"Read only file system\",\r\n    31: \"Too many links\",\r\n    32: \"Broken pipe\",\r\n    33: \"Math arg out of domain of func\",\r\n    34: \"Math result not representable\",\r\n    35: \"File locking deadlock error\",\r\n    36: \"File or path name too long\",\r\n    37: \"No record locks available\",\r\n    38: \"Function not implemented\",\r\n    39: \"Directory not empty\",\r\n    40: \"Too many symbolic links\",\r\n    42: \"No message of desired type\",\r\n    43: \"Identifier removed\",\r\n    44: \"Channel number out of range\",\r\n    45: \"Level 2 not synchronized\",\r\n    46: \"Level 3 halted\",\r\n    47: \"Level 3 reset\",\r\n    48: \"Link number out of range\",\r\n    49: \"Protocol driver not attached\",\r\n    50: \"No CSI structure available\",\r\n    51: \"Level 2 halted\",\r\n    52: \"Invalid exchange\",\r\n    53: \"Invalid request descriptor\",\r\n    54: \"Exchange full\",\r\n    55: \"No anode\",\r\n    56: \"Invalid request code\",\r\n    57: \"Invalid slot\",\r\n    59: \"Bad font file fmt\",\r\n    60: \"Device not a stream\",\r\n    61: \"No data (for no delay io)\",\r\n    62: \"Timer expired\",\r\n    63: \"Out of streams resources\",\r\n    64: \"Machine is not on the network\",\r\n    65: \"Package not installed\",\r\n    66: \"The object is remote\",\r\n    67: \"The link has been severed\",\r\n    68: \"Advertise error\",\r\n    69: \"Srmount error\",\r\n    70: \"Communication error on send\",\r\n    71: \"Protocol error\",\r\n    72: \"Multihop attempted\",\r\n    73: \"Cross mount point (not really error)\",\r\n    74: \"Trying to read unreadable message\",\r\n    75: \"Value too large for defined data type\",\r\n    76: \"Given log. name not unique\",\r\n    77: \"f.d. invalid for this operation\",\r\n    78: \"Remote address changed\",\r\n    79: \"Can   access a needed shared lib\",\r\n    80: \"Accessing a corrupted shared lib\",\r\n    81: \".lib section in a.out corrupted\",\r\n    82: \"Attempting to link in too many libs\",\r\n    83: \"Attempting to exec a shared library\",\r\n    84: \"Illegal byte sequence\",\r\n    86: \"Streams pipe error\",\r\n    87: \"Too many users\",\r\n    88: \"Socket operation on non-socket\",\r\n    89: \"Destination address required\",\r\n    90: \"Message too long\",\r\n    91: \"Protocol wrong type for socket\",\r\n    92: \"Protocol not available\",\r\n    93: \"Unknown protocol\",\r\n    94: \"Socket type not supported\",\r\n    95: \"Not supported\",\r\n    96: \"Protocol family not supported\",\r\n    97: \"Address family not supported by protocol family\",\r\n    98: \"Address already in use\",\r\n    99: \"Address not available\",\r\n    100: \"Network interface is not configured\",\r\n    101: \"Network is unreachable\",\r\n    102: \"Connection reset by network\",\r\n    103: \"Connection aborted\",\r\n    104: \"Connection reset by peer\",\r\n    105: \"No buffer space available\",\r\n    106: \"Socket is already connected\",\r\n    107: \"Socket is not connected\",\r\n    108: \"Can't send after socket shutdown\",\r\n    109: \"Too many references\",\r\n    110: \"Connection timed out\",\r\n    111: \"Connection refused\",\r\n    112: \"Host is down\",\r\n    113: \"Host is unreachable\",\r\n    114: \"Socket already connected\",\r\n    115: \"Connection already in progress\",\r\n    116: \"Stale file handle\",\r\n    122: \"Quota exceeded\",\r\n    123: \"No medium (in tape drive)\",\r\n    125: \"Operation canceled\",\r\n    130: \"Previous owner died\",\r\n    131: \"State not recoverable\"\r\n  };\r\n  var PATH = {\r\n    splitPath: (function(filename) {\r\n      var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\n      return splitPathRe.exec(filename).slice(1)\r\n    }),\r\n    normalizeArray: (function(parts, allowAboveRoot) {\r\n      var up = 0;\r\n      for (var i = parts.length - 1; i >= 0; i--) {\r\n        var last = parts[i];\r\n        if (last === \".\") {\r\n          parts.splice(i, 1)\r\n        } else if (last === \"..\") {\r\n          parts.splice(i, 1);\r\n          up++\r\n        } else if (up) {\r\n          parts.splice(i, 1);\r\n          up--\r\n        }\r\n      }\r\n      if (allowAboveRoot) {\r\n        for (; up; up--) {\r\n          parts.unshift(\"..\")\r\n        }\r\n      }\r\n      return parts\r\n    }),\r\n    normalize: (function(path) {\r\n      var isAbsolute = path.charAt(0) === \"/\",\r\n        trailingSlash = path.substr(-1) === \"/\";\r\n      path = PATH.normalizeArray(path.split(\"/\").filter((function(p) {\r\n        return !!p\r\n      })), !isAbsolute).join(\"/\");\r\n      if (!path && !isAbsolute) {\r\n        path = \".\"\r\n      }\r\n      if (path && trailingSlash) {\r\n        path += \"/\"\r\n      }\r\n      return (isAbsolute ? \"/\" : \"\") + path\r\n    }),\r\n    dirname: (function(path) {\r\n      var result = PATH.splitPath(path),\r\n        root = result[0],\r\n        dir = result[1];\r\n      if (!root && !dir) {\r\n        return \".\"\r\n      }\r\n      if (dir) {\r\n        dir = dir.substr(0, dir.length - 1)\r\n      }\r\n      return root + dir\r\n    }),\r\n    basename: (function(path) {\r\n      if (path === \"/\") return \"/\";\r\n      var lastSlash = path.lastIndexOf(\"/\");\r\n      if (lastSlash === -1) return path;\r\n      return path.substr(lastSlash + 1)\r\n    }),\r\n    extname: (function(path) {\r\n      return PATH.splitPath(path)[3]\r\n    }),\r\n    join: (function() {\r\n      var paths = Array.prototype.slice.call(arguments, 0);\r\n      return PATH.normalize(paths.join(\"/\"))\r\n    }),\r\n    join2: (function(l, r) {\r\n      return PATH.normalize(l + \"/\" + r)\r\n    }),\r\n    resolve: (function() {\r\n      var resolvedPath = \"\",\r\n        resolvedAbsolute = false;\r\n      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n        var path = i >= 0 ? arguments[i] : FS.cwd();\r\n        if (typeof path !== \"string\") {\r\n          throw new TypeError(\"Arguments to path.resolve must be strings\")\r\n        } else if (!path) {\r\n          return \"\"\r\n        }\r\n        resolvedPath = path + \"/\" + resolvedPath;\r\n        resolvedAbsolute = path.charAt(0) === \"/\"\r\n      }\r\n      resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter((function(p) {\r\n        return !!p\r\n      })), !resolvedAbsolute).join(\"/\");\r\n      return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\"\r\n    }),\r\n    relative: (function(from, to) {\r\n      from = PATH.resolve(from).substr(1);\r\n      to = PATH.resolve(to).substr(1);\r\n\r\n      function trim(arr) {\r\n        var start = 0;\r\n        for (; start < arr.length; start++) {\r\n          if (arr[start] !== \"\") break\r\n        }\r\n        var end = arr.length - 1;\r\n        for (; end >= 0; end--) {\r\n          if (arr[end] !== \"\") break\r\n        }\r\n        if (start > end) return [];\r\n        return arr.slice(start, end - start + 1)\r\n      }\r\n      var fromParts = trim(from.split(\"/\"));\r\n      var toParts = trim(to.split(\"/\"));\r\n      var length = Math.min(fromParts.length, toParts.length);\r\n      var samePartsLength = length;\r\n      for (var i = 0; i < length; i++) {\r\n        if (fromParts[i] !== toParts[i]) {\r\n          samePartsLength = i;\r\n          break\r\n        }\r\n      }\r\n      var outputParts = [];\r\n      for (var i = samePartsLength; i < fromParts.length; i++) {\r\n        outputParts.push(\"..\")\r\n      }\r\n      outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n      return outputParts.join(\"/\")\r\n    })\r\n  };\r\n  var TTY = {\r\n    ttys: [],\r\n    init: (function() {}),\r\n    shutdown: (function() {}),\r\n    register: (function(dev, ops) {\r\n      TTY.ttys[dev] = {\r\n        input: [],\r\n        output: [],\r\n        ops: ops\r\n      };\r\n      FS.registerDevice(dev, TTY.stream_ops)\r\n    }),\r\n    stream_ops: {\r\n      open: (function(stream) {\r\n        var tty = TTY.ttys[stream.node.rdev];\r\n        if (!tty) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENODEV)\r\n        }\r\n        stream.tty = tty;\r\n        stream.seekable = false\r\n      }),\r\n      close: (function(stream) {\r\n        stream.tty.ops.flush(stream.tty)\r\n      }),\r\n      flush: (function(stream) {\r\n        stream.tty.ops.flush(stream.tty)\r\n      }),\r\n      read: (function(stream, buffer, offset, length, pos) {\r\n        if (!stream.tty || !stream.tty.ops.get_char) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENXIO)\r\n        }\r\n        var bytesRead = 0;\r\n        for (var i = 0; i < length; i++) {\r\n          var result;\r\n          try {\r\n            result = stream.tty.ops.get_char(stream.tty)\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.EIO)\r\n          }\r\n          if (result === undefined && bytesRead === 0) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)\r\n          }\r\n          if (result === null || result === undefined) break;\r\n          bytesRead++;\r\n          buffer[offset + i] = result\r\n        }\r\n        if (bytesRead) {\r\n          stream.node.timestamp = Date.now()\r\n        }\r\n        return bytesRead\r\n      }),\r\n      write: (function(stream, buffer, offset, length, pos) {\r\n        if (!stream.tty || !stream.tty.ops.put_char) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENXIO)\r\n        }\r\n        for (var i = 0; i < length; i++) {\r\n          try {\r\n            stream.tty.ops.put_char(stream.tty, buffer[offset + i])\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.EIO)\r\n          }\r\n        }\r\n        if (length) {\r\n          stream.node.timestamp = Date.now()\r\n        }\r\n        return i\r\n      })\r\n    },\r\n    default_tty_ops: {\r\n      get_char: (function(tty) {\r\n        if (!tty.input.length) {\r\n          var result = null;\r\n          if (ENVIRONMENT_IS_NODE) {\r\n            var BUFSIZE = 256;\r\n            var buf = new Buffer(BUFSIZE);\r\n            var bytesRead = 0;\r\n            var isPosixPlatform = process.platform != \"win32\";\r\n            var fd = process.stdin.fd;\r\n            if (isPosixPlatform) {\r\n              var usingDevice = false;\r\n              try {\r\n                fd = fs.openSync(\"/dev/stdin\", \"r\");\r\n                usingDevice = true\r\n              } catch (e) {}\r\n            }\r\n            try {\r\n              bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null)\r\n            } catch (e) {\r\n              if (e.toString().indexOf(\"EOF\") != -1) bytesRead = 0;\r\n              else throw e\r\n            }\r\n            if (usingDevice) {\r\n              fs.closeSync(fd)\r\n            }\r\n            if (bytesRead > 0) {\r\n              result = buf.slice(0, bytesRead).toString(\"utf-8\")\r\n            } else {\r\n              result = null\r\n            }\r\n          } else if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\r\n            result = window.prompt(\"Input: \");\r\n            if (result !== null) {\r\n              result += \"\\n\"\r\n            }\r\n          } else if (typeof readline == \"function\") {\r\n            result = readline();\r\n            if (result !== null) {\r\n              result += \"\\n\"\r\n            }\r\n          }\r\n          if (!result) {\r\n            return null\r\n          }\r\n          tty.input = intArrayFromString(result, true)\r\n        }\r\n        return tty.input.shift()\r\n      }),\r\n      put_char: (function(tty, val) {\r\n        if (val === null || val === 10) {\r\n          Module[\"print\"](UTF8ArrayToString(tty.output, 0));\r\n          tty.output = []\r\n        } else {\r\n          if (val != 0) tty.output.push(val)\r\n        }\r\n      }),\r\n      flush: (function(tty) {\r\n        if (tty.output && tty.output.length > 0) {\r\n          Module[\"print\"](UTF8ArrayToString(tty.output, 0));\r\n          tty.output = []\r\n        }\r\n      })\r\n    },\r\n    default_tty1_ops: {\r\n      put_char: (function(tty, val) {\r\n        if (val === null || val === 10) {\r\n          Module[\"printErr\"](UTF8ArrayToString(tty.output, 0));\r\n          tty.output = []\r\n        } else {\r\n          if (val != 0) tty.output.push(val)\r\n        }\r\n      }),\r\n      flush: (function(tty) {\r\n        if (tty.output && tty.output.length > 0) {\r\n          Module[\"printErr\"](UTF8ArrayToString(tty.output, 0));\r\n          tty.output = []\r\n        }\r\n      })\r\n    }\r\n  };\r\n  var MEMFS = {\r\n    ops_table: null,\r\n    mount: (function(mount) {\r\n      return MEMFS.createNode(null, \"/\", 16384 | 511, 0)\r\n    }),\r\n    createNode: (function(parent, name, mode, dev) {\r\n      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM)\r\n      }\r\n      if (!MEMFS.ops_table) {\r\n        MEMFS.ops_table = {\r\n          dir: {\r\n            node: {\r\n              getattr: MEMFS.node_ops.getattr,\r\n              setattr: MEMFS.node_ops.setattr,\r\n              lookup: MEMFS.node_ops.lookup,\r\n              mknod: MEMFS.node_ops.mknod,\r\n              rename: MEMFS.node_ops.rename,\r\n              unlink: MEMFS.node_ops.unlink,\r\n              rmdir: MEMFS.node_ops.rmdir,\r\n              readdir: MEMFS.node_ops.readdir,\r\n              symlink: MEMFS.node_ops.symlink\r\n            },\r\n            stream: {\r\n              llseek: MEMFS.stream_ops.llseek\r\n            }\r\n          },\r\n          file: {\r\n            node: {\r\n              getattr: MEMFS.node_ops.getattr,\r\n              setattr: MEMFS.node_ops.setattr\r\n            },\r\n            stream: {\r\n              llseek: MEMFS.stream_ops.llseek,\r\n              read: MEMFS.stream_ops.read,\r\n              write: MEMFS.stream_ops.write,\r\n              allocate: MEMFS.stream_ops.allocate,\r\n              mmap: MEMFS.stream_ops.mmap,\r\n              msync: MEMFS.stream_ops.msync\r\n            }\r\n          },\r\n          link: {\r\n            node: {\r\n              getattr: MEMFS.node_ops.getattr,\r\n              setattr: MEMFS.node_ops.setattr,\r\n              readlink: MEMFS.node_ops.readlink\r\n            },\r\n            stream: {}\r\n          },\r\n          chrdev: {\r\n            node: {\r\n              getattr: MEMFS.node_ops.getattr,\r\n              setattr: MEMFS.node_ops.setattr\r\n            },\r\n            stream: FS.chrdev_stream_ops\r\n          }\r\n        }\r\n      }\r\n      var node = FS.createNode(parent, name, mode, dev);\r\n      if (FS.isDir(node.mode)) {\r\n        node.node_ops = MEMFS.ops_table.dir.node;\r\n        node.stream_ops = MEMFS.ops_table.dir.stream;\r\n        node.contents = {}\r\n      } else if (FS.isFile(node.mode)) {\r\n        node.node_ops = MEMFS.ops_table.file.node;\r\n        node.stream_ops = MEMFS.ops_table.file.stream;\r\n        node.usedBytes = 0;\r\n        node.contents = null\r\n      } else if (FS.isLink(node.mode)) {\r\n        node.node_ops = MEMFS.ops_table.link.node;\r\n        node.stream_ops = MEMFS.ops_table.link.stream\r\n      } else if (FS.isChrdev(node.mode)) {\r\n        node.node_ops = MEMFS.ops_table.chrdev.node;\r\n        node.stream_ops = MEMFS.ops_table.chrdev.stream\r\n      }\r\n      node.timestamp = Date.now();\r\n      if (parent) {\r\n        parent.contents[name] = node\r\n      }\r\n      return node\r\n    }),\r\n    getFileDataAsRegularArray: (function(node) {\r\n      if (node.contents && node.contents.subarray) {\r\n        var arr = [];\r\n        for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);\r\n        return arr\r\n      }\r\n      return node.contents\r\n    }),\r\n    getFileDataAsTypedArray: (function(node) {\r\n      if (!node.contents) return new Uint8Array;\r\n      if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\r\n      return new Uint8Array(node.contents)\r\n    }),\r\n    expandFileStorage: (function(node, newCapacity) {\r\n      if (node.contents && node.contents.subarray && newCapacity > node.contents.length) {\r\n        node.contents = MEMFS.getFileDataAsRegularArray(node);\r\n        node.usedBytes = node.contents.length\r\n      }\r\n      if (!node.contents || node.contents.subarray) {\r\n        var prevCapacity = node.contents ? node.contents.length : 0;\r\n        if (prevCapacity >= newCapacity) return;\r\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\r\n        newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) | 0);\r\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\r\n        var oldContents = node.contents;\r\n        node.contents = new Uint8Array(newCapacity);\r\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\r\n        return\r\n      }\r\n      if (!node.contents && newCapacity > 0) node.contents = [];\r\n      while (node.contents.length < newCapacity) node.contents.push(0)\r\n    }),\r\n    resizeFileStorage: (function(node, newSize) {\r\n      if (node.usedBytes == newSize) return;\r\n      if (newSize == 0) {\r\n        node.contents = null;\r\n        node.usedBytes = 0;\r\n        return\r\n      }\r\n      if (!node.contents || node.contents.subarray) {\r\n        var oldContents = node.contents;\r\n        node.contents = new Uint8Array(new ArrayBuffer(newSize));\r\n        if (oldContents) {\r\n          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)))\r\n        }\r\n        node.usedBytes = newSize;\r\n        return\r\n      }\r\n      if (!node.contents) node.contents = [];\r\n      if (node.contents.length > newSize) node.contents.length = newSize;\r\n      else\r\n        while (node.contents.length < newSize) node.contents.push(0);\r\n      node.usedBytes = newSize\r\n    }),\r\n    node_ops: {\r\n      getattr: (function(node) {\r\n        var attr = {};\r\n        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\r\n        attr.ino = node.id;\r\n        attr.mode = node.mode;\r\n        attr.nlink = 1;\r\n        attr.uid = 0;\r\n        attr.gid = 0;\r\n        attr.rdev = node.rdev;\r\n        if (FS.isDir(node.mode)) {\r\n          attr.size = 4096\r\n        } else if (FS.isFile(node.mode)) {\r\n          attr.size = node.usedBytes\r\n        } else if (FS.isLink(node.mode)) {\r\n          attr.size = node.link.length\r\n        } else {\r\n          attr.size = 0\r\n        }\r\n        attr.atime = new Date(node.timestamp);\r\n        attr.mtime = new Date(node.timestamp);\r\n        attr.ctime = new Date(node.timestamp);\r\n        attr.blksize = 4096;\r\n        attr.blocks = Math.ceil(attr.size / attr.blksize);\r\n        return attr\r\n      }),\r\n      setattr: (function(node, attr) {\r\n        if (attr.mode !== undefined) {\r\n          node.mode = attr.mode\r\n        }\r\n        if (attr.timestamp !== undefined) {\r\n          node.timestamp = attr.timestamp\r\n        }\r\n        if (attr.size !== undefined) {\r\n          MEMFS.resizeFileStorage(node, attr.size)\r\n        }\r\n      }),\r\n      lookup: (function(parent, name) {\r\n        throw FS.genericErrors[ERRNO_CODES.ENOENT]\r\n      }),\r\n      mknod: (function(parent, name, mode, dev) {\r\n        return MEMFS.createNode(parent, name, mode, dev)\r\n      }),\r\n      rename: (function(old_node, new_dir, new_name) {\r\n        if (FS.isDir(old_node.mode)) {\r\n          var new_node;\r\n          try {\r\n            new_node = FS.lookupNode(new_dir, new_name)\r\n          } catch (e) {}\r\n          if (new_node) {\r\n            for (var i in new_node.contents) {\r\n              throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)\r\n            }\r\n          }\r\n        }\r\n        delete old_node.parent.contents[old_node.name];\r\n        old_node.name = new_name;\r\n        new_dir.contents[new_name] = old_node;\r\n        old_node.parent = new_dir\r\n      }),\r\n      unlink: (function(parent, name) {\r\n        delete parent.contents[name]\r\n      }),\r\n      rmdir: (function(parent, name) {\r\n        var node = FS.lookupNode(parent, name);\r\n        for (var i in node.contents) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)\r\n        }\r\n        delete parent.contents[name]\r\n      }),\r\n      readdir: (function(node) {\r\n        var entries = [\".\", \"..\"];\r\n        for (var key in node.contents) {\r\n          if (!node.contents.hasOwnProperty(key)) {\r\n            continue\r\n          }\r\n          entries.push(key)\r\n        }\r\n        return entries\r\n      }),\r\n      symlink: (function(parent, newname, oldpath) {\r\n        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\r\n        node.link = oldpath;\r\n        return node\r\n      }),\r\n      readlink: (function(node) {\r\n        if (!FS.isLink(node.mode)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n        }\r\n        return node.link\r\n      })\r\n    },\r\n    stream_ops: {\r\n      read: (function(stream, buffer, offset, length, position) {\r\n        var contents = stream.node.contents;\r\n        if (position >= stream.node.usedBytes) return 0;\r\n        var size = Math.min(stream.node.usedBytes - position, length);\r\n        assert(size >= 0);\r\n        if (size > 8 && contents.subarray) {\r\n          buffer.set(contents.subarray(position, position + size), offset)\r\n        } else {\r\n          for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i]\r\n        }\r\n        return size\r\n      }),\r\n      write: (function(stream, buffer, offset, length, position, canOwn) {\r\n        if (!length) return 0;\r\n        var node = stream.node;\r\n        node.timestamp = Date.now();\r\n        if (buffer.subarray && (!node.contents || node.contents.subarray)) {\r\n          if (canOwn) {\r\n            node.contents = buffer.subarray(offset, offset + length);\r\n            node.usedBytes = length;\r\n            return length\r\n          } else if (node.usedBytes === 0 && position === 0) {\r\n            node.contents = new Uint8Array(buffer.subarray(offset, offset + length));\r\n            node.usedBytes = length;\r\n            return length\r\n          } else if (position + length <= node.usedBytes) {\r\n            node.contents.set(buffer.subarray(offset, offset + length), position);\r\n            return length\r\n          }\r\n        }\r\n        MEMFS.expandFileStorage(node, position + length);\r\n        if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position);\r\n        else {\r\n          for (var i = 0; i < length; i++) {\r\n            node.contents[position + i] = buffer[offset + i]\r\n          }\r\n        }\r\n        node.usedBytes = Math.max(node.usedBytes, position + length);\r\n        return length\r\n      }),\r\n      llseek: (function(stream, offset, whence) {\r\n        var position = offset;\r\n        if (whence === 1) {\r\n          position += stream.position\r\n        } else if (whence === 2) {\r\n          if (FS.isFile(stream.node.mode)) {\r\n            position += stream.node.usedBytes\r\n          }\r\n        }\r\n        if (position < 0) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n        }\r\n        return position\r\n      }),\r\n      allocate: (function(stream, offset, length) {\r\n        MEMFS.expandFileStorage(stream.node, offset + length);\r\n        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length)\r\n      }),\r\n      mmap: (function(stream, buffer, offset, length, position, prot, flags) {\r\n        if (!FS.isFile(stream.node.mode)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENODEV)\r\n        }\r\n        var ptr;\r\n        var allocated;\r\n        var contents = stream.node.contents;\r\n        if (!(flags & 2) && (contents.buffer === buffer || contents.buffer === buffer.buffer)) {\r\n          allocated = false;\r\n          ptr = contents.byteOffset\r\n        } else {\r\n          if (position > 0 || position + length < stream.node.usedBytes) {\r\n            if (contents.subarray) {\r\n              contents = contents.subarray(position, position + length)\r\n            } else {\r\n              contents = Array.prototype.slice.call(contents, position, position + length)\r\n            }\r\n          }\r\n          allocated = true;\r\n          ptr = _malloc(length);\r\n          if (!ptr) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.ENOMEM)\r\n          }\r\n          buffer.set(contents, ptr)\r\n        }\r\n        return {\r\n          ptr: ptr,\r\n          allocated: allocated\r\n        }\r\n      }),\r\n      msync: (function(stream, buffer, offset, length, mmapFlags) {\r\n        if (!FS.isFile(stream.node.mode)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENODEV)\r\n        }\r\n        if (mmapFlags & 2) {\r\n          return 0\r\n        }\r\n        var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\r\n        return 0\r\n      })\r\n    }\r\n  };\r\n  var IDBFS = {\r\n    dbs: {},\r\n    indexedDB: (function() {\r\n      if (typeof indexedDB !== \"undefined\") return indexedDB;\r\n      var ret = null;\r\n      if (typeof window === \"object\") ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\r\n      assert(ret, \"IDBFS used, but indexedDB not supported\");\r\n      return ret\r\n    }),\r\n    DB_VERSION: 21,\r\n    DB_STORE_NAME: \"FILE_DATA\",\r\n    mount: (function(mount) {\r\n      return MEMFS.mount.apply(null, arguments)\r\n    }),\r\n    syncfs: (function(mount, populate, callback) {\r\n      IDBFS.getLocalSet(mount, (function(err, local) {\r\n        if (err) return callback(err);\r\n        IDBFS.getRemoteSet(mount, (function(err, remote) {\r\n          if (err) return callback(err);\r\n          var src = populate ? remote : local;\r\n          var dst = populate ? local : remote;\r\n          IDBFS.reconcile(src, dst, callback)\r\n        }))\r\n      }))\r\n    }),\r\n    getDB: (function(name, callback) {\r\n      var db = IDBFS.dbs[name];\r\n      if (db) {\r\n        return callback(null, db)\r\n      }\r\n      var req;\r\n      try {\r\n        req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION)\r\n      } catch (e) {\r\n        return callback(e)\r\n      }\r\n      if (!req) {\r\n        return callback(\"Unable to connect to IndexedDB\")\r\n      }\r\n      req.onupgradeneeded = (function(e) {\r\n        var db = e.target.result;\r\n        var transaction = e.target.transaction;\r\n        var fileStore;\r\n        if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {\r\n          fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME)\r\n        } else {\r\n          fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME)\r\n        }\r\n        if (!fileStore.indexNames.contains(\"timestamp\")) {\r\n          fileStore.createIndex(\"timestamp\", \"timestamp\", {\r\n            unique: false\r\n          })\r\n        }\r\n      });\r\n      req.onsuccess = (function() {\r\n        db = req.result;\r\n        IDBFS.dbs[name] = db;\r\n        callback(null, db)\r\n      });\r\n      req.onerror = (function(e) {\r\n        callback(this.error);\r\n        e.preventDefault()\r\n      })\r\n    }),\r\n    getLocalSet: (function(mount, callback) {\r\n      var entries = {};\r\n\r\n      function isRealDir(p) {\r\n        return p !== \".\" && p !== \"..\"\r\n      }\r\n\r\n      function toAbsolute(root) {\r\n        return (function(p) {\r\n          return PATH.join2(root, p)\r\n        })\r\n      }\r\n      var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));\r\n      while (check.length) {\r\n        var path = check.pop();\r\n        var stat;\r\n        try {\r\n          stat = FS.stat(path)\r\n        } catch (e) {\r\n          return callback(e)\r\n        }\r\n        if (FS.isDir(stat.mode)) {\r\n          check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)))\r\n        }\r\n        entries[path] = {\r\n          timestamp: stat.mtime\r\n        }\r\n      }\r\n      return callback(null, {\r\n        type: \"local\",\r\n        entries: entries\r\n      })\r\n    }),\r\n    getRemoteSet: (function(mount, callback) {\r\n      var entries = {};\r\n      IDBFS.getDB(mount.mountpoint, (function(err, db) {\r\n        if (err) return callback(err);\r\n        try {\r\n          var transaction = db.transaction([IDBFS.DB_STORE_NAME], \"readonly\");\r\n          transaction.onerror = (function(e) {\r\n            callback(this.error);\r\n            e.preventDefault()\r\n          });\r\n          var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\r\n          var index = store.index(\"timestamp\");\r\n          index.openKeyCursor().onsuccess = (function(event) {\r\n            var cursor = event.target.result;\r\n            if (!cursor) {\r\n              return callback(null, {\r\n                type: \"remote\",\r\n                db: db,\r\n                entries: entries\r\n              })\r\n            }\r\n            entries[cursor.primaryKey] = {\r\n              timestamp: cursor.key\r\n            };\r\n            cursor.continue()\r\n          })\r\n        } catch (e) {\r\n          return callback(e)\r\n        }\r\n      }))\r\n    }),\r\n    loadLocalEntry: (function(path, callback) {\r\n      var stat, node;\r\n      try {\r\n        var lookup = FS.lookupPath(path);\r\n        node = lookup.node;\r\n        stat = FS.stat(path)\r\n      } catch (e) {\r\n        return callback(e)\r\n      }\r\n      if (FS.isDir(stat.mode)) {\r\n        return callback(null, {\r\n          timestamp: stat.mtime,\r\n          mode: stat.mode\r\n        })\r\n      } else if (FS.isFile(stat.mode)) {\r\n        node.contents = MEMFS.getFileDataAsTypedArray(node);\r\n        return callback(null, {\r\n          timestamp: stat.mtime,\r\n          mode: stat.mode,\r\n          contents: node.contents\r\n        })\r\n      } else {\r\n        return callback(new Error(\"node type not supported\"))\r\n      }\r\n    }),\r\n    storeLocalEntry: (function(path, entry, callback) {\r\n      try {\r\n        if (FS.isDir(entry.mode)) {\r\n          FS.mkdir(path, entry.mode)\r\n        } else if (FS.isFile(entry.mode)) {\r\n          FS.writeFile(path, entry.contents, {\r\n            canOwn: true\r\n          })\r\n        } else {\r\n          return callback(new Error(\"node type not supported\"))\r\n        }\r\n        FS.chmod(path, entry.mode);\r\n        FS.utime(path, entry.timestamp, entry.timestamp)\r\n      } catch (e) {\r\n        return callback(e)\r\n      }\r\n      callback(null)\r\n    }),\r\n    removeLocalEntry: (function(path, callback) {\r\n      try {\r\n        var lookup = FS.lookupPath(path);\r\n        var stat = FS.stat(path);\r\n        if (FS.isDir(stat.mode)) {\r\n          FS.rmdir(path)\r\n        } else if (FS.isFile(stat.mode)) {\r\n          FS.unlink(path)\r\n        }\r\n      } catch (e) {\r\n        return callback(e)\r\n      }\r\n      callback(null)\r\n    }),\r\n    loadRemoteEntry: (function(store, path, callback) {\r\n      var req = store.get(path);\r\n      req.onsuccess = (function(event) {\r\n        callback(null, event.target.result)\r\n      });\r\n      req.onerror = (function(e) {\r\n        callback(this.error);\r\n        e.preventDefault()\r\n      })\r\n    }),\r\n    storeRemoteEntry: (function(store, path, entry, callback) {\r\n      var req = store.put(entry, path);\r\n      req.onsuccess = (function() {\r\n        callback(null)\r\n      });\r\n      req.onerror = (function(e) {\r\n        callback(this.error);\r\n        e.preventDefault()\r\n      })\r\n    }),\r\n    removeRemoteEntry: (function(store, path, callback) {\r\n      var req = store.delete(path);\r\n      req.onsuccess = (function() {\r\n        callback(null)\r\n      });\r\n      req.onerror = (function(e) {\r\n        callback(this.error);\r\n        e.preventDefault()\r\n      })\r\n    }),\r\n    reconcile: (function(src, dst, callback) {\r\n      var total = 0;\r\n      var create = [];\r\n      Object.keys(src.entries).forEach((function(key) {\r\n        var e = src.entries[key];\r\n        var e2 = dst.entries[key];\r\n        if (!e2 || e.timestamp > e2.timestamp) {\r\n          create.push(key);\r\n          total++\r\n        }\r\n      }));\r\n      var remove = [];\r\n      Object.keys(dst.entries).forEach((function(key) {\r\n        var e = dst.entries[key];\r\n        var e2 = src.entries[key];\r\n        if (!e2) {\r\n          remove.push(key);\r\n          total++\r\n        }\r\n      }));\r\n      if (!total) {\r\n        return callback(null)\r\n      }\r\n      var completed = 0;\r\n      var db = src.type === \"remote\" ? src.db : dst.db;\r\n      var transaction = db.transaction([IDBFS.DB_STORE_NAME], \"readwrite\");\r\n      var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\r\n\r\n      function done(err) {\r\n        if (err) {\r\n          if (!done.errored) {\r\n            done.errored = true;\r\n            return callback(err)\r\n          }\r\n          return\r\n        }\r\n        if (++completed >= total) {\r\n          return callback(null)\r\n        }\r\n      }\r\n      transaction.onerror = (function(e) {\r\n        done(this.error);\r\n        e.preventDefault()\r\n      });\r\n      create.sort().forEach((function(path) {\r\n        if (dst.type === \"local\") {\r\n          IDBFS.loadRemoteEntry(store, path, (function(err, entry) {\r\n            if (err) return done(err);\r\n            IDBFS.storeLocalEntry(path, entry, done)\r\n          }))\r\n        } else {\r\n          IDBFS.loadLocalEntry(path, (function(err, entry) {\r\n            if (err) return done(err);\r\n            IDBFS.storeRemoteEntry(store, path, entry, done)\r\n          }))\r\n        }\r\n      }));\r\n      remove.sort().reverse().forEach((function(path) {\r\n        if (dst.type === \"local\") {\r\n          IDBFS.removeLocalEntry(path, done)\r\n        } else {\r\n          IDBFS.removeRemoteEntry(store, path, done)\r\n        }\r\n      }))\r\n    })\r\n  };\r\n  var NODEFS = {\r\n    isWindows: false,\r\n    staticInit: (function() {\r\n      NODEFS.isWindows = !!process.platform.match(/^win/);\r\n      var flags = process[\"binding\"](\"constants\");\r\n      if (flags[\"fs\"]) {\r\n        flags = flags[\"fs\"]\r\n      }\r\n      NODEFS.flagsForNodeMap = {\r\n        \"1024\": flags[\"O_APPEND\"],\r\n        \"64\": flags[\"O_CREAT\"],\r\n        \"128\": flags[\"O_EXCL\"],\r\n        \"0\": flags[\"O_RDONLY\"],\r\n        \"2\": flags[\"O_RDWR\"],\r\n        \"4096\": flags[\"O_SYNC\"],\r\n        \"512\": flags[\"O_TRUNC\"],\r\n        \"1\": flags[\"O_WRONLY\"]\r\n      }\r\n    }),\r\n    bufferFrom: (function(arrayBuffer) {\r\n      return Buffer.alloc ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer)\r\n    }),\r\n    mount: (function(mount) {\r\n      assert(ENVIRONMENT_IS_NODE);\r\n      return NODEFS.createNode(null, \"/\", NODEFS.getMode(mount.opts.root), 0)\r\n    }),\r\n    createNode: (function(parent, name, mode, dev) {\r\n      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n      }\r\n      var node = FS.createNode(parent, name, mode);\r\n      node.node_ops = NODEFS.node_ops;\r\n      node.stream_ops = NODEFS.stream_ops;\r\n      return node\r\n    }),\r\n    getMode: (function(path) {\r\n      var stat;\r\n      try {\r\n        stat = fs.lstatSync(path);\r\n        if (NODEFS.isWindows) {\r\n          stat.mode = stat.mode | (stat.mode & 292) >> 2\r\n        }\r\n      } catch (e) {\r\n        if (!e.code) throw e;\r\n        throw new FS.ErrnoError(ERRNO_CODES[e.code])\r\n      }\r\n      return stat.mode\r\n    }),\r\n    realPath: (function(node) {\r\n      var parts = [];\r\n      while (node.parent !== node) {\r\n        parts.push(node.name);\r\n        node = node.parent\r\n      }\r\n      parts.push(node.mount.opts.root);\r\n      parts.reverse();\r\n      return PATH.join.apply(null, parts)\r\n    }),\r\n    flagsForNode: (function(flags) {\r\n      flags &= ~2097152;\r\n      flags &= ~2048;\r\n      flags &= ~32768;\r\n      flags &= ~524288;\r\n      var newFlags = 0;\r\n      for (var k in NODEFS.flagsForNodeMap) {\r\n        if (flags & k) {\r\n          newFlags |= NODEFS.flagsForNodeMap[k];\r\n          flags ^= k\r\n        }\r\n      }\r\n      if (!flags) {\r\n        return newFlags\r\n      } else {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n      }\r\n    }),\r\n    node_ops: {\r\n      getattr: (function(node) {\r\n        var path = NODEFS.realPath(node);\r\n        var stat;\r\n        try {\r\n          stat = fs.lstatSync(path)\r\n        } catch (e) {\r\n          if (!e.code) throw e;\r\n          throw new FS.ErrnoError(ERRNO_CODES[e.code])\r\n        }\r\n        if (NODEFS.isWindows && !stat.blksize) {\r\n          stat.blksize = 4096\r\n        }\r\n        if (NODEFS.isWindows && !stat.blocks) {\r\n          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0\r\n        }\r\n        return {\r\n          dev: stat.dev,\r\n          ino: stat.ino,\r\n          mode: stat.mode,\r\n          nlink: stat.nlink,\r\n          uid: stat.uid,\r\n          gid: stat.gid,\r\n          rdev: stat.rdev,\r\n          size: stat.size,\r\n          atime: stat.atime,\r\n          mtime: stat.mtime,\r\n          ctime: stat.ctime,\r\n          blksize: stat.blksize,\r\n          blocks: stat.blocks\r\n        }\r\n      }),\r\n      setattr: (function(node, attr) {\r\n        var path = NODEFS.realPath(node);\r\n        try {\r\n          if (attr.mode !== undefined) {\r\n            fs.chmodSync(path, attr.mode);\r\n            node.mode = attr.mode\r\n          }\r\n          if (attr.timestamp !== undefined) {\r\n            var date = new Date(attr.timestamp);\r\n            fs.utimesSync(path, date, date)\r\n          }\r\n          if (attr.size !== undefined) {\r\n            fs.truncateSync(path, attr.size)\r\n          }\r\n        } catch (e) {\r\n          if (!e.code) throw e;\r\n          throw new FS.ErrnoError(ERRNO_CODES[e.code])\r\n        }\r\n      }),\r\n      lookup: (function(parent, name) {\r\n        var path = PATH.join2(NODEFS.realPath(parent), name);\r\n        var mode = NODEFS.getMode(path);\r\n        return NODEFS.createNode(parent, name, mode)\r\n      }),\r\n      mknod: (function(parent, name, mode, dev) {\r\n        var node = NODEFS.createNode(parent, name, mode, dev);\r\n        var path = NODEFS.realPath(node);\r\n        try {\r\n          if (FS.isDir(node.mode)) {\r\n            fs.mkdirSync(path, node.mode)\r\n          } else {\r\n            fs.writeFileSync(path, \"\", {\r\n              mode: node.mode\r\n            })\r\n          }\r\n        } catch (e) {\r\n          if (!e.code) throw e;\r\n          throw new FS.ErrnoError(ERRNO_CODES[e.code])\r\n        }\r\n        return node\r\n      }),\r\n      rename: (function(oldNode, newDir, newName) {\r\n        var oldPath = NODEFS.realPath(oldNode);\r\n        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);\r\n        try {\r\n          fs.renameSync(oldPath, newPath)\r\n        } catch (e) {\r\n          if (!e.code) throw e;\r\n          throw new FS.ErrnoError(ERRNO_CODES[e.code])\r\n        }\r\n      }),\r\n      unlink: (function(parent, name) {\r\n        var path = PATH.join2(NODEFS.realPath(parent), name);\r\n        try {\r\n          fs.unlinkSync(path)\r\n        } catch (e) {\r\n          if (!e.code) throw e;\r\n          throw new FS.ErrnoError(ERRNO_CODES[e.code])\r\n        }\r\n      }),\r\n      rmdir: (function(parent, name) {\r\n        var path = PATH.join2(NODEFS.realPath(parent), name);\r\n        try {\r\n          fs.rmdirSync(path)\r\n        } catch (e) {\r\n          if (!e.code) throw e;\r\n          throw new FS.ErrnoError(ERRNO_CODES[e.code])\r\n        }\r\n      }),\r\n      readdir: (function(node) {\r\n        var path = NODEFS.realPath(node);\r\n        try {\r\n          return fs.readdirSync(path)\r\n        } catch (e) {\r\n          if (!e.code) throw e;\r\n          throw new FS.ErrnoError(ERRNO_CODES[e.code])\r\n        }\r\n      }),\r\n      symlink: (function(parent, newName, oldPath) {\r\n        var newPath = PATH.join2(NODEFS.realPath(parent), newName);\r\n        try {\r\n          fs.symlinkSync(oldPath, newPath)\r\n        } catch (e) {\r\n          if (!e.code) throw e;\r\n          throw new FS.ErrnoError(ERRNO_CODES[e.code])\r\n        }\r\n      }),\r\n      readlink: (function(node) {\r\n        var path = NODEFS.realPath(node);\r\n        try {\r\n          path = fs.readlinkSync(path);\r\n          path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);\r\n          return path\r\n        } catch (e) {\r\n          if (!e.code) throw e;\r\n          throw new FS.ErrnoError(ERRNO_CODES[e.code])\r\n        }\r\n      })\r\n    },\r\n    stream_ops: {\r\n      open: (function(stream) {\r\n        var path = NODEFS.realPath(stream.node);\r\n        try {\r\n          if (FS.isFile(stream.node.mode)) {\r\n            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags))\r\n          }\r\n        } catch (e) {\r\n          if (!e.code) throw e;\r\n          throw new FS.ErrnoError(ERRNO_CODES[e.code])\r\n        }\r\n      }),\r\n      close: (function(stream) {\r\n        try {\r\n          if (FS.isFile(stream.node.mode) && stream.nfd) {\r\n            fs.closeSync(stream.nfd)\r\n          }\r\n        } catch (e) {\r\n          if (!e.code) throw e;\r\n          throw new FS.ErrnoError(ERRNO_CODES[e.code])\r\n        }\r\n      }),\r\n      read: (function(stream, buffer, offset, length, position) {\r\n        if (length === 0) return 0;\r\n        try {\r\n          return fs.readSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position)\r\n        } catch (e) {\r\n          throw new FS.ErrnoError(ERRNO_CODES[e.code])\r\n        }\r\n      }),\r\n      write: (function(stream, buffer, offset, length, position) {\r\n        try {\r\n          return fs.writeSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position)\r\n        } catch (e) {\r\n          throw new FS.ErrnoError(ERRNO_CODES[e.code])\r\n        }\r\n      }),\r\n      llseek: (function(stream, offset, whence) {\r\n        var position = offset;\r\n        if (whence === 1) {\r\n          position += stream.position\r\n        } else if (whence === 2) {\r\n          if (FS.isFile(stream.node.mode)) {\r\n            try {\r\n              var stat = fs.fstatSync(stream.nfd);\r\n              position += stat.size\r\n            } catch (e) {\r\n              throw new FS.ErrnoError(ERRNO_CODES[e.code])\r\n            }\r\n          }\r\n        }\r\n        if (position < 0) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n        }\r\n        return position\r\n      })\r\n    }\r\n  };\r\n  var WORKERFS = {\r\n    DIR_MODE: 16895,\r\n    FILE_MODE: 33279,\r\n    reader: null,\r\n    mount: (function(mount) {\r\n      assert(ENVIRONMENT_IS_WORKER);\r\n      if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync;\r\n      var root = WORKERFS.createNode(null, \"/\", WORKERFS.DIR_MODE, 0);\r\n      var createdParents = {};\r\n\r\n      function ensureParent(path) {\r\n        var parts = path.split(\"/\");\r\n        var parent = root;\r\n        for (var i = 0; i < parts.length - 1; i++) {\r\n          var curr = parts.slice(0, i + 1).join(\"/\");\r\n          if (!createdParents[curr]) {\r\n            createdParents[curr] = WORKERFS.createNode(parent, parts[i], WORKERFS.DIR_MODE, 0)\r\n          }\r\n          parent = createdParents[curr]\r\n        }\r\n        return parent\r\n      }\r\n\r\n      function base(path) {\r\n        var parts = path.split(\"/\");\r\n        return parts[parts.length - 1]\r\n      }\r\n      Array.prototype.forEach.call(mount.opts[\"files\"] || [], (function(file) {\r\n        WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate)\r\n      }));\r\n      (mount.opts[\"blobs\"] || []).forEach((function(obj) {\r\n        WORKERFS.createNode(ensureParent(obj[\"name\"]), base(obj[\"name\"]), WORKERFS.FILE_MODE, 0, obj[\"data\"])\r\n      }));\r\n      (mount.opts[\"packages\"] || []).forEach((function(pack) {\r\n        pack[\"metadata\"].files.forEach((function(file) {\r\n          var name = file.filename.substr(1);\r\n          WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack[\"blob\"].slice(file.start, file.end))\r\n        }))\r\n      }));\r\n      return root\r\n    }),\r\n    createNode: (function(parent, name, mode, dev, contents, mtime) {\r\n      var node = FS.createNode(parent, name, mode);\r\n      node.mode = mode;\r\n      node.node_ops = WORKERFS.node_ops;\r\n      node.stream_ops = WORKERFS.stream_ops;\r\n      node.timestamp = (mtime || new Date).getTime();\r\n      assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);\r\n      if (mode === WORKERFS.FILE_MODE) {\r\n        node.size = contents.size;\r\n        node.contents = contents\r\n      } else {\r\n        node.size = 4096;\r\n        node.contents = {}\r\n      }\r\n      if (parent) {\r\n        parent.contents[name] = node\r\n      }\r\n      return node\r\n    }),\r\n    node_ops: {\r\n      getattr: (function(node) {\r\n        return {\r\n          dev: 1,\r\n          ino: undefined,\r\n          mode: node.mode,\r\n          nlink: 1,\r\n          uid: 0,\r\n          gid: 0,\r\n          rdev: undefined,\r\n          size: node.size,\r\n          atime: new Date(node.timestamp),\r\n          mtime: new Date(node.timestamp),\r\n          ctime: new Date(node.timestamp),\r\n          blksize: 4096,\r\n          blocks: Math.ceil(node.size / 4096)\r\n        }\r\n      }),\r\n      setattr: (function(node, attr) {\r\n        if (attr.mode !== undefined) {\r\n          node.mode = attr.mode\r\n        }\r\n        if (attr.timestamp !== undefined) {\r\n          node.timestamp = attr.timestamp\r\n        }\r\n      }),\r\n      lookup: (function(parent, name) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENOENT)\r\n      }),\r\n      mknod: (function(parent, name, mode, dev) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM)\r\n      }),\r\n      rename: (function(oldNode, newDir, newName) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM)\r\n      }),\r\n      unlink: (function(parent, name) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM)\r\n      }),\r\n      rmdir: (function(parent, name) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM)\r\n      }),\r\n      readdir: (function(node) {\r\n        var entries = [\".\", \"..\"];\r\n        for (var key in node.contents) {\r\n          if (!node.contents.hasOwnProperty(key)) {\r\n            continue\r\n          }\r\n          entries.push(key)\r\n        }\r\n        return entries\r\n      }),\r\n      symlink: (function(parent, newName, oldPath) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM)\r\n      }),\r\n      readlink: (function(node) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM)\r\n      })\r\n    },\r\n    stream_ops: {\r\n      read: (function(stream, buffer, offset, length, position) {\r\n        if (position >= stream.node.size) return 0;\r\n        var chunk = stream.node.contents.slice(position, position + length);\r\n        var ab = WORKERFS.reader.readAsArrayBuffer(chunk);\r\n        buffer.set(new Uint8Array(ab), offset);\r\n        return chunk.size\r\n      }),\r\n      write: (function(stream, buffer, offset, length, position) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EIO)\r\n      }),\r\n      llseek: (function(stream, offset, whence) {\r\n        var position = offset;\r\n        if (whence === 1) {\r\n          position += stream.position\r\n        } else if (whence === 2) {\r\n          if (FS.isFile(stream.node.mode)) {\r\n            position += stream.node.size\r\n          }\r\n        }\r\n        if (position < 0) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n        }\r\n        return position\r\n      })\r\n    }\r\n  };\r\n  STATICTOP += 16;\r\n  STATICTOP += 16;\r\n  STATICTOP += 16;\r\n  var FS = {\r\n    root: null,\r\n    mounts: [],\r\n    devices: {},\r\n    streams: [],\r\n    nextInode: 1,\r\n    nameTable: null,\r\n    currentPath: \"/\",\r\n    initialized: false,\r\n    ignorePermissions: true,\r\n    trackingDelegate: {},\r\n    tracking: {\r\n      openFlags: {\r\n        READ: 1,\r\n        WRITE: 2\r\n      }\r\n    },\r\n    ErrnoError: null,\r\n    genericErrors: {},\r\n    filesystems: null,\r\n    syncFSRequests: 0,\r\n    handleFSError: (function(e) {\r\n      if (!(e instanceof FS.ErrnoError)) throw e + \" : \" + stackTrace();\r\n      return ___setErrNo(e.errno)\r\n    }),\r\n    lookupPath: (function(path, opts) {\r\n      path = PATH.resolve(FS.cwd(), path);\r\n      opts = opts || {};\r\n      if (!path) return {\r\n        path: \"\",\r\n        node: null\r\n      };\r\n      var defaults = {\r\n        follow_mount: true,\r\n        recurse_count: 0\r\n      };\r\n      for (var key in defaults) {\r\n        if (opts[key] === undefined) {\r\n          opts[key] = defaults[key]\r\n        }\r\n      }\r\n      if (opts.recurse_count > 8) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ELOOP)\r\n      }\r\n      var parts = PATH.normalizeArray(path.split(\"/\").filter((function(p) {\r\n        return !!p\r\n      })), false);\r\n      var current = FS.root;\r\n      var current_path = \"/\";\r\n      for (var i = 0; i < parts.length; i++) {\r\n        var islast = i === parts.length - 1;\r\n        if (islast && opts.parent) {\r\n          break\r\n        }\r\n        current = FS.lookupNode(current, parts[i]);\r\n        current_path = PATH.join2(current_path, parts[i]);\r\n        if (FS.isMountpoint(current)) {\r\n          if (!islast || islast && opts.follow_mount) {\r\n            current = current.mounted.root\r\n          }\r\n        }\r\n        if (!islast || opts.follow) {\r\n          var count = 0;\r\n          while (FS.isLink(current.mode)) {\r\n            var link = FS.readlink(current_path);\r\n            current_path = PATH.resolve(PATH.dirname(current_path), link);\r\n            var lookup = FS.lookupPath(current_path, {\r\n              recurse_count: opts.recurse_count\r\n            });\r\n            current = lookup.node;\r\n            if (count++ > 40) {\r\n              throw new FS.ErrnoError(ERRNO_CODES.ELOOP)\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return {\r\n        path: current_path,\r\n        node: current\r\n      }\r\n    }),\r\n    getPath: (function(node) {\r\n      var path;\r\n      while (true) {\r\n        if (FS.isRoot(node)) {\r\n          var mount = node.mount.mountpoint;\r\n          if (!path) return mount;\r\n          return mount[mount.length - 1] !== \"/\" ? mount + \"/\" + path : mount + path\r\n        }\r\n        path = path ? node.name + \"/\" + path : node.name;\r\n        node = node.parent\r\n      }\r\n    }),\r\n    hashName: (function(parentid, name) {\r\n      var hash = 0;\r\n      for (var i = 0; i < name.length; i++) {\r\n        hash = (hash << 5) - hash + name.charCodeAt(i) | 0\r\n      }\r\n      return (parentid + hash >>> 0) % FS.nameTable.length\r\n    }),\r\n    hashAddNode: (function(node) {\r\n      var hash = FS.hashName(node.parent.id, node.name);\r\n      node.name_next = FS.nameTable[hash];\r\n      FS.nameTable[hash] = node\r\n    }),\r\n    hashRemoveNode: (function(node) {\r\n      var hash = FS.hashName(node.parent.id, node.name);\r\n      if (FS.nameTable[hash] === node) {\r\n        FS.nameTable[hash] = node.name_next\r\n      } else {\r\n        var current = FS.nameTable[hash];\r\n        while (current) {\r\n          if (current.name_next === node) {\r\n            current.name_next = node.name_next;\r\n            break\r\n          }\r\n          current = current.name_next\r\n        }\r\n      }\r\n    }),\r\n    lookupNode: (function(parent, name) {\r\n      var err = FS.mayLookup(parent);\r\n      if (err) {\r\n        throw new FS.ErrnoError(err, parent)\r\n      }\r\n      var hash = FS.hashName(parent.id, name);\r\n      for (var node = FS.nameTable[hash]; node; node = node.name_next) {\r\n        var nodeName = node.name;\r\n        if (node.parent.id === parent.id && nodeName === name) {\r\n          return node\r\n        }\r\n      }\r\n      return FS.lookup(parent, name)\r\n    }),\r\n    createNode: (function(parent, name, mode, rdev) {\r\n      if (!FS.FSNode) {\r\n        FS.FSNode = (function(parent, name, mode, rdev) {\r\n          if (!parent) {\r\n            parent = this\r\n          }\r\n          this.parent = parent;\r\n          this.mount = parent.mount;\r\n          this.mounted = null;\r\n          this.id = FS.nextInode++;\r\n          this.name = name;\r\n          this.mode = mode;\r\n          this.node_ops = {};\r\n          this.stream_ops = {};\r\n          this.rdev = rdev\r\n        });\r\n        FS.FSNode.prototype = {};\r\n        var readMode = 292 | 73;\r\n        var writeMode = 146;\r\n        Object.defineProperties(FS.FSNode.prototype, {\r\n          read: {\r\n            get: (function() {\r\n              return (this.mode & readMode) === readMode\r\n            }),\r\n            set: (function(val) {\r\n              val ? this.mode |= readMode : this.mode &= ~readMode\r\n            })\r\n          },\r\n          write: {\r\n            get: (function() {\r\n              return (this.mode & writeMode) === writeMode\r\n            }),\r\n            set: (function(val) {\r\n              val ? this.mode |= writeMode : this.mode &= ~writeMode\r\n            })\r\n          },\r\n          isFolder: {\r\n            get: (function() {\r\n              return FS.isDir(this.mode)\r\n            })\r\n          },\r\n          isDevice: {\r\n            get: (function() {\r\n              return FS.isChrdev(this.mode)\r\n            })\r\n          }\r\n        })\r\n      }\r\n      var node = new FS.FSNode(parent, name, mode, rdev);\r\n      FS.hashAddNode(node);\r\n      return node\r\n    }),\r\n    destroyNode: (function(node) {\r\n      FS.hashRemoveNode(node)\r\n    }),\r\n    isRoot: (function(node) {\r\n      return node === node.parent\r\n    }),\r\n    isMountpoint: (function(node) {\r\n      return !!node.mounted\r\n    }),\r\n    isFile: (function(mode) {\r\n      return (mode & 61440) === 32768\r\n    }),\r\n    isDir: (function(mode) {\r\n      return (mode & 61440) === 16384\r\n    }),\r\n    isLink: (function(mode) {\r\n      return (mode & 61440) === 40960\r\n    }),\r\n    isChrdev: (function(mode) {\r\n      return (mode & 61440) === 8192\r\n    }),\r\n    isBlkdev: (function(mode) {\r\n      return (mode & 61440) === 24576\r\n    }),\r\n    isFIFO: (function(mode) {\r\n      return (mode & 61440) === 4096\r\n    }),\r\n    isSocket: (function(mode) {\r\n      return (mode & 49152) === 49152\r\n    }),\r\n    flagModes: {\r\n      \"r\": 0,\r\n      \"rs\": 1052672,\r\n      \"r+\": 2,\r\n      \"w\": 577,\r\n      \"wx\": 705,\r\n      \"xw\": 705,\r\n      \"w+\": 578,\r\n      \"wx+\": 706,\r\n      \"xw+\": 706,\r\n      \"a\": 1089,\r\n      \"ax\": 1217,\r\n      \"xa\": 1217,\r\n      \"a+\": 1090,\r\n      \"ax+\": 1218,\r\n      \"xa+\": 1218\r\n    },\r\n    modeStringToFlags: (function(str) {\r\n      var flags = FS.flagModes[str];\r\n      if (typeof flags === \"undefined\") {\r\n        throw new Error(\"Unknown file open mode: \" + str)\r\n      }\r\n      return flags\r\n    }),\r\n    flagsToPermissionString: (function(flag) {\r\n      var perms = [\"r\", \"w\", \"rw\"][flag & 3];\r\n      if (flag & 512) {\r\n        perms += \"w\"\r\n      }\r\n      return perms\r\n    }),\r\n    nodePermissions: (function(node, perms) {\r\n      if (FS.ignorePermissions) {\r\n        return 0\r\n      }\r\n      if (perms.indexOf(\"r\") !== -1 && !(node.mode & 292)) {\r\n        return ERRNO_CODES.EACCES\r\n      } else if (perms.indexOf(\"w\") !== -1 && !(node.mode & 146)) {\r\n        return ERRNO_CODES.EACCES\r\n      } else if (perms.indexOf(\"x\") !== -1 && !(node.mode & 73)) {\r\n        return ERRNO_CODES.EACCES\r\n      }\r\n      return 0\r\n    }),\r\n    mayLookup: (function(dir) {\r\n      var err = FS.nodePermissions(dir, \"x\");\r\n      if (err) return err;\r\n      if (!dir.node_ops.lookup) return ERRNO_CODES.EACCES;\r\n      return 0\r\n    }),\r\n    mayCreate: (function(dir, name) {\r\n      try {\r\n        var node = FS.lookupNode(dir, name);\r\n        return ERRNO_CODES.EEXIST\r\n      } catch (e) {}\r\n      return FS.nodePermissions(dir, \"wx\")\r\n    }),\r\n    mayDelete: (function(dir, name, isdir) {\r\n      var node;\r\n      try {\r\n        node = FS.lookupNode(dir, name)\r\n      } catch (e) {\r\n        return e.errno\r\n      }\r\n      var err = FS.nodePermissions(dir, \"wx\");\r\n      if (err) {\r\n        return err\r\n      }\r\n      if (isdir) {\r\n        if (!FS.isDir(node.mode)) {\r\n          return ERRNO_CODES.ENOTDIR\r\n        }\r\n        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\r\n          return ERRNO_CODES.EBUSY\r\n        }\r\n      } else {\r\n        if (FS.isDir(node.mode)) {\r\n          return ERRNO_CODES.EISDIR\r\n        }\r\n      }\r\n      return 0\r\n    }),\r\n    mayOpen: (function(node, flags) {\r\n      if (!node) {\r\n        return ERRNO_CODES.ENOENT\r\n      }\r\n      if (FS.isLink(node.mode)) {\r\n        return ERRNO_CODES.ELOOP\r\n      } else if (FS.isDir(node.mode)) {\r\n        if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) {\r\n          return ERRNO_CODES.EISDIR\r\n        }\r\n      }\r\n      return FS.nodePermissions(node, FS.flagsToPermissionString(flags))\r\n    }),\r\n    MAX_OPEN_FDS: 4096,\r\n    nextfd: (function(fd_start, fd_end) {\r\n      fd_start = fd_start || 0;\r\n      fd_end = fd_end || FS.MAX_OPEN_FDS;\r\n      for (var fd = fd_start; fd <= fd_end; fd++) {\r\n        if (!FS.streams[fd]) {\r\n          return fd\r\n        }\r\n      }\r\n      throw new FS.ErrnoError(ERRNO_CODES.EMFILE)\r\n    }),\r\n    getStream: (function(fd) {\r\n      return FS.streams[fd]\r\n    }),\r\n    createStream: (function(stream, fd_start, fd_end) {\r\n      if (!FS.FSStream) {\r\n        FS.FSStream = (function() {});\r\n        FS.FSStream.prototype = {};\r\n        Object.defineProperties(FS.FSStream.prototype, {\r\n          object: {\r\n            get: (function() {\r\n              return this.node\r\n            }),\r\n            set: (function(val) {\r\n              this.node = val\r\n            })\r\n          },\r\n          isRead: {\r\n            get: (function() {\r\n              return (this.flags & 2097155) !== 1\r\n            })\r\n          },\r\n          isWrite: {\r\n            get: (function() {\r\n              return (this.flags & 2097155) !== 0\r\n            })\r\n          },\r\n          isAppend: {\r\n            get: (function() {\r\n              return this.flags & 1024\r\n            })\r\n          }\r\n        })\r\n      }\r\n      var newStream = new FS.FSStream;\r\n      for (var p in stream) {\r\n        newStream[p] = stream[p]\r\n      }\r\n      stream = newStream;\r\n      var fd = FS.nextfd(fd_start, fd_end);\r\n      stream.fd = fd;\r\n      FS.streams[fd] = stream;\r\n      return stream\r\n    }),\r\n    closeStream: (function(fd) {\r\n      FS.streams[fd] = null\r\n    }),\r\n    chrdev_stream_ops: {\r\n      open: (function(stream) {\r\n        var device = FS.getDevice(stream.node.rdev);\r\n        stream.stream_ops = device.stream_ops;\r\n        if (stream.stream_ops.open) {\r\n          stream.stream_ops.open(stream)\r\n        }\r\n      }),\r\n      llseek: (function() {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)\r\n      })\r\n    },\r\n    major: (function(dev) {\r\n      return dev >> 8\r\n    }),\r\n    minor: (function(dev) {\r\n      return dev & 255\r\n    }),\r\n    makedev: (function(ma, mi) {\r\n      return ma << 8 | mi\r\n    }),\r\n    registerDevice: (function(dev, ops) {\r\n      FS.devices[dev] = {\r\n        stream_ops: ops\r\n      }\r\n    }),\r\n    getDevice: (function(dev) {\r\n      return FS.devices[dev]\r\n    }),\r\n    getMounts: (function(mount) {\r\n      var mounts = [];\r\n      var check = [mount];\r\n      while (check.length) {\r\n        var m = check.pop();\r\n        mounts.push(m);\r\n        check.push.apply(check, m.mounts)\r\n      }\r\n      return mounts\r\n    }),\r\n    syncfs: (function(populate, callback) {\r\n      if (typeof populate === \"function\") {\r\n        callback = populate;\r\n        populate = false\r\n      }\r\n      FS.syncFSRequests++;\r\n      if (FS.syncFSRequests > 1) {\r\n        console.log(\"warning: \" + FS.syncFSRequests + \" FS.syncfs operations in flight at once, probably just doing extra work\")\r\n      }\r\n      var mounts = FS.getMounts(FS.root.mount);\r\n      var completed = 0;\r\n\r\n      function doCallback(err) {\r\n        assert(FS.syncFSRequests > 0);\r\n        FS.syncFSRequests--;\r\n        return callback(err)\r\n      }\r\n\r\n      function done(err) {\r\n        if (err) {\r\n          if (!done.errored) {\r\n            done.errored = true;\r\n            return doCallback(err)\r\n          }\r\n          return\r\n        }\r\n        if (++completed >= mounts.length) {\r\n          doCallback(null)\r\n        }\r\n      }\r\n      mounts.forEach((function(mount) {\r\n        if (!mount.type.syncfs) {\r\n          return done(null)\r\n        }\r\n        mount.type.syncfs(mount, populate, done)\r\n      }))\r\n    }),\r\n    mount: (function(type, opts, mountpoint) {\r\n      var root = mountpoint === \"/\";\r\n      var pseudo = !mountpoint;\r\n      var node;\r\n      if (root && FS.root) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EBUSY)\r\n      } else if (!root && !pseudo) {\r\n        var lookup = FS.lookupPath(mountpoint, {\r\n          follow_mount: false\r\n        });\r\n        mountpoint = lookup.path;\r\n        node = lookup.node;\r\n        if (FS.isMountpoint(node)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBUSY)\r\n        }\r\n        if (!FS.isDir(node.mode)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)\r\n        }\r\n      }\r\n      var mount = {\r\n        type: type,\r\n        opts: opts,\r\n        mountpoint: mountpoint,\r\n        mounts: []\r\n      };\r\n      var mountRoot = type.mount(mount);\r\n      mountRoot.mount = mount;\r\n      mount.root = mountRoot;\r\n      if (root) {\r\n        FS.root = mountRoot\r\n      } else if (node) {\r\n        node.mounted = mount;\r\n        if (node.mount) {\r\n          node.mount.mounts.push(mount)\r\n        }\r\n      }\r\n      return mountRoot\r\n    }),\r\n    unmount: (function(mountpoint) {\r\n      var lookup = FS.lookupPath(mountpoint, {\r\n        follow_mount: false\r\n      });\r\n      if (!FS.isMountpoint(lookup.node)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n      }\r\n      var node = lookup.node;\r\n      var mount = node.mounted;\r\n      var mounts = FS.getMounts(mount);\r\n      Object.keys(FS.nameTable).forEach((function(hash) {\r\n        var current = FS.nameTable[hash];\r\n        while (current) {\r\n          var next = current.name_next;\r\n          if (mounts.indexOf(current.mount) !== -1) {\r\n            FS.destroyNode(current)\r\n          }\r\n          current = next\r\n        }\r\n      }));\r\n      node.mounted = null;\r\n      var idx = node.mount.mounts.indexOf(mount);\r\n      assert(idx !== -1);\r\n      node.mount.mounts.splice(idx, 1)\r\n    }),\r\n    lookup: (function(parent, name) {\r\n      return parent.node_ops.lookup(parent, name)\r\n    }),\r\n    mknod: (function(path, mode, dev) {\r\n      var lookup = FS.lookupPath(path, {\r\n        parent: true\r\n      });\r\n      var parent = lookup.node;\r\n      var name = PATH.basename(path);\r\n      if (!name || name === \".\" || name === \"..\") {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n      }\r\n      var err = FS.mayCreate(parent, name);\r\n      if (err) {\r\n        throw new FS.ErrnoError(err)\r\n      }\r\n      if (!parent.node_ops.mknod) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM)\r\n      }\r\n      return parent.node_ops.mknod(parent, name, mode, dev)\r\n    }),\r\n    create: (function(path, mode) {\r\n      mode = mode !== undefined ? mode : 438;\r\n      mode &= 4095;\r\n      mode |= 32768;\r\n      return FS.mknod(path, mode, 0)\r\n    }),\r\n    mkdir: (function(path, mode) {\r\n      mode = mode !== undefined ? mode : 511;\r\n      mode &= 511 | 512;\r\n      mode |= 16384;\r\n      return FS.mknod(path, mode, 0)\r\n    }),\r\n    mkdirTree: (function(path, mode) {\r\n      var dirs = path.split(\"/\");\r\n      var d = \"\";\r\n      for (var i = 0; i < dirs.length; ++i) {\r\n        if (!dirs[i]) continue;\r\n        d += \"/\" + dirs[i];\r\n        try {\r\n          FS.mkdir(d, mode)\r\n        } catch (e) {\r\n          if (e.errno != ERRNO_CODES.EEXIST) throw e\r\n        }\r\n      }\r\n    }),\r\n    mkdev: (function(path, mode, dev) {\r\n      if (typeof dev === \"undefined\") {\r\n        dev = mode;\r\n        mode = 438\r\n      }\r\n      mode |= 8192;\r\n      return FS.mknod(path, mode, dev)\r\n    }),\r\n    symlink: (function(oldpath, newpath) {\r\n      if (!PATH.resolve(oldpath)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENOENT)\r\n      }\r\n      var lookup = FS.lookupPath(newpath, {\r\n        parent: true\r\n      });\r\n      var parent = lookup.node;\r\n      if (!parent) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENOENT)\r\n      }\r\n      var newname = PATH.basename(newpath);\r\n      var err = FS.mayCreate(parent, newname);\r\n      if (err) {\r\n        throw new FS.ErrnoError(err)\r\n      }\r\n      if (!parent.node_ops.symlink) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM)\r\n      }\r\n      return parent.node_ops.symlink(parent, newname, oldpath)\r\n    }),\r\n    rename: (function(old_path, new_path) {\r\n      var old_dirname = PATH.dirname(old_path);\r\n      var new_dirname = PATH.dirname(new_path);\r\n      var old_name = PATH.basename(old_path);\r\n      var new_name = PATH.basename(new_path);\r\n      var lookup, old_dir, new_dir;\r\n      try {\r\n        lookup = FS.lookupPath(old_path, {\r\n          parent: true\r\n        });\r\n        old_dir = lookup.node;\r\n        lookup = FS.lookupPath(new_path, {\r\n          parent: true\r\n        });\r\n        new_dir = lookup.node\r\n      } catch (e) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EBUSY)\r\n      }\r\n      if (!old_dir || !new_dir) throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\r\n      if (old_dir.mount !== new_dir.mount) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EXDEV)\r\n      }\r\n      var old_node = FS.lookupNode(old_dir, old_name);\r\n      var relative = PATH.relative(old_path, new_dirname);\r\n      if (relative.charAt(0) !== \".\") {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n      }\r\n      relative = PATH.relative(new_path, old_dirname);\r\n      if (relative.charAt(0) !== \".\") {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)\r\n      }\r\n      var new_node;\r\n      try {\r\n        new_node = FS.lookupNode(new_dir, new_name)\r\n      } catch (e) {}\r\n      if (old_node === new_node) {\r\n        return\r\n      }\r\n      var isdir = FS.isDir(old_node.mode);\r\n      var err = FS.mayDelete(old_dir, old_name, isdir);\r\n      if (err) {\r\n        throw new FS.ErrnoError(err)\r\n      }\r\n      err = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\r\n      if (err) {\r\n        throw new FS.ErrnoError(err)\r\n      }\r\n      if (!old_dir.node_ops.rename) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM)\r\n      }\r\n      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EBUSY)\r\n      }\r\n      if (new_dir !== old_dir) {\r\n        err = FS.nodePermissions(old_dir, \"w\");\r\n        if (err) {\r\n          throw new FS.ErrnoError(err)\r\n        }\r\n      }\r\n      try {\r\n        if (FS.trackingDelegate[\"willMovePath\"]) {\r\n          FS.trackingDelegate[\"willMovePath\"](old_path, new_path)\r\n        }\r\n      } catch (e) {\r\n        console.log(\"FS.trackingDelegate['willMovePath']('\" + old_path + \"', '\" + new_path + \"') threw an exception: \" + e.message)\r\n      }\r\n      FS.hashRemoveNode(old_node);\r\n      try {\r\n        old_dir.node_ops.rename(old_node, new_dir, new_name)\r\n      } catch (e) {\r\n        throw e\r\n      } finally {\r\n        FS.hashAddNode(old_node)\r\n      }\r\n      try {\r\n        if (FS.trackingDelegate[\"onMovePath\"]) FS.trackingDelegate[\"onMovePath\"](old_path, new_path)\r\n      } catch (e) {\r\n        console.log(\"FS.trackingDelegate['onMovePath']('\" + old_path + \"', '\" + new_path + \"') threw an exception: \" + e.message)\r\n      }\r\n    }),\r\n    rmdir: (function(path) {\r\n      var lookup = FS.lookupPath(path, {\r\n        parent: true\r\n      });\r\n      var parent = lookup.node;\r\n      var name = PATH.basename(path);\r\n      var node = FS.lookupNode(parent, name);\r\n      var err = FS.mayDelete(parent, name, true);\r\n      if (err) {\r\n        throw new FS.ErrnoError(err)\r\n      }\r\n      if (!parent.node_ops.rmdir) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM)\r\n      }\r\n      if (FS.isMountpoint(node)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EBUSY)\r\n      }\r\n      try {\r\n        if (FS.trackingDelegate[\"willDeletePath\"]) {\r\n          FS.trackingDelegate[\"willDeletePath\"](path)\r\n        }\r\n      } catch (e) {\r\n        console.log(\"FS.trackingDelegate['willDeletePath']('\" + path + \"') threw an exception: \" + e.message)\r\n      }\r\n      parent.node_ops.rmdir(parent, name);\r\n      FS.destroyNode(node);\r\n      try {\r\n        if (FS.trackingDelegate[\"onDeletePath\"]) FS.trackingDelegate[\"onDeletePath\"](path)\r\n      } catch (e) {\r\n        console.log(\"FS.trackingDelegate['onDeletePath']('\" + path + \"') threw an exception: \" + e.message)\r\n      }\r\n    }),\r\n    readdir: (function(path) {\r\n      var lookup = FS.lookupPath(path, {\r\n        follow: true\r\n      });\r\n      var node = lookup.node;\r\n      if (!node.node_ops.readdir) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)\r\n      }\r\n      return node.node_ops.readdir(node)\r\n    }),\r\n    unlink: (function(path) {\r\n      var lookup = FS.lookupPath(path, {\r\n        parent: true\r\n      });\r\n      var parent = lookup.node;\r\n      var name = PATH.basename(path);\r\n      var node = FS.lookupNode(parent, name);\r\n      var err = FS.mayDelete(parent, name, false);\r\n      if (err) {\r\n        throw new FS.ErrnoError(err)\r\n      }\r\n      if (!parent.node_ops.unlink) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM)\r\n      }\r\n      if (FS.isMountpoint(node)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EBUSY)\r\n      }\r\n      try {\r\n        if (FS.trackingDelegate[\"willDeletePath\"]) {\r\n          FS.trackingDelegate[\"willDeletePath\"](path)\r\n        }\r\n      } catch (e) {\r\n        console.log(\"FS.trackingDelegate['willDeletePath']('\" + path + \"') threw an exception: \" + e.message)\r\n      }\r\n      parent.node_ops.unlink(parent, name);\r\n      FS.destroyNode(node);\r\n      try {\r\n        if (FS.trackingDelegate[\"onDeletePath\"]) FS.trackingDelegate[\"onDeletePath\"](path)\r\n      } catch (e) {\r\n        console.log(\"FS.trackingDelegate['onDeletePath']('\" + path + \"') threw an exception: \" + e.message)\r\n      }\r\n    }),\r\n    readlink: (function(path) {\r\n      var lookup = FS.lookupPath(path);\r\n      var link = lookup.node;\r\n      if (!link) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENOENT)\r\n      }\r\n      if (!link.node_ops.readlink) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n      }\r\n      return PATH.resolve(FS.getPath(link.parent), link.node_ops.readlink(link))\r\n    }),\r\n    stat: (function(path, dontFollow) {\r\n      var lookup = FS.lookupPath(path, {\r\n        follow: !dontFollow\r\n      });\r\n      var node = lookup.node;\r\n      if (!node) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENOENT)\r\n      }\r\n      if (!node.node_ops.getattr) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM)\r\n      }\r\n      return node.node_ops.getattr(node)\r\n    }),\r\n    lstat: (function(path) {\r\n      return FS.stat(path, true)\r\n    }),\r\n    chmod: (function(path, mode, dontFollow) {\r\n      var node;\r\n      if (typeof path === \"string\") {\r\n        var lookup = FS.lookupPath(path, {\r\n          follow: !dontFollow\r\n        });\r\n        node = lookup.node\r\n      } else {\r\n        node = path\r\n      }\r\n      if (!node.node_ops.setattr) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM)\r\n      }\r\n      node.node_ops.setattr(node, {\r\n        mode: mode & 4095 | node.mode & ~4095,\r\n        timestamp: Date.now()\r\n      })\r\n    }),\r\n    lchmod: (function(path, mode) {\r\n      FS.chmod(path, mode, true)\r\n    }),\r\n    fchmod: (function(fd, mode) {\r\n      var stream = FS.getStream(fd);\r\n      if (!stream) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EBADF)\r\n      }\r\n      FS.chmod(stream.node, mode)\r\n    }),\r\n    chown: (function(path, uid, gid, dontFollow) {\r\n      var node;\r\n      if (typeof path === \"string\") {\r\n        var lookup = FS.lookupPath(path, {\r\n          follow: !dontFollow\r\n        });\r\n        node = lookup.node\r\n      } else {\r\n        node = path\r\n      }\r\n      if (!node.node_ops.setattr) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM)\r\n      }\r\n      node.node_ops.setattr(node, {\r\n        timestamp: Date.now()\r\n      })\r\n    }),\r\n    lchown: (function(path, uid, gid) {\r\n      FS.chown(path, uid, gid, true)\r\n    }),\r\n    fchown: (function(fd, uid, gid) {\r\n      var stream = FS.getStream(fd);\r\n      if (!stream) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EBADF)\r\n      }\r\n      FS.chown(stream.node, uid, gid)\r\n    }),\r\n    truncate: (function(path, len) {\r\n      if (len < 0) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n      }\r\n      var node;\r\n      if (typeof path === \"string\") {\r\n        var lookup = FS.lookupPath(path, {\r\n          follow: true\r\n        });\r\n        node = lookup.node\r\n      } else {\r\n        node = path\r\n      }\r\n      if (!node.node_ops.setattr) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM)\r\n      }\r\n      if (FS.isDir(node.mode)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EISDIR)\r\n      }\r\n      if (!FS.isFile(node.mode)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n      }\r\n      var err = FS.nodePermissions(node, \"w\");\r\n      if (err) {\r\n        throw new FS.ErrnoError(err)\r\n      }\r\n      node.node_ops.setattr(node, {\r\n        size: len,\r\n        timestamp: Date.now()\r\n      })\r\n    }),\r\n    ftruncate: (function(fd, len) {\r\n      var stream = FS.getStream(fd);\r\n      if (!stream) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EBADF)\r\n      }\r\n      if ((stream.flags & 2097155) === 0) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n      }\r\n      FS.truncate(stream.node, len)\r\n    }),\r\n    utime: (function(path, atime, mtime) {\r\n      var lookup = FS.lookupPath(path, {\r\n        follow: true\r\n      });\r\n      var node = lookup.node;\r\n      node.node_ops.setattr(node, {\r\n        timestamp: Math.max(atime, mtime)\r\n      })\r\n    }),\r\n    open: (function(path, flags, mode, fd_start, fd_end) {\r\n      if (path === \"\") {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENOENT)\r\n      }\r\n      flags = typeof flags === \"string\" ? FS.modeStringToFlags(flags) : flags;\r\n      mode = typeof mode === \"undefined\" ? 438 : mode;\r\n      if (flags & 64) {\r\n        mode = mode & 4095 | 32768\r\n      } else {\r\n        mode = 0\r\n      }\r\n      var node;\r\n      if (typeof path === \"object\") {\r\n        node = path\r\n      } else {\r\n        path = PATH.normalize(path);\r\n        try {\r\n          var lookup = FS.lookupPath(path, {\r\n            follow: !(flags & 131072)\r\n          });\r\n          node = lookup.node\r\n        } catch (e) {}\r\n      }\r\n      var created = false;\r\n      if (flags & 64) {\r\n        if (node) {\r\n          if (flags & 128) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.EEXIST)\r\n          }\r\n        } else {\r\n          node = FS.mknod(path, mode, 0);\r\n          created = true\r\n        }\r\n      }\r\n      if (!node) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENOENT)\r\n      }\r\n      if (FS.isChrdev(node.mode)) {\r\n        flags &= ~512\r\n      }\r\n      if (flags & 65536 && !FS.isDir(node.mode)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)\r\n      }\r\n      if (!created) {\r\n        var err = FS.mayOpen(node, flags);\r\n        if (err) {\r\n          throw new FS.ErrnoError(err)\r\n        }\r\n      }\r\n      if (flags & 512) {\r\n        FS.truncate(node, 0)\r\n      }\r\n      flags &= ~(128 | 512);\r\n      var stream = FS.createStream({\r\n        node: node,\r\n        path: FS.getPath(node),\r\n        flags: flags,\r\n        seekable: true,\r\n        position: 0,\r\n        stream_ops: node.stream_ops,\r\n        ungotten: [],\r\n        error: false\r\n      }, fd_start, fd_end);\r\n      if (stream.stream_ops.open) {\r\n        stream.stream_ops.open(stream)\r\n      }\r\n      if (Module[\"logReadFiles\"] && !(flags & 1)) {\r\n        if (!FS.readFiles) FS.readFiles = {};\r\n        if (!(path in FS.readFiles)) {\r\n          FS.readFiles[path] = 1;\r\n          Module[\"printErr\"](\"read file: \" + path)\r\n        }\r\n      }\r\n      try {\r\n        if (FS.trackingDelegate[\"onOpenFile\"]) {\r\n          var trackingFlags = 0;\r\n          if ((flags & 2097155) !== 1) {\r\n            trackingFlags |= FS.tracking.openFlags.READ\r\n          }\r\n          if ((flags & 2097155) !== 0) {\r\n            trackingFlags |= FS.tracking.openFlags.WRITE\r\n          }\r\n          FS.trackingDelegate[\"onOpenFile\"](path, trackingFlags)\r\n        }\r\n      } catch (e) {\r\n        console.log(\"FS.trackingDelegate['onOpenFile']('\" + path + \"', flags) threw an exception: \" + e.message)\r\n      }\r\n      return stream\r\n    }),\r\n    close: (function(stream) {\r\n      if (stream.getdents) stream.getdents = null;\r\n      try {\r\n        if (stream.stream_ops.close) {\r\n          stream.stream_ops.close(stream)\r\n        }\r\n      } catch (e) {\r\n        throw e\r\n      } finally {\r\n        FS.closeStream(stream.fd)\r\n      }\r\n    }),\r\n    llseek: (function(stream, offset, whence) {\r\n      if (!stream.seekable || !stream.stream_ops.llseek) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)\r\n      }\r\n      stream.position = stream.stream_ops.llseek(stream, offset, whence);\r\n      stream.ungotten = [];\r\n      return stream.position\r\n    }),\r\n    read: (function(stream, buffer, offset, length, position) {\r\n      if (length < 0 || position < 0) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n      }\r\n      if ((stream.flags & 2097155) === 1) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EBADF)\r\n      }\r\n      if (FS.isDir(stream.node.mode)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EISDIR)\r\n      }\r\n      if (!stream.stream_ops.read) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n      }\r\n      var seeking = typeof position !== \"undefined\";\r\n      if (!seeking) {\r\n        position = stream.position\r\n      } else if (!stream.seekable) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)\r\n      }\r\n      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\r\n      if (!seeking) stream.position += bytesRead;\r\n      return bytesRead\r\n    }),\r\n    write: (function(stream, buffer, offset, length, position, canOwn) {\r\n      if (length < 0 || position < 0) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n      }\r\n      if ((stream.flags & 2097155) === 0) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EBADF)\r\n      }\r\n      if (FS.isDir(stream.node.mode)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EISDIR)\r\n      }\r\n      if (!stream.stream_ops.write) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n      }\r\n      if (stream.flags & 1024) {\r\n        FS.llseek(stream, 0, 2)\r\n      }\r\n      var seeking = typeof position !== \"undefined\";\r\n      if (!seeking) {\r\n        position = stream.position\r\n      } else if (!stream.seekable) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)\r\n      }\r\n      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\r\n      if (!seeking) stream.position += bytesWritten;\r\n      try {\r\n        if (stream.path && FS.trackingDelegate[\"onWriteToFile\"]) FS.trackingDelegate[\"onWriteToFile\"](stream.path)\r\n      } catch (e) {\r\n        console.log(\"FS.trackingDelegate['onWriteToFile']('\" + path + \"') threw an exception: \" + e.message)\r\n      }\r\n      return bytesWritten\r\n    }),\r\n    allocate: (function(stream, offset, length) {\r\n      if (offset < 0 || length <= 0) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n      }\r\n      if ((stream.flags & 2097155) === 0) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EBADF)\r\n      }\r\n      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENODEV)\r\n      }\r\n      if (!stream.stream_ops.allocate) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP)\r\n      }\r\n      stream.stream_ops.allocate(stream, offset, length)\r\n    }),\r\n    mmap: (function(stream, buffer, offset, length, position, prot, flags) {\r\n      if ((stream.flags & 2097155) === 1) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EACCES)\r\n      }\r\n      if (!stream.stream_ops.mmap) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENODEV)\r\n      }\r\n      return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags)\r\n    }),\r\n    msync: (function(stream, buffer, offset, length, mmapFlags) {\r\n      if (!stream || !stream.stream_ops.msync) {\r\n        return 0\r\n      }\r\n      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags)\r\n    }),\r\n    munmap: (function(stream) {\r\n      return 0\r\n    }),\r\n    ioctl: (function(stream, cmd, arg) {\r\n      if (!stream.stream_ops.ioctl) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENOTTY)\r\n      }\r\n      return stream.stream_ops.ioctl(stream, cmd, arg)\r\n    }),\r\n    readFile: (function(path, opts) {\r\n      opts = opts || {};\r\n      opts.flags = opts.flags || \"r\";\r\n      opts.encoding = opts.encoding || \"binary\";\r\n      if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\r\n        throw new Error('Invalid encoding type \"' + opts.encoding + '\"')\r\n      }\r\n      var ret;\r\n      var stream = FS.open(path, opts.flags);\r\n      var stat = FS.stat(path);\r\n      var length = stat.size;\r\n      var buf = new Uint8Array(length);\r\n      FS.read(stream, buf, 0, length, 0);\r\n      if (opts.encoding === \"utf8\") {\r\n        ret = UTF8ArrayToString(buf, 0)\r\n      } else if (opts.encoding === \"binary\") {\r\n        ret = buf\r\n      }\r\n      FS.close(stream);\r\n      return ret\r\n    }),\r\n    writeFile: (function(path, data, opts) {\r\n      opts = opts || {};\r\n      opts.flags = opts.flags || \"w\";\r\n      var stream = FS.open(path, opts.flags, opts.mode);\r\n      if (typeof data === \"string\") {\r\n        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\r\n        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\r\n        FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn)\r\n      } else if (ArrayBuffer.isView(data)) {\r\n        FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn)\r\n      } else {\r\n        throw new Error(\"Unsupported data type\")\r\n      }\r\n      FS.close(stream)\r\n    }),\r\n    cwd: (function() {\r\n      return FS.currentPath\r\n    }),\r\n    chdir: (function(path) {\r\n      var lookup = FS.lookupPath(path, {\r\n        follow: true\r\n      });\r\n      if (lookup.node === null) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENOENT)\r\n      }\r\n      if (!FS.isDir(lookup.node.mode)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)\r\n      }\r\n      var err = FS.nodePermissions(lookup.node, \"x\");\r\n      if (err) {\r\n        throw new FS.ErrnoError(err)\r\n      }\r\n      FS.currentPath = lookup.path\r\n    }),\r\n    createDefaultDirectories: (function() {\r\n      FS.mkdir(\"/tmp\");\r\n      FS.mkdir(\"/home\");\r\n      FS.mkdir(\"/home/web_user\")\r\n    }),\r\n    createDefaultDevices: (function() {\r\n      FS.mkdir(\"/dev\");\r\n      FS.registerDevice(FS.makedev(1, 3), {\r\n        read: (function() {\r\n          return 0\r\n        }),\r\n        write: (function(stream, buffer, offset, length, pos) {\r\n          return length\r\n        })\r\n      });\r\n      FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\r\n      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\r\n      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\r\n      FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\r\n      FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\r\n      var random_device;\r\n      if (typeof crypto !== \"undefined\") {\r\n        var randomBuffer = new Uint8Array(1);\r\n        random_device = (function() {\r\n          crypto.getRandomValues(randomBuffer);\r\n          return randomBuffer[0]\r\n        })\r\n      } else if (ENVIRONMENT_IS_NODE) {\r\n        random_device = (function() {\r\n          return __webpack_require__(/*! crypto */ \"crypto\")[\"randomBytes\"](1)[0]\r\n        })\r\n      } else {\r\n        random_device = (function() {\r\n          return Math.random() * 256 | 0\r\n        })\r\n      }\r\n      FS.createDevice(\"/dev\", \"random\", random_device);\r\n      FS.createDevice(\"/dev\", \"urandom\", random_device);\r\n      FS.mkdir(\"/dev/shm\");\r\n      FS.mkdir(\"/dev/shm/tmp\")\r\n    }),\r\n    createSpecialDirectories: (function() {\r\n      FS.mkdir(\"/proc\");\r\n      FS.mkdir(\"/proc/self\");\r\n      FS.mkdir(\"/proc/self/fd\");\r\n      FS.mount({\r\n        mount: (function() {\r\n          var node = FS.createNode(\"/proc/self\", \"fd\", 16384 | 511, 73);\r\n          node.node_ops = {\r\n            lookup: (function(parent, name) {\r\n              var fd = +name;\r\n              var stream = FS.getStream(fd);\r\n              if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n              var ret = {\r\n                parent: null,\r\n                mount: {\r\n                  mountpoint: \"fake\"\r\n                },\r\n                node_ops: {\r\n                  readlink: (function() {\r\n                    return stream.path\r\n                  })\r\n                }\r\n              };\r\n              ret.parent = ret;\r\n              return ret\r\n            })\r\n          };\r\n          return node\r\n        })\r\n      }, {}, \"/proc/self/fd\")\r\n    }),\r\n    createStandardStreams: (function() {\r\n      if (Module[\"stdin\"]) {\r\n        FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"])\r\n      } else {\r\n        FS.symlink(\"/dev/tty\", \"/dev/stdin\")\r\n      }\r\n      if (Module[\"stdout\"]) {\r\n        FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"])\r\n      } else {\r\n        FS.symlink(\"/dev/tty\", \"/dev/stdout\")\r\n      }\r\n      if (Module[\"stderr\"]) {\r\n        FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"])\r\n      } else {\r\n        FS.symlink(\"/dev/tty1\", \"/dev/stderr\")\r\n      }\r\n      var stdin = FS.open(\"/dev/stdin\", \"r\");\r\n      assert(stdin.fd === 0, \"invalid handle for stdin (\" + stdin.fd + \")\");\r\n      var stdout = FS.open(\"/dev/stdout\", \"w\");\r\n      assert(stdout.fd === 1, \"invalid handle for stdout (\" + stdout.fd + \")\");\r\n      var stderr = FS.open(\"/dev/stderr\", \"w\");\r\n      assert(stderr.fd === 2, \"invalid handle for stderr (\" + stderr.fd + \")\")\r\n    }),\r\n    ensureErrnoError: (function() {\r\n      if (FS.ErrnoError) return;\r\n      FS.ErrnoError = function ErrnoError(errno, node) {\r\n        this.node = node;\r\n        this.setErrno = (function(errno) {\r\n          this.errno = errno;\r\n          for (var key in ERRNO_CODES) {\r\n            if (ERRNO_CODES[key] === errno) {\r\n              this.code = key;\r\n              break\r\n            }\r\n          }\r\n        });\r\n        this.setErrno(errno);\r\n        this.message = ERRNO_MESSAGES[errno];\r\n        if (this.stack) Object.defineProperty(this, \"stack\", {\r\n          value: (new Error).stack,\r\n          writable: true\r\n        })\r\n      };\r\n      FS.ErrnoError.prototype = new Error;\r\n      FS.ErrnoError.prototype.constructor = FS.ErrnoError;\r\n      [ERRNO_CODES.ENOENT].forEach((function(code) {\r\n        FS.genericErrors[code] = new FS.ErrnoError(code);\r\n        FS.genericErrors[code].stack = \"<generic error, no stack>\"\r\n      }))\r\n    }),\r\n    staticInit: (function() {\r\n      FS.ensureErrnoError();\r\n      FS.nameTable = new Array(4096);\r\n      FS.mount(MEMFS, {}, \"/\");\r\n      FS.createDefaultDirectories();\r\n      FS.createDefaultDevices();\r\n      FS.createSpecialDirectories();\r\n      FS.filesystems = {\r\n        \"MEMFS\": MEMFS,\r\n        \"IDBFS\": IDBFS,\r\n        \"NODEFS\": NODEFS,\r\n        \"WORKERFS\": WORKERFS\r\n      }\r\n    }),\r\n    init: (function(input, output, error) {\r\n      assert(!FS.init.initialized, \"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)\");\r\n      FS.init.initialized = true;\r\n      FS.ensureErrnoError();\r\n      Module[\"stdin\"] = input || Module[\"stdin\"];\r\n      Module[\"stdout\"] = output || Module[\"stdout\"];\r\n      Module[\"stderr\"] = error || Module[\"stderr\"];\r\n      FS.createStandardStreams()\r\n    }),\r\n    quit: (function() {\r\n      FS.init.initialized = false;\r\n      var fflush = Module[\"_fflush\"];\r\n      if (fflush) fflush(0);\r\n      for (var i = 0; i < FS.streams.length; i++) {\r\n        var stream = FS.streams[i];\r\n        if (!stream) {\r\n          continue\r\n        }\r\n        FS.close(stream)\r\n      }\r\n    }),\r\n    getMode: (function(canRead, canWrite) {\r\n      var mode = 0;\r\n      if (canRead) mode |= 292 | 73;\r\n      if (canWrite) mode |= 146;\r\n      return mode\r\n    }),\r\n    joinPath: (function(parts, forceRelative) {\r\n      var path = PATH.join.apply(null, parts);\r\n      if (forceRelative && path[0] == \"/\") path = path.substr(1);\r\n      return path\r\n    }),\r\n    absolutePath: (function(relative, base) {\r\n      return PATH.resolve(base, relative)\r\n    }),\r\n    standardizePath: (function(path) {\r\n      return PATH.normalize(path)\r\n    }),\r\n    findObject: (function(path, dontResolveLastLink) {\r\n      var ret = FS.analyzePath(path, dontResolveLastLink);\r\n      if (ret.exists) {\r\n        return ret.object\r\n      } else {\r\n        ___setErrNo(ret.error);\r\n        return null\r\n      }\r\n    }),\r\n    analyzePath: (function(path, dontResolveLastLink) {\r\n      try {\r\n        var lookup = FS.lookupPath(path, {\r\n          follow: !dontResolveLastLink\r\n        });\r\n        path = lookup.path\r\n      } catch (e) {}\r\n      var ret = {\r\n        isRoot: false,\r\n        exists: false,\r\n        error: 0,\r\n        name: null,\r\n        path: null,\r\n        object: null,\r\n        parentExists: false,\r\n        parentPath: null,\r\n        parentObject: null\r\n      };\r\n      try {\r\n        var lookup = FS.lookupPath(path, {\r\n          parent: true\r\n        });\r\n        ret.parentExists = true;\r\n        ret.parentPath = lookup.path;\r\n        ret.parentObject = lookup.node;\r\n        ret.name = PATH.basename(path);\r\n        lookup = FS.lookupPath(path, {\r\n          follow: !dontResolveLastLink\r\n        });\r\n        ret.exists = true;\r\n        ret.path = lookup.path;\r\n        ret.object = lookup.node;\r\n        ret.name = lookup.node.name;\r\n        ret.isRoot = lookup.path === \"/\"\r\n      } catch (e) {\r\n        ret.error = e.errno\r\n      }\r\n      return ret\r\n    }),\r\n    createFolder: (function(parent, name, canRead, canWrite) {\r\n      var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\r\n      var mode = FS.getMode(canRead, canWrite);\r\n      return FS.mkdir(path, mode)\r\n    }),\r\n    createPath: (function(parent, path, canRead, canWrite) {\r\n      parent = typeof parent === \"string\" ? parent : FS.getPath(parent);\r\n      var parts = path.split(\"/\").reverse();\r\n      while (parts.length) {\r\n        var part = parts.pop();\r\n        if (!part) continue;\r\n        var current = PATH.join2(parent, part);\r\n        try {\r\n          FS.mkdir(current)\r\n        } catch (e) {}\r\n        parent = current\r\n      }\r\n      return current\r\n    }),\r\n    createFile: (function(parent, name, properties, canRead, canWrite) {\r\n      var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\r\n      var mode = FS.getMode(canRead, canWrite);\r\n      return FS.create(path, mode)\r\n    }),\r\n    createDataFile: (function(parent, name, data, canRead, canWrite, canOwn) {\r\n      var path = name ? PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name) : parent;\r\n      var mode = FS.getMode(canRead, canWrite);\r\n      var node = FS.create(path, mode);\r\n      if (data) {\r\n        if (typeof data === \"string\") {\r\n          var arr = new Array(data.length);\r\n          for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\r\n          data = arr\r\n        }\r\n        FS.chmod(node, mode | 146);\r\n        var stream = FS.open(node, \"w\");\r\n        FS.write(stream, data, 0, data.length, 0, canOwn);\r\n        FS.close(stream);\r\n        FS.chmod(node, mode)\r\n      }\r\n      return node\r\n    }),\r\n    createDevice: (function(parent, name, input, output) {\r\n      var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\r\n      var mode = FS.getMode(!!input, !!output);\r\n      if (!FS.createDevice.major) FS.createDevice.major = 64;\r\n      var dev = FS.makedev(FS.createDevice.major++, 0);\r\n      FS.registerDevice(dev, {\r\n        open: (function(stream) {\r\n          stream.seekable = false\r\n        }),\r\n        close: (function(stream) {\r\n          if (output && output.buffer && output.buffer.length) {\r\n            output(10)\r\n          }\r\n        }),\r\n        read: (function(stream, buffer, offset, length, pos) {\r\n          var bytesRead = 0;\r\n          for (var i = 0; i < length; i++) {\r\n            var result;\r\n            try {\r\n              result = input()\r\n            } catch (e) {\r\n              throw new FS.ErrnoError(ERRNO_CODES.EIO)\r\n            }\r\n            if (result === undefined && bytesRead === 0) {\r\n              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)\r\n            }\r\n            if (result === null || result === undefined) break;\r\n            bytesRead++;\r\n            buffer[offset + i] = result\r\n          }\r\n          if (bytesRead) {\r\n            stream.node.timestamp = Date.now()\r\n          }\r\n          return bytesRead\r\n        }),\r\n        write: (function(stream, buffer, offset, length, pos) {\r\n          for (var i = 0; i < length; i++) {\r\n            try {\r\n              output(buffer[offset + i])\r\n            } catch (e) {\r\n              throw new FS.ErrnoError(ERRNO_CODES.EIO)\r\n            }\r\n          }\r\n          if (length) {\r\n            stream.node.timestamp = Date.now()\r\n          }\r\n          return i\r\n        })\r\n      });\r\n      return FS.mkdev(path, mode, dev)\r\n    }),\r\n    createLink: (function(parent, name, target, canRead, canWrite) {\r\n      var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\r\n      return FS.symlink(target, path)\r\n    }),\r\n    forceLoadFile: (function(obj) {\r\n      if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\r\n      var success = true;\r\n      if (typeof XMLHttpRequest !== \"undefined\") {\r\n        throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\")\r\n      } else if (Module[\"read\"]) {\r\n        try {\r\n          obj.contents = intArrayFromString(Module[\"read\"](obj.url), true);\r\n          obj.usedBytes = obj.contents.length\r\n        } catch (e) {\r\n          success = false\r\n        }\r\n      } else {\r\n        throw new Error(\"Cannot load without read() or XMLHttpRequest.\")\r\n      }\r\n      if (!success) ___setErrNo(ERRNO_CODES.EIO);\r\n      return success\r\n    }),\r\n    createLazyFile: (function(parent, name, url, canRead, canWrite) {\r\n      function LazyUint8Array() {\r\n        this.lengthKnown = false;\r\n        this.chunks = []\r\n      }\r\n      LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\r\n        if (idx > this.length - 1 || idx < 0) {\r\n          return undefined\r\n        }\r\n        var chunkOffset = idx % this.chunkSize;\r\n        var chunkNum = idx / this.chunkSize | 0;\r\n        return this.getter(chunkNum)[chunkOffset]\r\n      };\r\n      LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\r\n        this.getter = getter\r\n      };\r\n      LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\r\n        var xhr = new XMLHttpRequest;\r\n        xhr.open(\"HEAD\", url, false);\r\n        xhr.send(null);\r\n        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n        var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\r\n        var header;\r\n        var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\r\n        var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\r\n        var chunkSize = 1024 * 1024;\r\n        if (!hasByteServing) chunkSize = datalength;\r\n        var doXHR = (function(from, to) {\r\n          if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\r\n          if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\r\n          var xhr = new XMLHttpRequest;\r\n          xhr.open(\"GET\", url, false);\r\n          if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\r\n          if (typeof Uint8Array != \"undefined\") xhr.responseType = \"arraybuffer\";\r\n          if (xhr.overrideMimeType) {\r\n            xhr.overrideMimeType(\"text/plain; charset=x-user-defined\")\r\n          }\r\n          xhr.send(null);\r\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n          if (xhr.response !== undefined) {\r\n            return new Uint8Array(xhr.response || [])\r\n          } else {\r\n            return intArrayFromString(xhr.responseText || \"\", true)\r\n          }\r\n        });\r\n        var lazyArray = this;\r\n        lazyArray.setDataGetter((function(chunkNum) {\r\n          var start = chunkNum * chunkSize;\r\n          var end = (chunkNum + 1) * chunkSize - 1;\r\n          end = Math.min(end, datalength - 1);\r\n          if (typeof lazyArray.chunks[chunkNum] === \"undefined\") {\r\n            lazyArray.chunks[chunkNum] = doXHR(start, end)\r\n          }\r\n          if (typeof lazyArray.chunks[chunkNum] === \"undefined\") throw new Error(\"doXHR failed!\");\r\n          return lazyArray.chunks[chunkNum]\r\n        }));\r\n        if (usesGzip || !datalength) {\r\n          chunkSize = datalength = 1;\r\n          datalength = this.getter(0).length;\r\n          chunkSize = datalength;\r\n          console.log(\"LazyFiles on gzip forces download of the whole file when length is accessed\")\r\n        }\r\n        this._length = datalength;\r\n        this._chunkSize = chunkSize;\r\n        this.lengthKnown = true\r\n      };\r\n      if (typeof XMLHttpRequest !== \"undefined\") {\r\n        if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\r\n        var lazyArray = new LazyUint8Array;\r\n        Object.defineProperties(lazyArray, {\r\n          length: {\r\n            get: (function() {\r\n              if (!this.lengthKnown) {\r\n                this.cacheLength()\r\n              }\r\n              return this._length\r\n            })\r\n          },\r\n          chunkSize: {\r\n            get: (function() {\r\n              if (!this.lengthKnown) {\r\n                this.cacheLength()\r\n              }\r\n              return this._chunkSize\r\n            })\r\n          }\r\n        });\r\n        var properties = {\r\n          isDevice: false,\r\n          contents: lazyArray\r\n        }\r\n      } else {\r\n        var properties = {\r\n          isDevice: false,\r\n          url: url\r\n        }\r\n      }\r\n      var node = FS.createFile(parent, name, properties, canRead, canWrite);\r\n      if (properties.contents) {\r\n        node.contents = properties.contents\r\n      } else if (properties.url) {\r\n        node.contents = null;\r\n        node.url = properties.url\r\n      }\r\n      Object.defineProperties(node, {\r\n        usedBytes: {\r\n          get: (function() {\r\n            return this.contents.length\r\n          })\r\n        }\r\n      });\r\n      var stream_ops = {};\r\n      var keys = Object.keys(node.stream_ops);\r\n      keys.forEach((function(key) {\r\n        var fn = node.stream_ops[key];\r\n        stream_ops[key] = function forceLoadLazyFile() {\r\n          if (!FS.forceLoadFile(node)) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.EIO)\r\n          }\r\n          return fn.apply(null, arguments)\r\n        }\r\n      }));\r\n      stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {\r\n        if (!FS.forceLoadFile(node)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EIO)\r\n        }\r\n        var contents = stream.node.contents;\r\n        if (position >= contents.length) return 0;\r\n        var size = Math.min(contents.length - position, length);\r\n        assert(size >= 0);\r\n        if (contents.slice) {\r\n          for (var i = 0; i < size; i++) {\r\n            buffer[offset + i] = contents[position + i]\r\n          }\r\n        } else {\r\n          for (var i = 0; i < size; i++) {\r\n            buffer[offset + i] = contents.get(position + i)\r\n          }\r\n        }\r\n        return size\r\n      };\r\n      node.stream_ops = stream_ops;\r\n      return node\r\n    }),\r\n    createPreloadedFile: (function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\r\n      Browser.init();\r\n      var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;\r\n      var dep = getUniqueRunDependency(\"cp \" + fullname);\r\n\r\n      function processData(byteArray) {\r\n        function finish(byteArray) {\r\n          if (preFinish) preFinish();\r\n          if (!dontCreateFile) {\r\n            FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn)\r\n          }\r\n          if (onload) onload();\r\n          removeRunDependency(dep)\r\n        }\r\n        var handled = false;\r\n        Module[\"preloadPlugins\"].forEach((function(plugin) {\r\n          if (handled) return;\r\n          if (plugin[\"canHandle\"](fullname)) {\r\n            plugin[\"handle\"](byteArray, fullname, finish, (function() {\r\n              if (onerror) onerror();\r\n              removeRunDependency(dep)\r\n            }));\r\n            handled = true\r\n          }\r\n        }));\r\n        if (!handled) finish(byteArray)\r\n      }\r\n      addRunDependency(dep);\r\n      if (typeof url == \"string\") {\r\n        Browser.asyncLoad(url, (function(byteArray) {\r\n          processData(byteArray)\r\n        }), onerror)\r\n      } else {\r\n        processData(url)\r\n      }\r\n    }),\r\n    indexedDB: (function() {\r\n      return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB\r\n    }),\r\n    DB_NAME: (function() {\r\n      return \"EM_FS_\" + window.location.pathname\r\n    }),\r\n    DB_VERSION: 20,\r\n    DB_STORE_NAME: \"FILE_DATA\",\r\n    saveFilesToDB: (function(paths, onload, onerror) {\r\n      onload = onload || (function() {});\r\n      onerror = onerror || (function() {});\r\n      var indexedDB = FS.indexedDB();\r\n      try {\r\n        var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION)\r\n      } catch (e) {\r\n        return onerror(e)\r\n      }\r\n      openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\r\n        console.log(\"creating db\");\r\n        var db = openRequest.result;\r\n        db.createObjectStore(FS.DB_STORE_NAME)\r\n      };\r\n      openRequest.onsuccess = function openRequest_onsuccess() {\r\n        var db = openRequest.result;\r\n        var transaction = db.transaction([FS.DB_STORE_NAME], \"readwrite\");\r\n        var files = transaction.objectStore(FS.DB_STORE_NAME);\r\n        var ok = 0,\r\n          fail = 0,\r\n          total = paths.length;\r\n\r\n        function finish() {\r\n          if (fail == 0) onload();\r\n          else onerror()\r\n        }\r\n        paths.forEach((function(path) {\r\n          var putRequest = files.put(FS.analyzePath(path).object.contents, path);\r\n          putRequest.onsuccess = function putRequest_onsuccess() {\r\n            ok++;\r\n            if (ok + fail == total) finish()\r\n          };\r\n          putRequest.onerror = function putRequest_onerror() {\r\n            fail++;\r\n            if (ok + fail == total) finish()\r\n          }\r\n        }));\r\n        transaction.onerror = onerror\r\n      };\r\n      openRequest.onerror = onerror\r\n    }),\r\n    loadFilesFromDB: (function(paths, onload, onerror) {\r\n      onload = onload || (function() {});\r\n      onerror = onerror || (function() {});\r\n      var indexedDB = FS.indexedDB();\r\n      try {\r\n        var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION)\r\n      } catch (e) {\r\n        return onerror(e)\r\n      }\r\n      openRequest.onupgradeneeded = onerror;\r\n      openRequest.onsuccess = function openRequest_onsuccess() {\r\n        var db = openRequest.result;\r\n        try {\r\n          var transaction = db.transaction([FS.DB_STORE_NAME], \"readonly\")\r\n        } catch (e) {\r\n          onerror(e);\r\n          return\r\n        }\r\n        var files = transaction.objectStore(FS.DB_STORE_NAME);\r\n        var ok = 0,\r\n          fail = 0,\r\n          total = paths.length;\r\n\r\n        function finish() {\r\n          if (fail == 0) onload();\r\n          else onerror()\r\n        }\r\n        paths.forEach((function(path) {\r\n          var getRequest = files.get(path);\r\n          getRequest.onsuccess = function getRequest_onsuccess() {\r\n            if (FS.analyzePath(path).exists) {\r\n              FS.unlink(path)\r\n            }\r\n            FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\r\n            ok++;\r\n            if (ok + fail == total) finish()\r\n          };\r\n          getRequest.onerror = function getRequest_onerror() {\r\n            fail++;\r\n            if (ok + fail == total) finish()\r\n          }\r\n        }));\r\n        transaction.onerror = onerror\r\n      };\r\n      openRequest.onerror = onerror\r\n    })\r\n  };\r\n  var SYSCALLS = {\r\n    DEFAULT_POLLMASK: 5,\r\n    mappings: {},\r\n    umask: 511,\r\n    calculateAt: (function(dirfd, path) {\r\n      if (path[0] !== \"/\") {\r\n        var dir;\r\n        if (dirfd === -100) {\r\n          dir = FS.cwd()\r\n        } else {\r\n          var dirstream = FS.getStream(dirfd);\r\n          if (!dirstream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n          dir = dirstream.path\r\n        }\r\n        path = PATH.join2(dir, path)\r\n      }\r\n      return path\r\n    }),\r\n    doStat: (function(func, path, buf) {\r\n      try {\r\n        var stat = func(path)\r\n      } catch (e) {\r\n        if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\r\n          return -ERRNO_CODES.ENOTDIR\r\n        }\r\n        throw e\r\n      }\r\n      HEAP32[buf >> 2] = stat.dev;\r\n      HEAP32[buf + 4 >> 2] = 0;\r\n      HEAP32[buf + 8 >> 2] = stat.ino;\r\n      HEAP32[buf + 12 >> 2] = stat.mode;\r\n      HEAP32[buf + 16 >> 2] = stat.nlink;\r\n      HEAP32[buf + 20 >> 2] = stat.uid;\r\n      HEAP32[buf + 24 >> 2] = stat.gid;\r\n      HEAP32[buf + 28 >> 2] = stat.rdev;\r\n      HEAP32[buf + 32 >> 2] = 0;\r\n      HEAP32[buf + 36 >> 2] = stat.size;\r\n      HEAP32[buf + 40 >> 2] = 4096;\r\n      HEAP32[buf + 44 >> 2] = stat.blocks;\r\n      HEAP32[buf + 48 >> 2] = stat.atime.getTime() / 1e3 | 0;\r\n      HEAP32[buf + 52 >> 2] = 0;\r\n      HEAP32[buf + 56 >> 2] = stat.mtime.getTime() / 1e3 | 0;\r\n      HEAP32[buf + 60 >> 2] = 0;\r\n      HEAP32[buf + 64 >> 2] = stat.ctime.getTime() / 1e3 | 0;\r\n      HEAP32[buf + 68 >> 2] = 0;\r\n      HEAP32[buf + 72 >> 2] = stat.ino;\r\n      return 0\r\n    }),\r\n    doMsync: (function(addr, stream, len, flags) {\r\n      var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));\r\n      FS.msync(stream, buffer, 0, len, flags)\r\n    }),\r\n    doMkdir: (function(path, mode) {\r\n      path = PATH.normalize(path);\r\n      if (path[path.length - 1] === \"/\") path = path.substr(0, path.length - 1);\r\n      FS.mkdir(path, mode, 0);\r\n      return 0\r\n    }),\r\n    doMknod: (function(path, mode, dev) {\r\n      switch (mode & 61440) {\r\n        case 32768:\r\n        case 8192:\r\n        case 24576:\r\n        case 4096:\r\n        case 49152:\r\n          break;\r\n        default:\r\n          return -ERRNO_CODES.EINVAL\r\n      }\r\n      FS.mknod(path, mode, dev);\r\n      return 0\r\n    }),\r\n    doReadlink: (function(path, buf, bufsize) {\r\n      if (bufsize <= 0) return -ERRNO_CODES.EINVAL;\r\n      var ret = FS.readlink(path);\r\n      var len = Math.min(bufsize, lengthBytesUTF8(ret));\r\n      var endChar = HEAP8[buf + len];\r\n      stringToUTF8(ret, buf, bufsize + 1);\r\n      HEAP8[buf + len] = endChar;\r\n      return len\r\n    }),\r\n    doAccess: (function(path, amode) {\r\n      if (amode & ~7) {\r\n        return -ERRNO_CODES.EINVAL\r\n      }\r\n      var node;\r\n      var lookup = FS.lookupPath(path, {\r\n        follow: true\r\n      });\r\n      node = lookup.node;\r\n      var perms = \"\";\r\n      if (amode & 4) perms += \"r\";\r\n      if (amode & 2) perms += \"w\";\r\n      if (amode & 1) perms += \"x\";\r\n      if (perms && FS.nodePermissions(node, perms)) {\r\n        return -ERRNO_CODES.EACCES\r\n      }\r\n      return 0\r\n    }),\r\n    doDup: (function(path, flags, suggestFD) {\r\n      var suggest = FS.getStream(suggestFD);\r\n      if (suggest) FS.close(suggest);\r\n      return FS.open(path, flags, 0, suggestFD, suggestFD).fd\r\n    }),\r\n    doReadv: (function(stream, iov, iovcnt, offset) {\r\n      var ret = 0;\r\n      for (var i = 0; i < iovcnt; i++) {\r\n        var ptr = HEAP32[iov + i * 8 >> 2];\r\n        var len = HEAP32[iov + (i * 8 + 4) >> 2];\r\n        var curr = FS.read(stream, HEAP8, ptr, len, offset);\r\n        if (curr < 0) return -1;\r\n        ret += curr;\r\n        if (curr < len) break\r\n      }\r\n      return ret\r\n    }),\r\n    doWritev: (function(stream, iov, iovcnt, offset) {\r\n      var ret = 0;\r\n      for (var i = 0; i < iovcnt; i++) {\r\n        var ptr = HEAP32[iov + i * 8 >> 2];\r\n        var len = HEAP32[iov + (i * 8 + 4) >> 2];\r\n        var curr = FS.write(stream, HEAP8, ptr, len, offset);\r\n        if (curr < 0) return -1;\r\n        ret += curr\r\n      }\r\n      return ret\r\n    }),\r\n    varargs: 0,\r\n    get: (function(varargs) {\r\n      SYSCALLS.varargs += 4;\r\n      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\r\n      return ret\r\n    }),\r\n    getStr: (function() {\r\n      var ret = Pointer_stringify(SYSCALLS.get());\r\n      return ret\r\n    }),\r\n    getStreamFromFD: (function() {\r\n      var stream = FS.getStream(SYSCALLS.get());\r\n      if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n      return stream\r\n    }),\r\n    getSocketFromFD: (function() {\r\n      var socket = SOCKFS.getSocket(SYSCALLS.get());\r\n      if (!socket) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n      return socket\r\n    }),\r\n    getSocketAddress: (function(allowNull) {\r\n      var addrp = SYSCALLS.get(),\r\n        addrlen = SYSCALLS.get();\r\n      if (allowNull && addrp === 0) return null;\r\n      var info = __read_sockaddr(addrp, addrlen);\r\n      if (info.errno) throw new FS.ErrnoError(info.errno);\r\n      info.addr = DNS.lookup_addr(info.addr) || info.addr;\r\n      return info\r\n    }),\r\n    get64: (function() {\r\n      var low = SYSCALLS.get(),\r\n        high = SYSCALLS.get();\r\n      if (low >= 0) assert(high === 0);\r\n      else assert(high === -1);\r\n      return low\r\n    }),\r\n    getZero: (function() {\r\n      assert(SYSCALLS.get() === 0)\r\n    })\r\n  };\r\n\r\n  function ___syscall10(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var path = SYSCALLS.getStr();\r\n      FS.unlink(path);\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n  var SOCKFS = {\r\n    mount: (function(mount) {\r\n      Module[\"websocket\"] = Module[\"websocket\"] && \"object\" === typeof Module[\"websocket\"] ? Module[\"websocket\"] : {};\r\n      Module[\"websocket\"]._callbacks = {};\r\n      Module[\"websocket\"][\"on\"] = (function(event, callback) {\r\n        if (\"function\" === typeof callback) {\r\n          this._callbacks[event] = callback\r\n        }\r\n        return this\r\n      });\r\n      Module[\"websocket\"].emit = (function(event, param) {\r\n        if (\"function\" === typeof this._callbacks[event]) {\r\n          this._callbacks[event].call(this, param)\r\n        }\r\n      });\r\n      return FS.createNode(null, \"/\", 16384 | 511, 0)\r\n    }),\r\n    createSocket: (function(family, type, protocol) {\r\n      var streaming = type == 1;\r\n      if (protocol) {\r\n        assert(streaming == (protocol == 6))\r\n      }\r\n      var sock = {\r\n        family: family,\r\n        type: type,\r\n        protocol: protocol,\r\n        server: null,\r\n        error: null,\r\n        peers: {},\r\n        pending: [],\r\n        recv_queue: [],\r\n        sock_ops: SOCKFS.websocket_sock_ops\r\n      };\r\n      var name = SOCKFS.nextname();\r\n      var node = FS.createNode(SOCKFS.root, name, 49152, 0);\r\n      node.sock = sock;\r\n      var stream = FS.createStream({\r\n        path: name,\r\n        node: node,\r\n        flags: FS.modeStringToFlags(\"r+\"),\r\n        seekable: false,\r\n        stream_ops: SOCKFS.stream_ops\r\n      });\r\n      sock.stream = stream;\r\n      return sock\r\n    }),\r\n    getSocket: (function(fd) {\r\n      var stream = FS.getStream(fd);\r\n      if (!stream || !FS.isSocket(stream.node.mode)) {\r\n        return null\r\n      }\r\n      return stream.node.sock\r\n    }),\r\n    stream_ops: {\r\n      poll: (function(stream) {\r\n        var sock = stream.node.sock;\r\n        return sock.sock_ops.poll(sock)\r\n      }),\r\n      ioctl: (function(stream, request, varargs) {\r\n        var sock = stream.node.sock;\r\n        return sock.sock_ops.ioctl(sock, request, varargs)\r\n      }),\r\n      read: (function(stream, buffer, offset, length, position) {\r\n        var sock = stream.node.sock;\r\n        var msg = sock.sock_ops.recvmsg(sock, length);\r\n        if (!msg) {\r\n          return 0\r\n        }\r\n        buffer.set(msg.buffer, offset);\r\n        return msg.buffer.length\r\n      }),\r\n      write: (function(stream, buffer, offset, length, position) {\r\n        var sock = stream.node.sock;\r\n        return sock.sock_ops.sendmsg(sock, buffer, offset, length)\r\n      }),\r\n      close: (function(stream) {\r\n        var sock = stream.node.sock;\r\n        sock.sock_ops.close(sock)\r\n      })\r\n    },\r\n    nextname: (function() {\r\n      if (!SOCKFS.nextname.current) {\r\n        SOCKFS.nextname.current = 0\r\n      }\r\n      return \"socket[\" + SOCKFS.nextname.current++ + \"]\"\r\n    }),\r\n    websocket_sock_ops: {\r\n      createPeer: (function(sock, addr, port) {\r\n        var ws;\r\n        if (typeof addr === \"object\") {\r\n          ws = addr;\r\n          addr = null;\r\n          port = null\r\n        }\r\n        if (ws) {\r\n          if (ws._socket) {\r\n            addr = ws._socket.remoteAddress;\r\n            port = ws._socket.remotePort\r\n          } else {\r\n            var result = /ws[s]?:\\/\\/([^:]+):(\\d+)/.exec(ws.url);\r\n            if (!result) {\r\n              throw new Error(\"WebSocket URL must be in the format ws(s)://address:port\")\r\n            }\r\n            addr = result[1];\r\n            port = parseInt(result[2], 10)\r\n          }\r\n        } else {\r\n          try {\r\n            var runtimeConfig = Module[\"websocket\"] && \"object\" === typeof Module[\"websocket\"];\r\n            var url = \"ws:#\".replace(\"#\", \"//\");\r\n            if (runtimeConfig) {\r\n              if (\"string\" === typeof Module[\"websocket\"][\"url\"]) {\r\n                url = Module[\"websocket\"][\"url\"]\r\n              }\r\n            }\r\n            if (url === \"ws://\" || url === \"wss://\") {\r\n              var parts = addr.split(\"/\");\r\n              url = url + parts[0] + \":\" + port + \"/\" + parts.slice(1).join(\"/\")\r\n            }\r\n            var subProtocols = \"binary\";\r\n            if (runtimeConfig) {\r\n              if (\"string\" === typeof Module[\"websocket\"][\"subprotocol\"]) {\r\n                subProtocols = Module[\"websocket\"][\"subprotocol\"]\r\n              }\r\n            }\r\n            subProtocols = subProtocols.replace(/^ +| +$/g, \"\").split(/ *, */);\r\n            var opts = ENVIRONMENT_IS_NODE ? {\r\n              \"protocol\": subProtocols.toString()\r\n            } : subProtocols;\r\n            if (runtimeConfig && null === Module[\"websocket\"][\"subprotocol\"]) {\r\n              subProtocols = \"null\";\r\n              opts = undefined\r\n            }\r\n            var WebSocketConstructor;\r\n            if (ENVIRONMENT_IS_NODE) {\r\n              WebSocketConstructor = __webpack_require__(/*! ws */ \"./node_modules/ws/index.js\")\r\n            } else if (ENVIRONMENT_IS_WEB) {\r\n              WebSocketConstructor = window[\"WebSocket\"]\r\n            } else {\r\n              WebSocketConstructor = WebSocket\r\n            }\r\n            ws = new WebSocketConstructor(url, opts);\r\n            ws.binaryType = \"arraybuffer\"\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.EHOSTUNREACH)\r\n          }\r\n        }\r\n        var peer = {\r\n          addr: addr,\r\n          port: port,\r\n          socket: ws,\r\n          dgram_send_queue: []\r\n        };\r\n        SOCKFS.websocket_sock_ops.addPeer(sock, peer);\r\n        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);\r\n        if (sock.type === 2 && typeof sock.sport !== \"undefined\") {\r\n          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, \"p\".charCodeAt(0), \"o\".charCodeAt(0), \"r\".charCodeAt(0), \"t\".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]))\r\n        }\r\n        return peer\r\n      }),\r\n      getPeer: (function(sock, addr, port) {\r\n        return sock.peers[addr + \":\" + port]\r\n      }),\r\n      addPeer: (function(sock, peer) {\r\n        sock.peers[peer.addr + \":\" + peer.port] = peer\r\n      }),\r\n      removePeer: (function(sock, peer) {\r\n        delete sock.peers[peer.addr + \":\" + peer.port]\r\n      }),\r\n      handlePeerEvents: (function(sock, peer) {\r\n        var first = true;\r\n        var handleOpen = (function() {\r\n          Module[\"websocket\"].emit(\"open\", sock.stream.fd);\r\n          try {\r\n            var queued = peer.dgram_send_queue.shift();\r\n            while (queued) {\r\n              peer.socket.send(queued);\r\n              queued = peer.dgram_send_queue.shift()\r\n            }\r\n          } catch (e) {\r\n            peer.socket.close()\r\n          }\r\n        });\r\n\r\n        function handleMessage(data) {\r\n          assert(typeof data !== \"string\" && data.byteLength !== undefined);\r\n          if (data.byteLength == 0) {\r\n            return\r\n          }\r\n          data = new Uint8Array(data);\r\n          var wasfirst = first;\r\n          first = false;\r\n          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === \"p\".charCodeAt(0) && data[5] === \"o\".charCodeAt(0) && data[6] === \"r\".charCodeAt(0) && data[7] === \"t\".charCodeAt(0)) {\r\n            var newport = data[8] << 8 | data[9];\r\n            SOCKFS.websocket_sock_ops.removePeer(sock, peer);\r\n            peer.port = newport;\r\n            SOCKFS.websocket_sock_ops.addPeer(sock, peer);\r\n            return\r\n          }\r\n          sock.recv_queue.push({\r\n            addr: peer.addr,\r\n            port: peer.port,\r\n            data: data\r\n          });\r\n          Module[\"websocket\"].emit(\"message\", sock.stream.fd)\r\n        }\r\n        if (ENVIRONMENT_IS_NODE) {\r\n          peer.socket.on(\"open\", handleOpen);\r\n          peer.socket.on(\"message\", (function(data, flags) {\r\n            if (!flags.binary) {\r\n              return\r\n            }\r\n            handleMessage((new Uint8Array(data)).buffer)\r\n          }));\r\n          peer.socket.on(\"close\", (function() {\r\n            Module[\"websocket\"].emit(\"close\", sock.stream.fd)\r\n          }));\r\n          peer.socket.on(\"error\", (function(error) {\r\n            sock.error = ERRNO_CODES.ECONNREFUSED;\r\n            Module[\"websocket\"].emit(\"error\", [sock.stream.fd, sock.error, \"ECONNREFUSED: Connection refused\"])\r\n          }))\r\n        } else {\r\n          peer.socket.onopen = handleOpen;\r\n          peer.socket.onclose = (function() {\r\n            Module[\"websocket\"].emit(\"close\", sock.stream.fd)\r\n          });\r\n          peer.socket.onmessage = function peer_socket_onmessage(event) {\r\n            handleMessage(event.data)\r\n          };\r\n          peer.socket.onerror = (function(error) {\r\n            sock.error = ERRNO_CODES.ECONNREFUSED;\r\n            Module[\"websocket\"].emit(\"error\", [sock.stream.fd, sock.error, \"ECONNREFUSED: Connection refused\"])\r\n          })\r\n        }\r\n      }),\r\n      poll: (function(sock) {\r\n        if (sock.type === 1 && sock.server) {\r\n          return sock.pending.length ? 64 | 1 : 0\r\n        }\r\n        var mask = 0;\r\n        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;\r\n        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {\r\n          mask |= 64 | 1\r\n        }\r\n        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {\r\n          mask |= 4\r\n        }\r\n        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {\r\n          mask |= 16\r\n        }\r\n        return mask\r\n      }),\r\n      ioctl: (function(sock, request, arg) {\r\n        switch (request) {\r\n          case 21531:\r\n            var bytes = 0;\r\n            if (sock.recv_queue.length) {\r\n              bytes = sock.recv_queue[0].data.length\r\n            }\r\n            HEAP32[arg >> 2] = bytes;\r\n            return 0;\r\n          default:\r\n            return ERRNO_CODES.EINVAL\r\n        }\r\n      }),\r\n      close: (function(sock) {\r\n        if (sock.server) {\r\n          try {\r\n            sock.server.close()\r\n          } catch (e) {}\r\n          sock.server = null\r\n        }\r\n        var peers = Object.keys(sock.peers);\r\n        for (var i = 0; i < peers.length; i++) {\r\n          var peer = sock.peers[peers[i]];\r\n          try {\r\n            peer.socket.close()\r\n          } catch (e) {}\r\n          SOCKFS.websocket_sock_ops.removePeer(sock, peer)\r\n        }\r\n        return 0\r\n      }),\r\n      bind: (function(sock, addr, port) {\r\n        if (typeof sock.saddr !== \"undefined\" || typeof sock.sport !== \"undefined\") {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n        }\r\n        sock.saddr = addr;\r\n        sock.sport = port;\r\n        if (sock.type === 2) {\r\n          if (sock.server) {\r\n            sock.server.close();\r\n            sock.server = null\r\n          }\r\n          try {\r\n            sock.sock_ops.listen(sock, 0)\r\n          } catch (e) {\r\n            if (!(e instanceof FS.ErrnoError)) throw e;\r\n            if (e.errno !== ERRNO_CODES.EOPNOTSUPP) throw e\r\n          }\r\n        }\r\n      }),\r\n      connect: (function(sock, addr, port) {\r\n        if (sock.server) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP)\r\n        }\r\n        if (typeof sock.daddr !== \"undefined\" && typeof sock.dport !== \"undefined\") {\r\n          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);\r\n          if (dest) {\r\n            if (dest.socket.readyState === dest.socket.CONNECTING) {\r\n              throw new FS.ErrnoError(ERRNO_CODES.EALREADY)\r\n            } else {\r\n              throw new FS.ErrnoError(ERRNO_CODES.EISCONN)\r\n            }\r\n          }\r\n        }\r\n        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);\r\n        sock.daddr = peer.addr;\r\n        sock.dport = peer.port;\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINPROGRESS)\r\n      }),\r\n      listen: (function(sock, backlog) {\r\n        if (!ENVIRONMENT_IS_NODE) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP)\r\n        }\r\n        if (sock.server) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n        }\r\n        var WebSocketServer = __webpack_require__(/*! ws */ \"./node_modules/ws/index.js\").Server;\r\n        var host = sock.saddr;\r\n        sock.server = new WebSocketServer({\r\n          host: host,\r\n          port: sock.sport\r\n        });\r\n        Module[\"websocket\"].emit(\"listen\", sock.stream.fd);\r\n        sock.server.on(\"connection\", (function(ws) {\r\n          if (sock.type === 1) {\r\n            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);\r\n            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);\r\n            newsock.daddr = peer.addr;\r\n            newsock.dport = peer.port;\r\n            sock.pending.push(newsock);\r\n            Module[\"websocket\"].emit(\"connection\", newsock.stream.fd)\r\n          } else {\r\n            SOCKFS.websocket_sock_ops.createPeer(sock, ws);\r\n            Module[\"websocket\"].emit(\"connection\", sock.stream.fd)\r\n          }\r\n        }));\r\n        sock.server.on(\"closed\", (function() {\r\n          Module[\"websocket\"].emit(\"close\", sock.stream.fd);\r\n          sock.server = null\r\n        }));\r\n        sock.server.on(\"error\", (function(error) {\r\n          sock.error = ERRNO_CODES.EHOSTUNREACH;\r\n          Module[\"websocket\"].emit(\"error\", [sock.stream.fd, sock.error, \"EHOSTUNREACH: Host is unreachable\"])\r\n        }))\r\n      }),\r\n      accept: (function(listensock) {\r\n        if (!listensock.server) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n        }\r\n        var newsock = listensock.pending.shift();\r\n        newsock.stream.flags = listensock.stream.flags;\r\n        return newsock\r\n      }),\r\n      getname: (function(sock, peer) {\r\n        var addr, port;\r\n        if (peer) {\r\n          if (sock.daddr === undefined || sock.dport === undefined) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN)\r\n          }\r\n          addr = sock.daddr;\r\n          port = sock.dport\r\n        } else {\r\n          addr = sock.saddr || 0;\r\n          port = sock.sport || 0\r\n        }\r\n        return {\r\n          addr: addr,\r\n          port: port\r\n        }\r\n      }),\r\n      sendmsg: (function(sock, buffer, offset, length, addr, port) {\r\n        if (sock.type === 2) {\r\n          if (addr === undefined || port === undefined) {\r\n            addr = sock.daddr;\r\n            port = sock.dport\r\n          }\r\n          if (addr === undefined || port === undefined) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.EDESTADDRREQ)\r\n          }\r\n        } else {\r\n          addr = sock.daddr;\r\n          port = sock.dport\r\n        }\r\n        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);\r\n        if (sock.type === 1) {\r\n          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN)\r\n          } else if (dest.socket.readyState === dest.socket.CONNECTING) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)\r\n          }\r\n        }\r\n        if (ArrayBuffer.isView(buffer)) {\r\n          offset += buffer.byteOffset;\r\n          buffer = buffer.buffer\r\n        }\r\n        var data;\r\n        data = buffer.slice(offset, offset + length);\r\n        if (sock.type === 2) {\r\n          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {\r\n            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {\r\n              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port)\r\n            }\r\n            dest.dgram_send_queue.push(data);\r\n            return length\r\n          }\r\n        }\r\n        try {\r\n          dest.socket.send(data);\r\n          return length\r\n        } catch (e) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\r\n        }\r\n      }),\r\n      recvmsg: (function(sock, length) {\r\n        if (sock.type === 1 && sock.server) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN)\r\n        }\r\n        var queued = sock.recv_queue.shift();\r\n        if (!queued) {\r\n          if (sock.type === 1) {\r\n            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);\r\n            if (!dest) {\r\n              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN)\r\n            } else if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {\r\n              return null\r\n            } else {\r\n              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)\r\n            }\r\n          } else {\r\n            throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)\r\n          }\r\n        }\r\n        var queuedLength = queued.data.byteLength || queued.data.length;\r\n        var queuedOffset = queued.data.byteOffset || 0;\r\n        var queuedBuffer = queued.data.buffer || queued.data;\r\n        var bytesRead = Math.min(length, queuedLength);\r\n        var res = {\r\n          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),\r\n          addr: queued.addr,\r\n          port: queued.port\r\n        };\r\n        if (sock.type === 1 && bytesRead < queuedLength) {\r\n          var bytesRemaining = queuedLength - bytesRead;\r\n          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);\r\n          sock.recv_queue.unshift(queued)\r\n        }\r\n        return res\r\n      })\r\n    }\r\n  };\r\n\r\n  function __inet_pton4_raw(str) {\r\n    var b = str.split(\".\");\r\n    for (var i = 0; i < 4; i++) {\r\n      var tmp = Number(b[i]);\r\n      if (isNaN(tmp)) return null;\r\n      b[i] = tmp\r\n    }\r\n    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0\r\n  }\r\n\r\n  function __inet_pton6_raw(str) {\r\n    var words;\r\n    var w, offset, z;\r\n    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\\dA-F]{1,4}:(:|\\b)|){5}|([\\dA-F]{1,4}:){6})((([\\dA-F]{1,4}((?!\\3)::|:\\b|$))|(?!\\2\\3)){2}|(((2[0-4]|1\\d|[1-9])?\\d|25[0-5])\\.?\\b){4})$/i;\r\n    var parts = [];\r\n    if (!valid6regx.test(str)) {\r\n      return null\r\n    }\r\n    if (str === \"::\") {\r\n      return [0, 0, 0, 0, 0, 0, 0, 0]\r\n    }\r\n    if (str.indexOf(\"::\") === 0) {\r\n      str = str.replace(\"::\", \"Z:\")\r\n    } else {\r\n      str = str.replace(\"::\", \":Z:\")\r\n    }\r\n    if (str.indexOf(\".\") > 0) {\r\n      str = str.replace(new RegExp(\"[.]\", \"g\"), \":\");\r\n      words = str.split(\":\");\r\n      words[words.length - 4] = parseInt(words[words.length - 4]) + parseInt(words[words.length - 3]) * 256;\r\n      words[words.length - 3] = parseInt(words[words.length - 2]) + parseInt(words[words.length - 1]) * 256;\r\n      words = words.slice(0, words.length - 2)\r\n    } else {\r\n      words = str.split(\":\")\r\n    }\r\n    offset = 0;\r\n    z = 0;\r\n    for (w = 0; w < words.length; w++) {\r\n      if (typeof words[w] === \"string\") {\r\n        if (words[w] === \"Z\") {\r\n          for (z = 0; z < 8 - words.length + 1; z++) {\r\n            parts[w + z] = 0\r\n          }\r\n          offset = z - 1\r\n        } else {\r\n          parts[w + offset] = _htons(parseInt(words[w], 16))\r\n        }\r\n      } else {\r\n        parts[w + offset] = words[w]\r\n      }\r\n    }\r\n    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]]\r\n  }\r\n  var DNS = {\r\n    address_map: {\r\n      id: 1,\r\n      addrs: {},\r\n      names: {}\r\n    },\r\n    lookup_name: (function(name) {\r\n      var res = __inet_pton4_raw(name);\r\n      if (res !== null) {\r\n        return name\r\n      }\r\n      res = __inet_pton6_raw(name);\r\n      if (res !== null) {\r\n        return name\r\n      }\r\n      var addr;\r\n      if (DNS.address_map.addrs[name]) {\r\n        addr = DNS.address_map.addrs[name]\r\n      } else {\r\n        var id = DNS.address_map.id++;\r\n        assert(id < 65535, \"exceeded max address mappings of 65535\");\r\n        addr = \"172.29.\" + (id & 255) + \".\" + (id & 65280);\r\n        DNS.address_map.names[addr] = name;\r\n        DNS.address_map.addrs[name] = addr\r\n      }\r\n      return addr\r\n    }),\r\n    lookup_addr: (function(addr) {\r\n      if (DNS.address_map.names[addr]) {\r\n        return DNS.address_map.names[addr]\r\n      }\r\n      return null\r\n    })\r\n  };\r\n\r\n  function __inet_ntop4_raw(addr) {\r\n    return (addr & 255) + \".\" + (addr >> 8 & 255) + \".\" + (addr >> 16 & 255) + \".\" + (addr >> 24 & 255)\r\n  }\r\n\r\n  function __inet_ntop6_raw(ints) {\r\n    var str = \"\";\r\n    var word = 0;\r\n    var longest = 0;\r\n    var lastzero = 0;\r\n    var zstart = 0;\r\n    var len = 0;\r\n    var i = 0;\r\n    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];\r\n    var hasipv4 = true;\r\n    var v4part = \"\";\r\n    for (i = 0; i < 5; i++) {\r\n      if (parts[i] !== 0) {\r\n        hasipv4 = false;\r\n        break\r\n      }\r\n    }\r\n    if (hasipv4) {\r\n      v4part = __inet_ntop4_raw(parts[6] | parts[7] << 16);\r\n      if (parts[5] === -1) {\r\n        str = \"::ffff:\";\r\n        str += v4part;\r\n        return str\r\n      }\r\n      if (parts[5] === 0) {\r\n        str = \"::\";\r\n        if (v4part === \"0.0.0.0\") v4part = \"\";\r\n        if (v4part === \"0.0.0.1\") v4part = \"1\";\r\n        str += v4part;\r\n        return str\r\n      }\r\n    }\r\n    for (word = 0; word < 8; word++) {\r\n      if (parts[word] === 0) {\r\n        if (word - lastzero > 1) {\r\n          len = 0\r\n        }\r\n        lastzero = word;\r\n        len++\r\n      }\r\n      if (len > longest) {\r\n        longest = len;\r\n        zstart = word - longest + 1\r\n      }\r\n    }\r\n    for (word = 0; word < 8; word++) {\r\n      if (longest > 1) {\r\n        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {\r\n          if (word === zstart) {\r\n            str += \":\";\r\n            if (zstart === 0) str += \":\"\r\n          }\r\n          continue\r\n        }\r\n      }\r\n      str += Number(_ntohs(parts[word] & 65535)).toString(16);\r\n      str += word < 7 ? \":\" : \"\"\r\n    }\r\n    return str\r\n  }\r\n\r\n  function __read_sockaddr(sa, salen) {\r\n    var family = HEAP16[sa >> 1];\r\n    var port = _ntohs(HEAP16[sa + 2 >> 1]);\r\n    var addr;\r\n    switch (family) {\r\n      case 2:\r\n        if (salen !== 16) {\r\n          return {\r\n            errno: ERRNO_CODES.EINVAL\r\n          }\r\n        }\r\n        addr = HEAP32[sa + 4 >> 2];\r\n        addr = __inet_ntop4_raw(addr);\r\n        break;\r\n      case 10:\r\n        if (salen !== 28) {\r\n          return {\r\n            errno: ERRNO_CODES.EINVAL\r\n          }\r\n        }\r\n        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];\r\n        addr = __inet_ntop6_raw(addr);\r\n        break;\r\n      default:\r\n        return {\r\n          errno: ERRNO_CODES.EAFNOSUPPORT\r\n        }\r\n    }\r\n    return {\r\n      family: family,\r\n      addr: addr,\r\n      port: port\r\n    }\r\n  }\r\n\r\n  function __write_sockaddr(sa, family, addr, port) {\r\n    switch (family) {\r\n      case 2:\r\n        addr = __inet_pton4_raw(addr);\r\n        HEAP16[sa >> 1] = family;\r\n        HEAP32[sa + 4 >> 2] = addr;\r\n        HEAP16[sa + 2 >> 1] = _htons(port);\r\n        break;\r\n      case 10:\r\n        addr = __inet_pton6_raw(addr);\r\n        HEAP32[sa >> 2] = family;\r\n        HEAP32[sa + 8 >> 2] = addr[0];\r\n        HEAP32[sa + 12 >> 2] = addr[1];\r\n        HEAP32[sa + 16 >> 2] = addr[2];\r\n        HEAP32[sa + 20 >> 2] = addr[3];\r\n        HEAP16[sa + 2 >> 1] = _htons(port);\r\n        HEAP32[sa + 4 >> 2] = 0;\r\n        HEAP32[sa + 24 >> 2] = 0;\r\n        break;\r\n      default:\r\n        return {\r\n          errno: ERRNO_CODES.EAFNOSUPPORT\r\n        }\r\n    }\r\n    return {}\r\n  }\r\n\r\n  function ___syscall102(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var call = SYSCALLS.get(),\r\n        socketvararg = SYSCALLS.get();\r\n      SYSCALLS.varargs = socketvararg;\r\n      switch (call) {\r\n        case 1: {\r\n          var domain = SYSCALLS.get(),\r\n            type = SYSCALLS.get(),\r\n            protocol = SYSCALLS.get();\r\n          var sock = SOCKFS.createSocket(domain, type, protocol);\r\n          assert(sock.stream.fd < 64);\r\n          return sock.stream.fd\r\n        };\r\n      case 2: {\r\n        var sock = SYSCALLS.getSocketFromFD(),\r\n          info = SYSCALLS.getSocketAddress();\r\n        sock.sock_ops.bind(sock, info.addr, info.port);\r\n        return 0\r\n      };\r\n      case 3: {\r\n        var sock = SYSCALLS.getSocketFromFD(),\r\n          info = SYSCALLS.getSocketAddress();\r\n        sock.sock_ops.connect(sock, info.addr, info.port);\r\n        return 0\r\n      };\r\n      case 4: {\r\n        var sock = SYSCALLS.getSocketFromFD(),\r\n          backlog = SYSCALLS.get();\r\n        sock.sock_ops.listen(sock, backlog);\r\n        return 0\r\n      };\r\n      case 5: {\r\n        var sock = SYSCALLS.getSocketFromFD(),\r\n          addr = SYSCALLS.get(),\r\n          addrlen = SYSCALLS.get();\r\n        var newsock = sock.sock_ops.accept(sock);\r\n        if (addr) {\r\n          var res = __write_sockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport);\r\n          assert(!res.errno)\r\n        }\r\n        return newsock.stream.fd\r\n      };\r\n      case 6: {\r\n        var sock = SYSCALLS.getSocketFromFD(),\r\n          addr = SYSCALLS.get(),\r\n          addrlen = SYSCALLS.get();\r\n        var res = __write_sockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || \"0.0.0.0\"), sock.sport);\r\n        assert(!res.errno);\r\n        return 0\r\n      };\r\n      case 7: {\r\n        var sock = SYSCALLS.getSocketFromFD(),\r\n          addr = SYSCALLS.get(),\r\n          addrlen = SYSCALLS.get();\r\n        if (!sock.daddr) {\r\n          return -ERRNO_CODES.ENOTCONN\r\n        }\r\n        var res = __write_sockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport);\r\n        assert(!res.errno);\r\n        return 0\r\n      };\r\n      case 11: {\r\n        var sock = SYSCALLS.getSocketFromFD(),\r\n          message = SYSCALLS.get(),\r\n          length = SYSCALLS.get(),\r\n          flags = SYSCALLS.get(),\r\n          dest = SYSCALLS.getSocketAddress(true);\r\n        if (!dest) {\r\n          return FS.write(sock.stream, HEAP8, message, length)\r\n        } else {\r\n          return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port)\r\n        }\r\n      };\r\n      case 12: {\r\n        var sock = SYSCALLS.getSocketFromFD(),\r\n          buf = SYSCALLS.get(),\r\n          len = SYSCALLS.get(),\r\n          flags = SYSCALLS.get(),\r\n          addr = SYSCALLS.get(),\r\n          addrlen = SYSCALLS.get();\r\n        var msg = sock.sock_ops.recvmsg(sock, len);\r\n        if (!msg) return 0;\r\n        if (addr) {\r\n          var res = __write_sockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port);\r\n          assert(!res.errno)\r\n        }\r\n        HEAPU8.set(msg.buffer, buf);\r\n        return msg.buffer.byteLength\r\n      };\r\n      case 14: {\r\n        return -ERRNO_CODES.ENOPROTOOPT\r\n      };\r\n      case 15: {\r\n        var sock = SYSCALLS.getSocketFromFD(),\r\n          level = SYSCALLS.get(),\r\n          optname = SYSCALLS.get(),\r\n          optval = SYSCALLS.get(),\r\n          optlen = SYSCALLS.get();\r\n        if (level === 1) {\r\n          if (optname === 4) {\r\n            HEAP32[optval >> 2] = sock.error;\r\n            HEAP32[optlen >> 2] = 4;\r\n            sock.error = null;\r\n            return 0\r\n          }\r\n        }\r\n        return -ERRNO_CODES.ENOPROTOOPT\r\n      };\r\n      case 16: {\r\n        var sock = SYSCALLS.getSocketFromFD(),\r\n          message = SYSCALLS.get(),\r\n          flags = SYSCALLS.get();\r\n        var iov = HEAP32[message + 8 >> 2];\r\n        var num = HEAP32[message + 12 >> 2];\r\n        var addr, port;\r\n        var name = HEAP32[message >> 2];\r\n        var namelen = HEAP32[message + 4 >> 2];\r\n        if (name) {\r\n          var info = __read_sockaddr(name, namelen);\r\n          if (info.errno) return -info.errno;\r\n          port = info.port;\r\n          addr = DNS.lookup_addr(info.addr) || info.addr\r\n        }\r\n        var total = 0;\r\n        for (var i = 0; i < num; i++) {\r\n          total += HEAP32[iov + (8 * i + 4) >> 2]\r\n        }\r\n        var view = new Uint8Array(total);\r\n        var offset = 0;\r\n        for (var i = 0; i < num; i++) {\r\n          var iovbase = HEAP32[iov + (8 * i + 0) >> 2];\r\n          var iovlen = HEAP32[iov + (8 * i + 4) >> 2];\r\n          for (var j = 0; j < iovlen; j++) {\r\n            view[offset++] = HEAP8[iovbase + j >> 0]\r\n          }\r\n        }\r\n        return sock.sock_ops.sendmsg(sock, view, 0, total, addr, port)\r\n      };\r\n      case 17: {\r\n        var sock = SYSCALLS.getSocketFromFD(),\r\n          message = SYSCALLS.get(),\r\n          flags = SYSCALLS.get();\r\n        var iov = HEAP32[message + 8 >> 2];\r\n        var num = HEAP32[message + 12 >> 2];\r\n        var total = 0;\r\n        for (var i = 0; i < num; i++) {\r\n          total += HEAP32[iov + (8 * i + 4) >> 2]\r\n        }\r\n        var msg = sock.sock_ops.recvmsg(sock, total);\r\n        if (!msg) return 0;\r\n        var name = HEAP32[message >> 2];\r\n        if (name) {\r\n          var res = __write_sockaddr(name, sock.family, DNS.lookup_name(msg.addr), msg.port);\r\n          assert(!res.errno)\r\n        }\r\n        var bytesRead = 0;\r\n        var bytesRemaining = msg.buffer.byteLength;\r\n        for (var i = 0; bytesRemaining > 0 && i < num; i++) {\r\n          var iovbase = HEAP32[iov + (8 * i + 0) >> 2];\r\n          var iovlen = HEAP32[iov + (8 * i + 4) >> 2];\r\n          if (!iovlen) {\r\n            continue\r\n          }\r\n          var length = Math.min(iovlen, bytesRemaining);\r\n          var buf = msg.buffer.subarray(bytesRead, bytesRead + length);\r\n          HEAPU8.set(buf, iovbase + bytesRead);\r\n          bytesRead += length;\r\n          bytesRemaining -= length\r\n        }\r\n        return bytesRead\r\n      };\r\n      default:\r\n        abort(\"unsupported socketcall syscall \" + call)\r\n      }\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall118(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var stream = SYSCALLS.getStreamFromFD();\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall12(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var path = SYSCALLS.getStr();\r\n      FS.chdir(path);\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall122(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var buf = SYSCALLS.get();\r\n      if (!buf) return -ERRNO_CODES.EFAULT;\r\n      var layout = {\r\n        \"sysname\": 0,\r\n        \"nodename\": 65,\r\n        \"domainname\": 325,\r\n        \"machine\": 260,\r\n        \"version\": 195,\r\n        \"release\": 130,\r\n        \"__size__\": 390\r\n      };\r\n\r\n      function copyString(element, value) {\r\n        var offset = layout[element];\r\n        writeAsciiToMemory(value, buf + offset)\r\n      }\r\n      copyString(\"sysname\", \"Emscripten\");\r\n      copyString(\"nodename\", \"emscripten\");\r\n      copyString(\"release\", \"1.0\");\r\n      copyString(\"version\", \"#1\");\r\n      copyString(\"machine\", \"x86-JS\");\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall125(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall140(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var stream = SYSCALLS.getStreamFromFD(),\r\n        offset_high = SYSCALLS.get(),\r\n        offset_low = SYSCALLS.get(),\r\n        result = SYSCALLS.get(),\r\n        whence = SYSCALLS.get();\r\n      var offset = offset_low;\r\n      FS.llseek(stream, offset, whence);\r\n      HEAP32[result >> 2] = stream.position;\r\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall142(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var nfds = SYSCALLS.get(),\r\n        readfds = SYSCALLS.get(),\r\n        writefds = SYSCALLS.get(),\r\n        exceptfds = SYSCALLS.get(),\r\n        timeout = SYSCALLS.get();\r\n      assert(nfds <= 64, \"nfds must be less than or equal to 64\");\r\n      assert(!exceptfds, \"exceptfds not supported\");\r\n      var total = 0;\r\n      var srcReadLow = readfds ? HEAP32[readfds >> 2] : 0,\r\n        srcReadHigh = readfds ? HEAP32[readfds + 4 >> 2] : 0;\r\n      var srcWriteLow = writefds ? HEAP32[writefds >> 2] : 0,\r\n        srcWriteHigh = writefds ? HEAP32[writefds + 4 >> 2] : 0;\r\n      var srcExceptLow = exceptfds ? HEAP32[exceptfds >> 2] : 0,\r\n        srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0;\r\n      var dstReadLow = 0,\r\n        dstReadHigh = 0;\r\n      var dstWriteLow = 0,\r\n        dstWriteHigh = 0;\r\n      var dstExceptLow = 0,\r\n        dstExceptHigh = 0;\r\n      var allLow = (readfds ? HEAP32[readfds >> 2] : 0) | (writefds ? HEAP32[writefds >> 2] : 0) | (exceptfds ? HEAP32[exceptfds >> 2] : 0);\r\n      var allHigh = (readfds ? HEAP32[readfds + 4 >> 2] : 0) | (writefds ? HEAP32[writefds + 4 >> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0);\r\n\r\n      function check(fd, low, high, val) {\r\n        return fd < 32 ? low & val : high & val\r\n      }\r\n      for (var fd = 0; fd < nfds; fd++) {\r\n        var mask = 1 << fd % 32;\r\n        if (!check(fd, allLow, allHigh, mask)) {\r\n          continue\r\n        }\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n        var flags = SYSCALLS.DEFAULT_POLLMASK;\r\n        if (stream.stream_ops.poll) {\r\n          flags = stream.stream_ops.poll(stream)\r\n        }\r\n        if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {\r\n          fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;\r\n          total++\r\n        }\r\n        if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {\r\n          fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;\r\n          total++\r\n        }\r\n        if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {\r\n          fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;\r\n          total++\r\n        }\r\n      }\r\n      if (readfds) {\r\n        HEAP32[readfds >> 2] = dstReadLow;\r\n        HEAP32[readfds + 4 >> 2] = dstReadHigh\r\n      }\r\n      if (writefds) {\r\n        HEAP32[writefds >> 2] = dstWriteLow;\r\n        HEAP32[writefds + 4 >> 2] = dstWriteHigh\r\n      }\r\n      if (exceptfds) {\r\n        HEAP32[exceptfds >> 2] = dstExceptLow;\r\n        HEAP32[exceptfds + 4 >> 2] = dstExceptHigh\r\n      }\r\n      return total\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall144(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var addr = SYSCALLS.get(),\r\n        len = SYSCALLS.get(),\r\n        flags = SYSCALLS.get();\r\n      var info = SYSCALLS.mappings[addr];\r\n      if (!info) return 0;\r\n      SYSCALLS.doMsync(addr, FS.getStream(info.fd), len, info.flags);\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall145(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var stream = SYSCALLS.getStreamFromFD(),\r\n        iov = SYSCALLS.get(),\r\n        iovcnt = SYSCALLS.get();\r\n      return SYSCALLS.doReadv(stream, iov, iovcnt)\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall146(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var stream = SYSCALLS.getStreamFromFD(),\r\n        iov = SYSCALLS.get(),\r\n        iovcnt = SYSCALLS.get();\r\n      return SYSCALLS.doWritev(stream, iov, iovcnt)\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall15(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var path = SYSCALLS.getStr(),\r\n        mode = SYSCALLS.get();\r\n      FS.chmod(path, mode);\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall168(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var fds = SYSCALLS.get(),\r\n        nfds = SYSCALLS.get(),\r\n        timeout = SYSCALLS.get();\r\n      var nonzero = 0;\r\n      for (var i = 0; i < nfds; i++) {\r\n        var pollfd = fds + 8 * i;\r\n        var fd = HEAP32[pollfd >> 2];\r\n        var events = HEAP16[pollfd + 4 >> 1];\r\n        var mask = 32;\r\n        var stream = FS.getStream(fd);\r\n        if (stream) {\r\n          mask = SYSCALLS.DEFAULT_POLLMASK;\r\n          if (stream.stream_ops.poll) {\r\n            mask = stream.stream_ops.poll(stream)\r\n          }\r\n        }\r\n        mask &= events | 8 | 16;\r\n        if (mask) nonzero++;\r\n        HEAP16[pollfd + 6 >> 1] = mask\r\n      }\r\n      return nonzero\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall183(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var buf = SYSCALLS.get(),\r\n        size = SYSCALLS.get();\r\n      if (size === 0) return -ERRNO_CODES.EINVAL;\r\n      var cwd = FS.cwd();\r\n      var cwdLengthInBytes = lengthBytesUTF8(cwd);\r\n      if (size < cwdLengthInBytes + 1) return -ERRNO_CODES.ERANGE;\r\n      stringToUTF8(cwd, buf, size);\r\n      return buf\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall191(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var resource = SYSCALLS.get(),\r\n        rlim = SYSCALLS.get();\r\n      HEAP32[rlim >> 2] = -1;\r\n      HEAP32[rlim + 4 >> 2] = -1;\r\n      HEAP32[rlim + 8 >> 2] = -1;\r\n      HEAP32[rlim + 12 >> 2] = -1;\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall192(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var addr = SYSCALLS.get(),\r\n        len = SYSCALLS.get(),\r\n        prot = SYSCALLS.get(),\r\n        flags = SYSCALLS.get(),\r\n        fd = SYSCALLS.get(),\r\n        off = SYSCALLS.get();\r\n      off <<= 12;\r\n      var ptr;\r\n      var allocated = false;\r\n      if (fd === -1) {\r\n        ptr = _memalign(PAGE_SIZE, len);\r\n        if (!ptr) return -ERRNO_CODES.ENOMEM;\r\n        _memset(ptr, 0, len);\r\n        allocated = true\r\n      } else {\r\n        var info = FS.getStream(fd);\r\n        if (!info) return -ERRNO_CODES.EBADF;\r\n        var res = FS.mmap(info, HEAPU8, addr, len, off, prot, flags);\r\n        ptr = res.ptr;\r\n        allocated = res.allocated\r\n      }\r\n      SYSCALLS.mappings[ptr] = {\r\n        malloc: ptr,\r\n        len: len,\r\n        allocated: allocated,\r\n        fd: fd,\r\n        flags: flags\r\n      };\r\n      return ptr\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall194(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var fd = SYSCALLS.get(),\r\n        zero = SYSCALLS.getZero(),\r\n        length = SYSCALLS.get64();\r\n      FS.ftruncate(fd, length);\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall195(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var path = SYSCALLS.getStr(),\r\n        buf = SYSCALLS.get();\r\n      return SYSCALLS.doStat(FS.stat, path, buf)\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall196(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var path = SYSCALLS.getStr(),\r\n        buf = SYSCALLS.get();\r\n      return SYSCALLS.doStat(FS.lstat, path, buf)\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall197(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var stream = SYSCALLS.getStreamFromFD(),\r\n        buf = SYSCALLS.get();\r\n      return SYSCALLS.doStat(FS.stat, stream.path, buf)\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall202(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall199() {\r\n    return ___syscall202.apply(null, arguments)\r\n  }\r\n  var PROCINFO = {\r\n    ppid: 1,\r\n    pid: 42,\r\n    sid: 42,\r\n    pgid: 42\r\n  };\r\n\r\n  function ___syscall20(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      return PROCINFO.pid\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall201() {\r\n    return ___syscall202.apply(null, arguments)\r\n  }\r\n\r\n  function ___syscall211(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var ruid = SYSCALLS.get(),\r\n        euid = SYSCALLS.get(),\r\n        suid = SYSCALLS.get();\r\n      HEAP32[ruid >> 2] = 0;\r\n      HEAP32[euid >> 2] = 0;\r\n      HEAP32[suid >> 2] = 0;\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall209() {\r\n    return ___syscall211.apply(null, arguments)\r\n  }\r\n\r\n  function ___syscall219(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall220(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var stream = SYSCALLS.getStreamFromFD(),\r\n        dirp = SYSCALLS.get(),\r\n        count = SYSCALLS.get();\r\n      if (!stream.getdents) {\r\n        stream.getdents = FS.readdir(stream.path)\r\n      }\r\n      var pos = 0;\r\n      while (stream.getdents.length > 0 && pos + 268 <= count) {\r\n        var id;\r\n        var type;\r\n        var name = stream.getdents.pop();\r\n        if (name[0] === \".\") {\r\n          id = 1;\r\n          type = 4\r\n        } else {\r\n          var child = FS.lookupNode(stream.node, name);\r\n          id = child.id;\r\n          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8\r\n        }\r\n        HEAP32[dirp + pos >> 2] = id;\r\n        HEAP32[dirp + pos + 4 >> 2] = stream.position;\r\n        HEAP16[dirp + pos + 8 >> 1] = 268;\r\n        HEAP8[dirp + pos + 10 >> 0] = type;\r\n        stringToUTF8(name, dirp + pos + 11, 256);\r\n        pos += 268\r\n      }\r\n      return pos\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall221(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var stream = SYSCALLS.getStreamFromFD(),\r\n        cmd = SYSCALLS.get();\r\n      switch (cmd) {\r\n        case 0: {\r\n          var arg = SYSCALLS.get();\r\n          if (arg < 0) {\r\n            return -ERRNO_CODES.EINVAL\r\n          }\r\n          var newStream;\r\n          newStream = FS.open(stream.path, stream.flags, 0, arg);\r\n          return newStream.fd\r\n        };\r\n      case 1:\r\n      case 2:\r\n        return 0;\r\n      case 3:\r\n        return stream.flags;\r\n      case 4: {\r\n        var arg = SYSCALLS.get();\r\n        stream.flags |= arg;\r\n        return 0\r\n      };\r\n      case 12:\r\n      case 12: {\r\n        var arg = SYSCALLS.get();\r\n        var offset = 0;\r\n        HEAP16[arg + offset >> 1] = 2;\r\n        return 0\r\n      };\r\n      case 13:\r\n      case 14:\r\n      case 13:\r\n      case 14:\r\n        return 0;\r\n      case 16:\r\n      case 8:\r\n        return -ERRNO_CODES.EINVAL;\r\n      case 9:\r\n        ___setErrNo(ERRNO_CODES.EINVAL);\r\n        return -1;\r\n      default: {\r\n        return -ERRNO_CODES.EINVAL\r\n      }\r\n      }\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall268(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var path = SYSCALLS.getStr(),\r\n        size = SYSCALLS.get(),\r\n        buf = SYSCALLS.get();\r\n      assert(size === 64);\r\n      HEAP32[buf + 4 >> 2] = 4096;\r\n      HEAP32[buf + 40 >> 2] = 4096;\r\n      HEAP32[buf + 8 >> 2] = 1e6;\r\n      HEAP32[buf + 12 >> 2] = 5e5;\r\n      HEAP32[buf + 16 >> 2] = 5e5;\r\n      HEAP32[buf + 20 >> 2] = FS.nextInode;\r\n      HEAP32[buf + 24 >> 2] = 1e6;\r\n      HEAP32[buf + 28 >> 2] = 42;\r\n      HEAP32[buf + 44 >> 2] = 2;\r\n      HEAP32[buf + 36 >> 2] = 255;\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall272(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall3(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var stream = SYSCALLS.getStreamFromFD(),\r\n        buf = SYSCALLS.get(),\r\n        count = SYSCALLS.get();\r\n      return FS.read(stream, HEAP8, buf, count)\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall33(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var path = SYSCALLS.getStr(),\r\n        amode = SYSCALLS.get();\r\n      return SYSCALLS.doAccess(path, amode)\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall340(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var pid = SYSCALLS.get(),\r\n        resource = SYSCALLS.get(),\r\n        new_limit = SYSCALLS.get(),\r\n        old_limit = SYSCALLS.get();\r\n      if (old_limit) {\r\n        HEAP32[old_limit >> 2] = -1;\r\n        HEAP32[old_limit + 4 >> 2] = -1;\r\n        HEAP32[old_limit + 8 >> 2] = -1;\r\n        HEAP32[old_limit + 12 >> 2] = -1\r\n      }\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall38(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var old_path = SYSCALLS.getStr(),\r\n        new_path = SYSCALLS.getStr();\r\n      FS.rename(old_path, new_path);\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall39(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var path = SYSCALLS.getStr(),\r\n        mode = SYSCALLS.get();\r\n      return SYSCALLS.doMkdir(path, mode)\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall4(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var stream = SYSCALLS.getStreamFromFD(),\r\n        buf = SYSCALLS.get(),\r\n        count = SYSCALLS.get();\r\n      return FS.write(stream, HEAP8, buf, count)\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall40(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var path = SYSCALLS.getStr();\r\n      FS.rmdir(path);\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall41(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var old = SYSCALLS.getStreamFromFD();\r\n      return FS.open(old.path, old.flags, 0).fd\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n  var PIPEFS = {\r\n    BUCKET_BUFFER_SIZE: 8192,\r\n    mount: (function(mount) {\r\n      return FS.createNode(null, \"/\", 16384 | 511, 0)\r\n    }),\r\n    createPipe: (function() {\r\n      var pipe = {\r\n        buckets: []\r\n      };\r\n      pipe.buckets.push({\r\n        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),\r\n        offset: 0,\r\n        roffset: 0\r\n      });\r\n      var rName = PIPEFS.nextname();\r\n      var wName = PIPEFS.nextname();\r\n      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);\r\n      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);\r\n      rNode.pipe = pipe;\r\n      wNode.pipe = pipe;\r\n      var readableStream = FS.createStream({\r\n        path: rName,\r\n        node: rNode,\r\n        flags: FS.modeStringToFlags(\"r\"),\r\n        seekable: false,\r\n        stream_ops: PIPEFS.stream_ops\r\n      });\r\n      rNode.stream = readableStream;\r\n      var writableStream = FS.createStream({\r\n        path: wName,\r\n        node: wNode,\r\n        flags: FS.modeStringToFlags(\"w\"),\r\n        seekable: false,\r\n        stream_ops: PIPEFS.stream_ops\r\n      });\r\n      wNode.stream = writableStream;\r\n      return {\r\n        readable_fd: readableStream.fd,\r\n        writable_fd: writableStream.fd\r\n      }\r\n    }),\r\n    stream_ops: {\r\n      poll: (function(stream) {\r\n        var pipe = stream.node.pipe;\r\n        if ((stream.flags & 2097155) === 1) {\r\n          return 256 | 4\r\n        } else {\r\n          if (pipe.buckets.length > 0) {\r\n            for (var i = 0; i < pipe.buckets.length; i++) {\r\n              var bucket = pipe.buckets[i];\r\n              if (bucket.offset - bucket.roffset > 0) {\r\n                return 64 | 1\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return 0\r\n      }),\r\n      ioctl: (function(stream, request, varargs) {\r\n        return ERRNO_CODES.EINVAL\r\n      }),\r\n      read: (function(stream, buffer, offset, length, position) {\r\n        var pipe = stream.node.pipe;\r\n        var currentLength = 0;\r\n        for (var i = 0; i < pipe.buckets.length; i++) {\r\n          var bucket = pipe.buckets[i];\r\n          currentLength += bucket.offset - bucket.roffset\r\n        }\r\n        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));\r\n        var data = buffer.subarray(offset, offset + length);\r\n        if (length <= 0) {\r\n          return 0\r\n        }\r\n        if (currentLength == 0) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)\r\n        }\r\n        var toRead = Math.min(currentLength, length);\r\n        var totalRead = toRead;\r\n        var toRemove = 0;\r\n        for (var i = 0; i < pipe.buckets.length; i++) {\r\n          var currBucket = pipe.buckets[i];\r\n          var bucketSize = currBucket.offset - currBucket.roffset;\r\n          if (toRead <= bucketSize) {\r\n            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);\r\n            if (toRead < bucketSize) {\r\n              tmpSlice = tmpSlice.subarray(0, toRead);\r\n              currBucket.roffset += toRead\r\n            } else {\r\n              toRemove++\r\n            }\r\n            data.set(tmpSlice);\r\n            break\r\n          } else {\r\n            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);\r\n            data.set(tmpSlice);\r\n            data = data.subarray(tmpSlice.byteLength);\r\n            toRead -= tmpSlice.byteLength;\r\n            toRemove++\r\n          }\r\n        }\r\n        if (toRemove && toRemove == pipe.buckets.length) {\r\n          toRemove--;\r\n          pipe.buckets[toRemove].offset = 0;\r\n          pipe.buckets[toRemove].roffset = 0\r\n        }\r\n        pipe.buckets.splice(0, toRemove);\r\n        return totalRead\r\n      }),\r\n      write: (function(stream, buffer, offset, length, position) {\r\n        var pipe = stream.node.pipe;\r\n        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));\r\n        var data = buffer.subarray(offset, offset + length);\r\n        var dataLen = data.byteLength;\r\n        if (dataLen <= 0) {\r\n          return 0\r\n        }\r\n        var currBucket = null;\r\n        if (pipe.buckets.length == 0) {\r\n          currBucket = {\r\n            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),\r\n            offset: 0,\r\n            roffset: 0\r\n          };\r\n          pipe.buckets.push(currBucket)\r\n        } else {\r\n          currBucket = pipe.buckets[pipe.buckets.length - 1]\r\n        }\r\n        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);\r\n        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;\r\n        if (freeBytesInCurrBuffer >= dataLen) {\r\n          currBucket.buffer.set(data, currBucket.offset);\r\n          currBucket.offset += dataLen;\r\n          return dataLen\r\n        } else if (freeBytesInCurrBuffer > 0) {\r\n          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);\r\n          currBucket.offset += freeBytesInCurrBuffer;\r\n          data = data.subarray(freeBytesInCurrBuffer, data.byteLength)\r\n        }\r\n        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;\r\n        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;\r\n        for (var i = 0; i < numBuckets; i++) {\r\n          var newBucket = {\r\n            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),\r\n            offset: PIPEFS.BUCKET_BUFFER_SIZE,\r\n            roffset: 0\r\n          };\r\n          pipe.buckets.push(newBucket);\r\n          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));\r\n          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength)\r\n        }\r\n        if (remElements > 0) {\r\n          var newBucket = {\r\n            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),\r\n            offset: data.byteLength,\r\n            roffset: 0\r\n          };\r\n          pipe.buckets.push(newBucket);\r\n          newBucket.buffer.set(data)\r\n        }\r\n        return dataLen\r\n      }),\r\n      close: (function(stream) {\r\n        var pipe = stream.node.pipe;\r\n        pipe.buckets = null\r\n      })\r\n    },\r\n    nextname: (function() {\r\n      if (!PIPEFS.nextname.current) {\r\n        PIPEFS.nextname.current = 0\r\n      }\r\n      return \"pipe[\" + PIPEFS.nextname.current++ + \"]\"\r\n    })\r\n  };\r\n\r\n  function ___syscall42(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var fdPtr = SYSCALLS.get();\r\n      if (fdPtr == 0) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EFAULT)\r\n      }\r\n      var res = PIPEFS.createPipe();\r\n      HEAP32[fdPtr >> 2] = res.readable_fd;\r\n      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall5(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var pathname = SYSCALLS.getStr(),\r\n        flags = SYSCALLS.get(),\r\n        mode = SYSCALLS.get();\r\n      var stream = FS.open(pathname, flags, mode);\r\n      return stream.fd\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall54(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var stream = SYSCALLS.getStreamFromFD(),\r\n        op = SYSCALLS.get();\r\n      switch (op) {\r\n        case 21509:\r\n        case 21505: {\r\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n          return 0\r\n        };\r\n      case 21510:\r\n      case 21511:\r\n      case 21512:\r\n      case 21506:\r\n      case 21507:\r\n      case 21508: {\r\n        if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n        return 0\r\n      };\r\n      case 21519: {\r\n        if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n        var argp = SYSCALLS.get();\r\n        HEAP32[argp >> 2] = 0;\r\n        return 0\r\n      };\r\n      case 21520: {\r\n        if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n        return -ERRNO_CODES.EINVAL\r\n      };\r\n      case 21531: {\r\n        var argp = SYSCALLS.get();\r\n        return FS.ioctl(stream, op, argp)\r\n      };\r\n      case 21523: {\r\n        if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n        return 0\r\n      };\r\n      default:\r\n        abort(\"bad ioctl syscall \" + op)\r\n      }\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall6(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var stream = SYSCALLS.getStreamFromFD();\r\n      FS.close(stream);\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall63(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var old = SYSCALLS.getStreamFromFD(),\r\n        suggestFD = SYSCALLS.get();\r\n      if (old.fd === suggestFD) return suggestFD;\r\n      return SYSCALLS.doDup(old.path, old.flags, suggestFD)\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall77(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var who = SYSCALLS.get(),\r\n        usage = SYSCALLS.get();\r\n      _memset(usage, 0, 136);\r\n      HEAP32[usage >> 2] = 1;\r\n      HEAP32[usage + 4 >> 2] = 2;\r\n      HEAP32[usage + 8 >> 2] = 3;\r\n      HEAP32[usage + 12 >> 2] = 4;\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall85(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var path = SYSCALLS.getStr(),\r\n        buf = SYSCALLS.get(),\r\n        bufsize = SYSCALLS.get();\r\n      return SYSCALLS.doReadlink(path, buf, bufsize)\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall91(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      var addr = SYSCALLS.get(),\r\n        len = SYSCALLS.get();\r\n      var info = SYSCALLS.mappings[addr];\r\n      if (!info) return 0;\r\n      if (len === info.len) {\r\n        var stream = FS.getStream(info.fd);\r\n        SYSCALLS.doMsync(addr, stream, len, info.flags);\r\n        FS.munmap(stream);\r\n        SYSCALLS.mappings[addr] = null;\r\n        if (info.allocated) {\r\n          _free(info.malloc)\r\n        }\r\n      }\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall96(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      return 0\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___syscall97(which, varargs) {\r\n    SYSCALLS.varargs = varargs;\r\n    try {\r\n      return -ERRNO_CODES.EPERM\r\n    } catch (e) {\r\n      if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n      return -e.errno\r\n    }\r\n  }\r\n\r\n  function ___unlock() {}\r\n\r\n  function __exit(status) {\r\n    Module[\"exit\"](status)\r\n  }\r\n\r\n  function _abort() {\r\n    Module[\"abort\"]()\r\n  }\r\n\r\n  function _atexit(func, arg) {\r\n    __ATEXIT__.unshift({\r\n      func: func,\r\n      arg: arg\r\n    })\r\n  }\r\n\r\n  function _emscripten_get_now_res() {\r\n    if (ENVIRONMENT_IS_NODE) {\r\n      return 1\r\n    } else if (typeof dateNow !== \"undefined\" || (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && self[\"performance\"] && self[\"performance\"][\"now\"]) {\r\n      return 1e3\r\n    } else {\r\n      return 1e3 * 1e3\r\n    }\r\n  }\r\n\r\n  function _clock_getres(clk_id, res) {\r\n    var nsec;\r\n    if (clk_id === 0) {\r\n      nsec = 1e3 * 1e3\r\n    } else if (clk_id === 1 && _emscripten_get_now_is_monotonic()) {\r\n      nsec = _emscripten_get_now_res()\r\n    } else {\r\n      ___setErrNo(ERRNO_CODES.EINVAL);\r\n      return -1\r\n    }\r\n    HEAP32[res >> 2] = nsec / 1e9 | 0;\r\n    HEAP32[res + 4 >> 2] = nsec;\r\n    return 0\r\n  }\r\n\r\n  function _execl() {\r\n    ___setErrNo(ERRNO_CODES.ENOEXEC);\r\n    return -1\r\n  }\r\n\r\n  function _execve() {\r\n    return _execl.apply(null, arguments)\r\n  }\r\n\r\n  function _exit(status) {\r\n    __exit(status)\r\n  }\r\n\r\n  function _fork() {\r\n    ___setErrNo(ERRNO_CODES.EAGAIN);\r\n    return -1\r\n  }\r\n\r\n  function _getaddrinfo(node, service, hint, out) {\r\n    var addr = 0;\r\n    var port = 0;\r\n    var flags = 0;\r\n    var family = 0;\r\n    var type = 0;\r\n    var proto = 0;\r\n    var ai;\r\n\r\n    function allocaddrinfo(family, type, proto, canon, addr, port) {\r\n      var sa, salen, ai;\r\n      var res;\r\n      salen = family === 10 ? 28 : 16;\r\n      addr = family === 10 ? __inet_ntop6_raw(addr) : __inet_ntop4_raw(addr);\r\n      sa = _malloc(salen);\r\n      res = __write_sockaddr(sa, family, addr, port);\r\n      assert(!res.errno);\r\n      ai = _malloc(32);\r\n      HEAP32[ai + 4 >> 2] = family;\r\n      HEAP32[ai + 8 >> 2] = type;\r\n      HEAP32[ai + 12 >> 2] = proto;\r\n      HEAP32[ai + 24 >> 2] = canon;\r\n      HEAP32[ai + 20 >> 2] = sa;\r\n      if (family === 10) {\r\n        HEAP32[ai + 16 >> 2] = 28\r\n      } else {\r\n        HEAP32[ai + 16 >> 2] = 16\r\n      }\r\n      HEAP32[ai + 28 >> 2] = 0;\r\n      return ai\r\n    }\r\n    if (hint) {\r\n      flags = HEAP32[hint >> 2];\r\n      family = HEAP32[hint + 4 >> 2];\r\n      type = HEAP32[hint + 8 >> 2];\r\n      proto = HEAP32[hint + 12 >> 2]\r\n    }\r\n    if (type && !proto) {\r\n      proto = type === 2 ? 17 : 6\r\n    }\r\n    if (!type && proto) {\r\n      type = proto === 17 ? 2 : 1\r\n    }\r\n    if (proto === 0) {\r\n      proto = 6\r\n    }\r\n    if (type === 0) {\r\n      type = 1\r\n    }\r\n    if (!node && !service) {\r\n      return -2\r\n    }\r\n    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {\r\n      return -1\r\n    }\r\n    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {\r\n      return -1\r\n    }\r\n    if (flags & 32) {\r\n      return -2\r\n    }\r\n    if (type !== 0 && type !== 1 && type !== 2) {\r\n      return -7\r\n    }\r\n    if (family !== 0 && family !== 2 && family !== 10) {\r\n      return -6\r\n    }\r\n    if (service) {\r\n      service = Pointer_stringify(service);\r\n      port = parseInt(service, 10);\r\n      if (isNaN(port)) {\r\n        if (flags & 1024) {\r\n          return -2\r\n        }\r\n        return -8\r\n      }\r\n    }\r\n    if (!node) {\r\n      if (family === 0) {\r\n        family = 2\r\n      }\r\n      if ((flags & 1) === 0) {\r\n        if (family === 2) {\r\n          addr = _htonl(2130706433)\r\n        } else {\r\n          addr = [0, 0, 0, 1]\r\n        }\r\n      }\r\n      ai = allocaddrinfo(family, type, proto, null, addr, port);\r\n      HEAP32[out >> 2] = ai;\r\n      return 0\r\n    }\r\n    node = Pointer_stringify(node);\r\n    addr = __inet_pton4_raw(node);\r\n    if (addr !== null) {\r\n      if (family === 0 || family === 2) {\r\n        family = 2\r\n      } else if (family === 10 && flags & 8) {\r\n        addr = [0, 0, _htonl(65535), addr];\r\n        family = 10\r\n      } else {\r\n        return -2\r\n      }\r\n    } else {\r\n      addr = __inet_pton6_raw(node);\r\n      if (addr !== null) {\r\n        if (family === 0 || family === 10) {\r\n          family = 10\r\n        } else {\r\n          return -2\r\n        }\r\n      }\r\n    }\r\n    if (addr != null) {\r\n      ai = allocaddrinfo(family, type, proto, node, addr, port);\r\n      HEAP32[out >> 2] = ai;\r\n      return 0\r\n    }\r\n    if (flags & 4) {\r\n      return -2\r\n    }\r\n    node = DNS.lookup_name(node);\r\n    addr = __inet_pton4_raw(node);\r\n    if (family === 0) {\r\n      family = 2\r\n    } else if (family === 10) {\r\n      addr = [0, 0, _htonl(65535), addr]\r\n    }\r\n    ai = allocaddrinfo(family, type, proto, null, addr, port);\r\n    HEAP32[out >> 2] = ai;\r\n    return 0\r\n  }\r\n  var _environ = STATICTOP;\r\n  STATICTOP += 16;\r\n\r\n  function ___buildEnvironment(env) {\r\n    var MAX_ENV_VALUES = 64;\r\n    var TOTAL_ENV_SIZE = 1024;\r\n    var poolPtr;\r\n    var envPtr;\r\n    if (!___buildEnvironment.called) {\r\n      ___buildEnvironment.called = true;\r\n      ENV[\"USER\"] = ENV[\"LOGNAME\"] = \"web_user\";\r\n      ENV[\"PATH\"] = \"/\";\r\n      ENV[\"PWD\"] = \"/\";\r\n      ENV[\"HOME\"] = \"/home/web_user\";\r\n      ENV[\"LANG\"] = \"C.UTF-8\";\r\n      ENV[\"_\"] = Module[\"thisProgram\"];\r\n      poolPtr = staticAlloc(TOTAL_ENV_SIZE);\r\n      envPtr = staticAlloc(MAX_ENV_VALUES * 4);\r\n      HEAP32[envPtr >> 2] = poolPtr;\r\n      HEAP32[_environ >> 2] = envPtr\r\n    } else {\r\n      envPtr = HEAP32[_environ >> 2];\r\n      poolPtr = HEAP32[envPtr >> 2]\r\n    }\r\n    var strings = [];\r\n    var totalSize = 0;\r\n    for (var key in env) {\r\n      if (typeof env[key] === \"string\") {\r\n        var line = key + \"=\" + env[key];\r\n        strings.push(line);\r\n        totalSize += line.length\r\n      }\r\n    }\r\n    if (totalSize > TOTAL_ENV_SIZE) {\r\n      throw new Error(\"Environment size exceeded TOTAL_ENV_SIZE!\")\r\n    }\r\n    var ptrSize = 4;\r\n    for (var i = 0; i < strings.length; i++) {\r\n      var line = strings[i];\r\n      writeAsciiToMemory(line, poolPtr);\r\n      HEAP32[envPtr + i * ptrSize >> 2] = poolPtr;\r\n      poolPtr += line.length + 1\r\n    }\r\n    HEAP32[envPtr + strings.length * ptrSize >> 2] = 0\r\n  }\r\n  var ENV = {};\r\n\r\n  function _getenv(name) {\r\n    if (name === 0) return 0;\r\n    name = Pointer_stringify(name);\r\n    if (!ENV.hasOwnProperty(name)) return 0;\r\n    if (_getenv.ret) _free(_getenv.ret);\r\n    _getenv.ret = allocateUTF8(ENV[name]);\r\n    return _getenv.ret\r\n  }\r\n\r\n  function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags) {\r\n    var info = __read_sockaddr(sa, salen);\r\n    if (info.errno) {\r\n      return -6\r\n    }\r\n    var port = info.port;\r\n    var addr = info.addr;\r\n    var overflowed = false;\r\n    if (node && nodelen) {\r\n      var lookup;\r\n      if (flags & 1 || !(lookup = DNS.lookup_addr(addr))) {\r\n        if (flags & 8) {\r\n          return -2\r\n        }\r\n      } else {\r\n        addr = lookup\r\n      }\r\n      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);\r\n      if (numBytesWrittenExclNull + 1 >= nodelen) {\r\n        overflowed = true\r\n      }\r\n    }\r\n    if (serv && servlen) {\r\n      port = \"\" + port;\r\n      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);\r\n      if (numBytesWrittenExclNull + 1 >= servlen) {\r\n        overflowed = true\r\n      }\r\n    }\r\n    if (overflowed) {\r\n      return -12\r\n    }\r\n    return 0\r\n  }\r\n  var Protocols = {\r\n    list: [],\r\n    map: {}\r\n  };\r\n\r\n  function _setprotoent(stayopen) {\r\n    function allocprotoent(name, proto, aliases) {\r\n      var nameBuf = _malloc(name.length + 1);\r\n      writeAsciiToMemory(name, nameBuf);\r\n      var j = 0;\r\n      var length = aliases.length;\r\n      var aliasListBuf = _malloc((length + 1) * 4);\r\n      for (var i = 0; i < length; i++, j += 4) {\r\n        var alias = aliases[i];\r\n        var aliasBuf = _malloc(alias.length + 1);\r\n        writeAsciiToMemory(alias, aliasBuf);\r\n        HEAP32[aliasListBuf + j >> 2] = aliasBuf\r\n      }\r\n      HEAP32[aliasListBuf + j >> 2] = 0;\r\n      var pe = _malloc(12);\r\n      HEAP32[pe >> 2] = nameBuf;\r\n      HEAP32[pe + 4 >> 2] = aliasListBuf;\r\n      HEAP32[pe + 8 >> 2] = proto;\r\n      return pe\r\n    }\r\n    var list = Protocols.list;\r\n    var map = Protocols.map;\r\n    if (list.length === 0) {\r\n      var entry = allocprotoent(\"tcp\", 6, [\"TCP\"]);\r\n      list.push(entry);\r\n      map[\"tcp\"] = map[\"6\"] = entry;\r\n      entry = allocprotoent(\"udp\", 17, [\"UDP\"]);\r\n      list.push(entry);\r\n      map[\"udp\"] = map[\"17\"] = entry\r\n    }\r\n    _setprotoent.index = 0\r\n  }\r\n\r\n  function _getprotobyname(name) {\r\n    name = Pointer_stringify(name);\r\n    _setprotoent(true);\r\n    var result = Protocols.map[name];\r\n    return result\r\n  }\r\n\r\n  function _getpwuid(uid) {\r\n    return 0\r\n  }\r\n\r\n  function _gettimeofday(ptr) {\r\n    var now = Date.now();\r\n    HEAP32[ptr >> 2] = now / 1e3 | 0;\r\n    HEAP32[ptr + 4 >> 2] = now % 1e3 * 1e3 | 0;\r\n    return 0\r\n  }\r\n  var ___tm_timezone = allocate(intArrayFromString(\"GMT\"), \"i8\", ALLOC_STATIC);\r\n\r\n  function _gmtime_r(time, tmPtr) {\r\n    var date = new Date(HEAP32[time >> 2] * 1e3);\r\n    HEAP32[tmPtr >> 2] = date.getUTCSeconds();\r\n    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();\r\n    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();\r\n    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();\r\n    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();\r\n    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;\r\n    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();\r\n    HEAP32[tmPtr + 36 >> 2] = 0;\r\n    HEAP32[tmPtr + 32 >> 2] = 0;\r\n    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);\r\n    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;\r\n    HEAP32[tmPtr + 28 >> 2] = yday;\r\n    HEAP32[tmPtr + 40 >> 2] = ___tm_timezone;\r\n    return tmPtr\r\n  }\r\n\r\n  function _kill(pid, sig) {\r\n    ___setErrNo(ERRNO_CODES.EPERM);\r\n    return -1\r\n  }\r\n  var cttz_i8 = allocate([8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0], \"i8\", ALLOC_STATIC);\r\n\r\n  function _llvm_trap() {\r\n    abort(\"trap!\")\r\n  }\r\n  var _tzname = STATICTOP;\r\n  STATICTOP += 16;\r\n  var _daylight = STATICTOP;\r\n  STATICTOP += 16;\r\n  var _timezone = STATICTOP;\r\n  STATICTOP += 16;\r\n\r\n  function _tzset() {\r\n    if (_tzset.called) return;\r\n    _tzset.called = true;\r\n    HEAP32[_timezone >> 2] = (new Date).getTimezoneOffset() * 60;\r\n    var winter = new Date(2e3, 0, 1);\r\n    var summer = new Date(2e3, 6, 1);\r\n    HEAP32[_daylight >> 2] = Number(winter.getTimezoneOffset() != summer.getTimezoneOffset());\r\n\r\n    function extractZone(date) {\r\n      var match = date.toTimeString().match(/\\(([A-Za-z ]+)\\)$/);\r\n      return match ? match[1] : \"GMT\"\r\n    }\r\n    var winterName = extractZone(winter);\r\n    var summerName = extractZone(summer);\r\n    var winterNamePtr = allocate(intArrayFromString(winterName), \"i8\", ALLOC_NORMAL);\r\n    var summerNamePtr = allocate(intArrayFromString(summerName), \"i8\", ALLOC_NORMAL);\r\n    if (summer.getTimezoneOffset() < winter.getTimezoneOffset()) {\r\n      HEAP32[_tzname >> 2] = winterNamePtr;\r\n      HEAP32[_tzname + 4 >> 2] = summerNamePtr\r\n    } else {\r\n      HEAP32[_tzname >> 2] = summerNamePtr;\r\n      HEAP32[_tzname + 4 >> 2] = winterNamePtr\r\n    }\r\n  }\r\n\r\n  function _localtime_r(time, tmPtr) {\r\n    _tzset();\r\n    var date = new Date(HEAP32[time >> 2] * 1e3);\r\n    HEAP32[tmPtr >> 2] = date.getSeconds();\r\n    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();\r\n    HEAP32[tmPtr + 8 >> 2] = date.getHours();\r\n    HEAP32[tmPtr + 12 >> 2] = date.getDate();\r\n    HEAP32[tmPtr + 16 >> 2] = date.getMonth();\r\n    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;\r\n    HEAP32[tmPtr + 24 >> 2] = date.getDay();\r\n    var start = new Date(date.getFullYear(), 0, 1);\r\n    var yday = (date.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24) | 0;\r\n    HEAP32[tmPtr + 28 >> 2] = yday;\r\n    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);\r\n    var summerOffset = (new Date(2e3, 6, 1)).getTimezoneOffset();\r\n    var winterOffset = start.getTimezoneOffset();\r\n    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;\r\n    HEAP32[tmPtr + 32 >> 2] = dst;\r\n    var zonePtr = HEAP32[_tzname + (dst ? 4 : 0) >> 2];\r\n    HEAP32[tmPtr + 40 >> 2] = zonePtr;\r\n    return tmPtr\r\n  }\r\n\r\n  function _emscripten_memcpy_big(dest, src, num) {\r\n    HEAPU8.set(HEAPU8.subarray(src, src + num), dest);\r\n    return dest\r\n  }\r\n  var MONO = {\r\n    pump_count: 0,\r\n    timeout_queue: [],\r\n    pump_message: (function() {\r\n      if (!this.mono_background_exec) this.mono_background_exec = Module.cwrap(\"mono_background_exec\", \"void\", []);\r\n      while (MONO.timeout_queue.length > 0) {\r\n        --MONO.pump_count;\r\n        MONO.timeout_queue.shift()()\r\n      }\r\n      while (MONO.pump_count > 0) {\r\n        --MONO.pump_count;\r\n        this.mono_background_exec()\r\n      }\r\n    }),\r\n    mono_wasm_get_call_stack: (function() {\r\n      if (!this.mono_wasm_current_bp_id) this.mono_wasm_current_bp_id = Module.cwrap(\"mono_wasm_current_bp_id\", \"number\", []);\r\n      if (!this.mono_wasm_enum_frames) this.mono_wasm_enum_frames = Module.cwrap(\"mono_wasm_enum_frames\", \"void\", []);\r\n      var bp_id = this.mono_wasm_current_bp_id();\r\n      this.active_frames = [];\r\n      this.mono_wasm_enum_frames();\r\n      var the_frames = this.active_frames;\r\n      this.active_frames = [];\r\n      return {\r\n        \"breakpoint_id\": bp_id,\r\n        \"frames\": the_frames\r\n      }\r\n    }),\r\n    mono_wasm_get_variables: (function(scope, var_list) {\r\n      if (!this.mono_wasm_get_var_info) this.mono_wasm_get_var_info = Module.cwrap(\"mono_wasm_get_var_info\", \"void\", [\"number\", \"number\"]);\r\n      this.var_info = [];\r\n      for (var i = 0; i < var_list.length; ++i) this.mono_wasm_get_var_info(scope, var_list[i]);\r\n      var res = this.var_info;\r\n      this.var_info = [];\r\n      return res\r\n    })\r\n  };\r\n\r\n  function _mono_set_timeout(timeout, id) {\r\n    if (!this.mono_set_timeout_exec) this.mono_set_timeout_exec = Module.cwrap(\"mono_set_timeout_exec\", \"void\", [\"number\"]);\r\n    if (ENVIRONMENT_IS_WEB) {\r\n      window.setTimeout((function() {\r\n        this.mono_set_timeout_exec(id)\r\n      }), timeout)\r\n    } else {\r\n      ++MONO.pump_count;\r\n      MONO.timeout_queue.push((function() {\r\n        this.mono_set_timeout_exec(id)\r\n      }))\r\n    }\r\n  }\r\n\r\n  function _mono_wasm_add_bool_var(var_value) {\r\n    MONO.var_info.push({\r\n      value: {\r\n        type: \"boolean\",\r\n        value: var_value != 0\r\n      }\r\n    })\r\n  }\r\n\r\n  function _mono_wasm_add_float_var(var_value) {\r\n    MONO.var_info.push({\r\n      value: {\r\n        type: \"number\",\r\n        value: var_value\r\n      }\r\n    })\r\n  }\r\n\r\n  function _mono_wasm_add_frame(il, method, name) {\r\n    MONO.active_frames.push({\r\n      il_pos: il,\r\n      method_token: method,\r\n      assembly_name: Module.UTF8ToString(name)\r\n    })\r\n  }\r\n\r\n  function _mono_wasm_add_int_var(var_value) {\r\n    MONO.var_info.push({\r\n      value: {\r\n        type: \"number\",\r\n        value: var_value\r\n      }\r\n    })\r\n  }\r\n\r\n  function _mono_wasm_add_long_var(var_value) {\r\n    MONO.var_info.push({\r\n      value: {\r\n        type: \"number\",\r\n        value: var_value\r\n      }\r\n    })\r\n  }\r\n\r\n  function _mono_wasm_add_string_var(var_value) {\r\n    if (var_value == 0) {\r\n      MONO.var_info.push({\r\n        value: {\r\n          type: \"object\",\r\n          subtype: \"null\"\r\n        }\r\n      })\r\n    } else {\r\n      MONO.var_info.push({\r\n        value: {\r\n          type: \"string\",\r\n          value: Module.UTF8ToString(var_value)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  function _mono_wasm_fire_bp() {\r\n    console.log(\"mono_wasm_fire_bp\");\r\n    debugger\r\n  }\r\n\r\n  function _usleep(useconds) {\r\n    var msec = useconds / 1e3;\r\n    if ((ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && self[\"performance\"] && self[\"performance\"][\"now\"]) {\r\n      var start = self[\"performance\"][\"now\"]();\r\n      while (self[\"performance\"][\"now\"]() - start < msec) {}\r\n    } else {\r\n      var start = Date.now();\r\n      while (Date.now() - start < msec) {}\r\n    }\r\n    return 0\r\n  }\r\n  Module[\"_usleep\"] = _usleep;\r\n\r\n  function _nanosleep(rqtp, rmtp) {\r\n    var seconds = HEAP32[rqtp >> 2];\r\n    var nanoseconds = HEAP32[rqtp + 4 >> 2];\r\n    if (rmtp !== 0) {\r\n      HEAP32[rmtp >> 2] = 0;\r\n      HEAP32[rmtp + 4 >> 2] = 0\r\n    }\r\n    return _usleep(seconds * 1e6 + nanoseconds / 1e3)\r\n  }\r\n\r\n  function _pthread_cleanup_pop() {\r\n    assert(_pthread_cleanup_push.level == __ATEXIT__.length, \"cannot pop if something else added meanwhile!\");\r\n    __ATEXIT__.pop();\r\n    _pthread_cleanup_push.level = __ATEXIT__.length\r\n  }\r\n\r\n  function _pthread_cleanup_push(routine, arg) {\r\n    __ATEXIT__.push((function() {\r\n      Module[\"dynCall_vi\"](routine, arg)\r\n    }));\r\n    _pthread_cleanup_push.level = __ATEXIT__.length\r\n  }\r\n\r\n  function _pthread_cond_destroy() {\r\n    return 0\r\n  }\r\n\r\n  function _pthread_cond_init() {\r\n    return 0\r\n  }\r\n\r\n  function _pthread_cond_signal() {\r\n    return 0\r\n  }\r\n\r\n  function _pthread_cond_timedwait() {\r\n    return 0\r\n  }\r\n\r\n  function _pthread_cond_wait() {\r\n    return 0\r\n  }\r\n  var PTHREAD_SPECIFIC = {};\r\n\r\n  function _pthread_getspecific(key) {\r\n    return PTHREAD_SPECIFIC[key] || 0\r\n  }\r\n  var PTHREAD_SPECIFIC_NEXT_KEY = 1;\r\n\r\n  function _pthread_key_create(key, destructor) {\r\n    if (key == 0) {\r\n      return ERRNO_CODES.EINVAL\r\n    }\r\n    HEAP32[key >> 2] = PTHREAD_SPECIFIC_NEXT_KEY;\r\n    PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY] = 0;\r\n    PTHREAD_SPECIFIC_NEXT_KEY++;\r\n    return 0\r\n  }\r\n\r\n  function _pthread_key_delete(key) {\r\n    if (key in PTHREAD_SPECIFIC) {\r\n      delete PTHREAD_SPECIFIC[key];\r\n      return 0\r\n    }\r\n    return ERRNO_CODES.EINVAL\r\n  }\r\n\r\n  function _pthread_mutex_destroy() {}\r\n\r\n  function _pthread_mutex_init() {}\r\n\r\n  function _pthread_mutexattr_destroy() {}\r\n\r\n  function _pthread_mutexattr_init() {}\r\n\r\n  function _pthread_mutexattr_settype() {}\r\n\r\n  function _pthread_setcancelstate() {\r\n    return 0\r\n  }\r\n\r\n  function _pthread_setspecific(key, value) {\r\n    if (!(key in PTHREAD_SPECIFIC)) {\r\n      return ERRNO_CODES.EINVAL\r\n    }\r\n    PTHREAD_SPECIFIC[key] = value;\r\n    return 0\r\n  }\r\n\r\n  function _putchar() {\r\n    Module[\"printErr\"](\"missing function: putchar\");\r\n    abort(-1)\r\n  }\r\n\r\n  function _puts(s) {\r\n    var result = Pointer_stringify(s);\r\n    var string = result.substr(0);\r\n    if (string[string.length - 1] === \"\\n\") string = string.substr(0, string.length - 1);\r\n    Module.print(string);\r\n    return result.length\r\n  }\r\n\r\n  function _schedule_background_exec() {\r\n    ++MONO.pump_count;\r\n    if (ENVIRONMENT_IS_WEB) {\r\n      window.setTimeout(MONO.pump_message, 0)\r\n    }\r\n  }\r\n\r\n  function _sem_destroy() {}\r\n\r\n  function _sem_init() {}\r\n\r\n  function _sem_post() {}\r\n\r\n  function _sem_trywait() {}\r\n\r\n  function _sem_wait() {}\r\n\r\n  function _setenv(envname, envval, overwrite) {\r\n    if (envname === 0) {\r\n      ___setErrNo(ERRNO_CODES.EINVAL);\r\n      return -1\r\n    }\r\n    var name = Pointer_stringify(envname);\r\n    var val = Pointer_stringify(envval);\r\n    if (name === \"\" || name.indexOf(\"=\") !== -1) {\r\n      ___setErrNo(ERRNO_CODES.EINVAL);\r\n      return -1\r\n    }\r\n    if (ENV.hasOwnProperty(name) && !overwrite) return 0;\r\n    ENV[name] = val;\r\n    ___buildEnvironment(ENV);\r\n    return 0\r\n  }\r\n\r\n  function _sigaction(signum, act, oldact) {\r\n    return 0\r\n  }\r\n\r\n  function _sigemptyset(set) {\r\n    HEAP32[set >> 2] = 0;\r\n    return 0\r\n  }\r\n\r\n  function __isLeapYear(year) {\r\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)\r\n  }\r\n\r\n  function __arraySum(array, index) {\r\n    var sum = 0;\r\n    for (var i = 0; i <= index; sum += array[i++]);\r\n    return sum\r\n  }\r\n  var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n  var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n\r\n  function __addDays(date, days) {\r\n    var newDate = new Date(date.getTime());\r\n    while (days > 0) {\r\n      var leap = __isLeapYear(newDate.getFullYear());\r\n      var currentMonth = newDate.getMonth();\r\n      var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];\r\n      if (days > daysInCurrentMonth - newDate.getDate()) {\r\n        days -= daysInCurrentMonth - newDate.getDate() + 1;\r\n        newDate.setDate(1);\r\n        if (currentMonth < 11) {\r\n          newDate.setMonth(currentMonth + 1)\r\n        } else {\r\n          newDate.setMonth(0);\r\n          newDate.setFullYear(newDate.getFullYear() + 1)\r\n        }\r\n      } else {\r\n        newDate.setDate(newDate.getDate() + days);\r\n        return newDate\r\n      }\r\n    }\r\n    return newDate\r\n  }\r\n\r\n  function _strftime(s, maxsize, format, tm) {\r\n    var tm_zone = HEAP32[tm + 40 >> 2];\r\n    var date = {\r\n      tm_sec: HEAP32[tm >> 2],\r\n      tm_min: HEAP32[tm + 4 >> 2],\r\n      tm_hour: HEAP32[tm + 8 >> 2],\r\n      tm_mday: HEAP32[tm + 12 >> 2],\r\n      tm_mon: HEAP32[tm + 16 >> 2],\r\n      tm_year: HEAP32[tm + 20 >> 2],\r\n      tm_wday: HEAP32[tm + 24 >> 2],\r\n      tm_yday: HEAP32[tm + 28 >> 2],\r\n      tm_isdst: HEAP32[tm + 32 >> 2],\r\n      tm_gmtoff: HEAP32[tm + 36 >> 2],\r\n      tm_zone: tm_zone ? Pointer_stringify(tm_zone) : \"\"\r\n    };\r\n    var pattern = Pointer_stringify(format);\r\n    var EXPANSION_RULES_1 = {\r\n      \"%c\": \"%a %b %d %H:%M:%S %Y\",\r\n      \"%D\": \"%m/%d/%y\",\r\n      \"%F\": \"%Y-%m-%d\",\r\n      \"%h\": \"%b\",\r\n      \"%r\": \"%I:%M:%S %p\",\r\n      \"%R\": \"%H:%M\",\r\n      \"%T\": \"%H:%M:%S\",\r\n      \"%x\": \"%m/%d/%y\",\r\n      \"%X\": \"%H:%M:%S\"\r\n    };\r\n    for (var rule in EXPANSION_RULES_1) {\r\n      pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_1[rule])\r\n    }\r\n    var WEEKDAYS = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\r\n    var MONTHS = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\r\n\r\n    function leadingSomething(value, digits, character) {\r\n      var str = typeof value === \"number\" ? value.toString() : value || \"\";\r\n      while (str.length < digits) {\r\n        str = character[0] + str\r\n      }\r\n      return str\r\n    }\r\n\r\n    function leadingNulls(value, digits) {\r\n      return leadingSomething(value, digits, \"0\")\r\n    }\r\n\r\n    function compareByDay(date1, date2) {\r\n      function sgn(value) {\r\n        return value < 0 ? -1 : value > 0 ? 1 : 0\r\n      }\r\n      var compare;\r\n      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\r\n        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\r\n          compare = sgn(date1.getDate() - date2.getDate())\r\n        }\r\n      }\r\n      return compare\r\n    }\r\n\r\n    function getFirstWeekStartDate(janFourth) {\r\n      switch (janFourth.getDay()) {\r\n        case 0:\r\n          return new Date(janFourth.getFullYear() - 1, 11, 29);\r\n        case 1:\r\n          return janFourth;\r\n        case 2:\r\n          return new Date(janFourth.getFullYear(), 0, 3);\r\n        case 3:\r\n          return new Date(janFourth.getFullYear(), 0, 2);\r\n        case 4:\r\n          return new Date(janFourth.getFullYear(), 0, 1);\r\n        case 5:\r\n          return new Date(janFourth.getFullYear() - 1, 11, 31);\r\n        case 6:\r\n          return new Date(janFourth.getFullYear() - 1, 11, 30)\r\n      }\r\n    }\r\n\r\n    function getWeekBasedYear(date) {\r\n      var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\r\n      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\r\n      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\r\n      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\r\n      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\r\n      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\r\n        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\r\n          return thisDate.getFullYear() + 1\r\n        } else {\r\n          return thisDate.getFullYear()\r\n        }\r\n      } else {\r\n        return thisDate.getFullYear() - 1\r\n      }\r\n    }\r\n    var EXPANSION_RULES_2 = {\r\n      \"%a\": (function(date) {\r\n        return WEEKDAYS[date.tm_wday].substring(0, 3)\r\n      }),\r\n      \"%A\": (function(date) {\r\n        return WEEKDAYS[date.tm_wday]\r\n      }),\r\n      \"%b\": (function(date) {\r\n        return MONTHS[date.tm_mon].substring(0, 3)\r\n      }),\r\n      \"%B\": (function(date) {\r\n        return MONTHS[date.tm_mon]\r\n      }),\r\n      \"%C\": (function(date) {\r\n        var year = date.tm_year + 1900;\r\n        return leadingNulls(year / 100 | 0, 2)\r\n      }),\r\n      \"%d\": (function(date) {\r\n        return leadingNulls(date.tm_mday, 2)\r\n      }),\r\n      \"%e\": (function(date) {\r\n        return leadingSomething(date.tm_mday, 2, \" \")\r\n      }),\r\n      \"%g\": (function(date) {\r\n        return getWeekBasedYear(date).toString().substring(2)\r\n      }),\r\n      \"%G\": (function(date) {\r\n        return getWeekBasedYear(date)\r\n      }),\r\n      \"%H\": (function(date) {\r\n        return leadingNulls(date.tm_hour, 2)\r\n      }),\r\n      \"%I\": (function(date) {\r\n        var twelveHour = date.tm_hour;\r\n        if (twelveHour == 0) twelveHour = 12;\r\n        else if (twelveHour > 12) twelveHour -= 12;\r\n        return leadingNulls(twelveHour, 2)\r\n      }),\r\n      \"%j\": (function(date) {\r\n        return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3)\r\n      }),\r\n      \"%m\": (function(date) {\r\n        return leadingNulls(date.tm_mon + 1, 2)\r\n      }),\r\n      \"%M\": (function(date) {\r\n        return leadingNulls(date.tm_min, 2)\r\n      }),\r\n      \"%n\": (function() {\r\n        return \"\\n\"\r\n      }),\r\n      \"%p\": (function(date) {\r\n        if (date.tm_hour >= 0 && date.tm_hour < 12) {\r\n          return \"AM\"\r\n        } else {\r\n          return \"PM\"\r\n        }\r\n      }),\r\n      \"%S\": (function(date) {\r\n        return leadingNulls(date.tm_sec, 2)\r\n      }),\r\n      \"%t\": (function() {\r\n        return \"\\t\"\r\n      }),\r\n      \"%u\": (function(date) {\r\n        var day = new Date(date.tm_year + 1900, date.tm_mon + 1, date.tm_mday, 0, 0, 0, 0);\r\n        return day.getDay() || 7\r\n      }),\r\n      \"%U\": (function(date) {\r\n        var janFirst = new Date(date.tm_year + 1900, 0, 1);\r\n        var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());\r\n        var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\r\n        if (compareByDay(firstSunday, endDate) < 0) {\r\n          var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\r\n          var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();\r\n          var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\r\n          return leadingNulls(Math.ceil(days / 7), 2)\r\n        }\r\n        return compareByDay(firstSunday, janFirst) === 0 ? \"01\" : \"00\"\r\n      }),\r\n      \"%V\": (function(date) {\r\n        var janFourthThisYear = new Date(date.tm_year + 1900, 0, 4);\r\n        var janFourthNextYear = new Date(date.tm_year + 1901, 0, 4);\r\n        var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\r\n        var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\r\n        var endDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\r\n        if (compareByDay(endDate, firstWeekStartThisYear) < 0) {\r\n          return \"53\"\r\n        }\r\n        if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {\r\n          return \"01\"\r\n        }\r\n        var daysDifference;\r\n        if (firstWeekStartThisYear.getFullYear() < date.tm_year + 1900) {\r\n          daysDifference = date.tm_yday + 32 - firstWeekStartThisYear.getDate()\r\n        } else {\r\n          daysDifference = date.tm_yday + 1 - firstWeekStartThisYear.getDate()\r\n        }\r\n        return leadingNulls(Math.ceil(daysDifference / 7), 2)\r\n      }),\r\n      \"%w\": (function(date) {\r\n        var day = new Date(date.tm_year + 1900, date.tm_mon + 1, date.tm_mday, 0, 0, 0, 0);\r\n        return day.getDay()\r\n      }),\r\n      \"%W\": (function(date) {\r\n        var janFirst = new Date(date.tm_year, 0, 1);\r\n        var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);\r\n        var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\r\n        if (compareByDay(firstMonday, endDate) < 0) {\r\n          var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\r\n          var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();\r\n          var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\r\n          return leadingNulls(Math.ceil(days / 7), 2)\r\n        }\r\n        return compareByDay(firstMonday, janFirst) === 0 ? \"01\" : \"00\"\r\n      }),\r\n      \"%y\": (function(date) {\r\n        return (date.tm_year + 1900).toString().substring(2)\r\n      }),\r\n      \"%Y\": (function(date) {\r\n        return date.tm_year + 1900\r\n      }),\r\n      \"%z\": (function(date) {\r\n        var off = date.tm_gmtoff;\r\n        var ahead = off >= 0;\r\n        off = Math.abs(off) / 60;\r\n        off = off / 60 * 100 + off % 60;\r\n        return (ahead ? \"+\" : \"-\") + String(\"0000\" + off).slice(-4)\r\n      }),\r\n      \"%Z\": (function(date) {\r\n        return date.tm_zone\r\n      }),\r\n      \"%%\": (function() {\r\n        return \"%\"\r\n      })\r\n    };\r\n    for (var rule in EXPANSION_RULES_2) {\r\n      if (pattern.indexOf(rule) >= 0) {\r\n        pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_2[rule](date))\r\n      }\r\n    }\r\n    var bytes = intArrayFromString(pattern, false);\r\n    if (bytes.length > maxsize) {\r\n      return 0\r\n    }\r\n    writeArrayToMemory(bytes, s);\r\n    return bytes.length - 1\r\n  }\r\n\r\n  function _sysconf(name) {\r\n    switch (name) {\r\n      case 30:\r\n        return PAGE_SIZE;\r\n      case 85:\r\n        var maxHeapSize = 2 * 1024 * 1024 * 1024 - 65536;\r\n        return maxHeapSize / PAGE_SIZE;\r\n      case 132:\r\n      case 133:\r\n      case 12:\r\n      case 137:\r\n      case 138:\r\n      case 15:\r\n      case 235:\r\n      case 16:\r\n      case 17:\r\n      case 18:\r\n      case 19:\r\n      case 20:\r\n      case 149:\r\n      case 13:\r\n      case 10:\r\n      case 236:\r\n      case 153:\r\n      case 9:\r\n      case 21:\r\n      case 22:\r\n      case 159:\r\n      case 154:\r\n      case 14:\r\n      case 77:\r\n      case 78:\r\n      case 139:\r\n      case 80:\r\n      case 81:\r\n      case 82:\r\n      case 68:\r\n      case 67:\r\n      case 164:\r\n      case 11:\r\n      case 29:\r\n      case 47:\r\n      case 48:\r\n      case 95:\r\n      case 52:\r\n      case 51:\r\n      case 46:\r\n        return 200809;\r\n      case 79:\r\n        return 0;\r\n      case 27:\r\n      case 246:\r\n      case 127:\r\n      case 128:\r\n      case 23:\r\n      case 24:\r\n      case 160:\r\n      case 161:\r\n      case 181:\r\n      case 182:\r\n      case 242:\r\n      case 183:\r\n      case 184:\r\n      case 243:\r\n      case 244:\r\n      case 245:\r\n      case 165:\r\n      case 178:\r\n      case 179:\r\n      case 49:\r\n      case 50:\r\n      case 168:\r\n      case 169:\r\n      case 175:\r\n      case 170:\r\n      case 171:\r\n      case 172:\r\n      case 97:\r\n      case 76:\r\n      case 32:\r\n      case 173:\r\n      case 35:\r\n        return -1;\r\n      case 176:\r\n      case 177:\r\n      case 7:\r\n      case 155:\r\n      case 8:\r\n      case 157:\r\n      case 125:\r\n      case 126:\r\n      case 92:\r\n      case 93:\r\n      case 129:\r\n      case 130:\r\n      case 131:\r\n      case 94:\r\n      case 91:\r\n        return 1;\r\n      case 74:\r\n      case 60:\r\n      case 69:\r\n      case 70:\r\n      case 4:\r\n        return 1024;\r\n      case 31:\r\n      case 42:\r\n      case 72:\r\n        return 32;\r\n      case 87:\r\n      case 26:\r\n      case 33:\r\n        return 2147483647;\r\n      case 34:\r\n      case 1:\r\n        return 47839;\r\n      case 38:\r\n      case 36:\r\n        return 99;\r\n      case 43:\r\n      case 37:\r\n        return 2048;\r\n      case 0:\r\n        return 2097152;\r\n      case 3:\r\n        return 65536;\r\n      case 28:\r\n        return 32768;\r\n      case 44:\r\n        return 32767;\r\n      case 75:\r\n        return 16384;\r\n      case 39:\r\n        return 1e3;\r\n      case 89:\r\n        return 700;\r\n      case 71:\r\n        return 256;\r\n      case 40:\r\n        return 255;\r\n      case 2:\r\n        return 100;\r\n      case 180:\r\n        return 64;\r\n      case 25:\r\n        return 20;\r\n      case 5:\r\n        return 16;\r\n      case 6:\r\n        return 6;\r\n      case 73:\r\n        return 4;\r\n      case 84: {\r\n        if (typeof navigator === \"object\") return navigator[\"hardwareConcurrency\"] || 1;\r\n        return 1\r\n      }\r\n    }\r\n    ___setErrNo(ERRNO_CODES.EINVAL);\r\n    return -1\r\n  }\r\n\r\n  function _time(ptr) {\r\n    var ret = Date.now() / 1e3 | 0;\r\n    if (ptr) {\r\n      HEAP32[ptr >> 2] = ret\r\n    }\r\n    return ret\r\n  }\r\n\r\n  function _unsetenv(name) {\r\n    if (name === 0) {\r\n      ___setErrNo(ERRNO_CODES.EINVAL);\r\n      return -1\r\n    }\r\n    name = Pointer_stringify(name);\r\n    if (name === \"\" || name.indexOf(\"=\") !== -1) {\r\n      ___setErrNo(ERRNO_CODES.EINVAL);\r\n      return -1\r\n    }\r\n    if (ENV.hasOwnProperty(name)) {\r\n      delete ENV[name];\r\n      ___buildEnvironment(ENV)\r\n    }\r\n    return 0\r\n  }\r\n\r\n  function _utime(path, times) {\r\n    var time;\r\n    if (times) {\r\n      var offset = 4;\r\n      time = HEAP32[times + offset >> 2];\r\n      time *= 1e3\r\n    } else {\r\n      time = Date.now()\r\n    }\r\n    path = Pointer_stringify(path);\r\n    try {\r\n      FS.utime(path, time, time);\r\n      return 0\r\n    } catch (e) {\r\n      FS.handleFSError(e);\r\n      return -1\r\n    }\r\n  }\r\n\r\n  function _utimes(path, times) {\r\n    var time;\r\n    if (times) {\r\n      var offset = 8 + 0;\r\n      time = HEAP32[times + offset >> 2] * 1e3;\r\n      offset = 8 + 4;\r\n      time += HEAP32[times + offset >> 2] / 1e3\r\n    } else {\r\n      time = Date.now()\r\n    }\r\n    path = Pointer_stringify(path);\r\n    try {\r\n      FS.utime(path, time, time);\r\n      return 0\r\n    } catch (e) {\r\n      FS.handleFSError(e);\r\n      return -1\r\n    }\r\n  }\r\n\r\n  function _wait(stat_loc) {\r\n    ___setErrNo(ERRNO_CODES.ECHILD);\r\n    return -1\r\n  }\r\n\r\n  function _waitpid() {\r\n    return _wait.apply(null, arguments)\r\n  }\r\n  if (ENVIRONMENT_IS_NODE) {\r\n    _emscripten_get_now = function _emscripten_get_now_actual() {\r\n      var t = process[\"hrtime\"]();\r\n      return t[0] * 1e3 + t[1] / 1e6\r\n    }\r\n  } else if (typeof dateNow !== \"undefined\") {\r\n    _emscripten_get_now = dateNow\r\n  } else if (typeof self === \"object\" && self[\"performance\"] && typeof self[\"performance\"][\"now\"] === \"function\") {\r\n    _emscripten_get_now = (function() {\r\n      return self[\"performance\"][\"now\"]()\r\n    })\r\n  } else if (typeof performance === \"object\" && typeof performance[\"now\"] === \"function\") {\r\n    _emscripten_get_now = (function() {\r\n      return performance[\"now\"]()\r\n    })\r\n  } else {\r\n    _emscripten_get_now = Date.now\r\n  }\r\n  FS.staticInit();\r\n  __ATINIT__.unshift((function() {\r\n    if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init()\r\n  }));\r\n  __ATMAIN__.push((function() {\r\n    FS.ignorePermissions = false\r\n  }));\r\n  __ATEXIT__.push((function() {\r\n    FS.quit()\r\n  }));\r\n  Module[\"FS_createPath\"] = FS.createPath;\r\n  Module[\"FS_createDataFile\"] = FS.createDataFile;\r\n  __ATINIT__.unshift((function() {\r\n    TTY.init()\r\n  }));\r\n  __ATEXIT__.push((function() {\r\n    TTY.shutdown()\r\n  }));\r\n  if (ENVIRONMENT_IS_NODE) {\r\n    var fs = __webpack_require__(/*! fs */ \"fs\");\r\n    var NODEJS_PATH = __webpack_require__(/*! path */ \"path\");\r\n    NODEFS.staticInit()\r\n  }\r\n  __ATINIT__.push((function() {\r\n    SOCKFS.root = FS.mount(SOCKFS, {}, null)\r\n  }));\r\n  __ATINIT__.push((function() {\r\n    PIPEFS.root = FS.mount(PIPEFS, {}, null)\r\n  }));\r\n  ___buildEnvironment(ENV);\r\n  Module[\"pump_message\"] = MONO.pump_message;\r\n  DYNAMICTOP_PTR = staticAlloc(4);\r\n  STACK_BASE = STACKTOP = alignMemory(STATICTOP);\r\n  STACK_MAX = STACK_BASE + TOTAL_STACK;\r\n  DYNAMIC_BASE = alignMemory(STACK_MAX);\r\n  HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\r\n  staticSealed = true;\r\n\r\n  function intArrayFromString(stringy, dontAddNull, length) {\r\n    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\r\n    var u8array = new Array(len);\r\n    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\r\n    if (dontAddNull) u8array.length = numBytesWritten;\r\n    return u8array\r\n  }\r\n  Module[\"wasmTableSize\"] = 69448;\r\n  Module[\"wasmMaxTableSize\"] = 69448;\r\n  Module.asmGlobalArg = {};\r\n  Module.asmLibraryArg = {\r\n    \"abort\": abort,\r\n    \"enlargeMemory\": enlargeMemory,\r\n    \"getTotalMemory\": getTotalMemory,\r\n    \"abortOnCannotGrowMemory\": abortOnCannotGrowMemory,\r\n    \"___clock_gettime\": ___clock_gettime,\r\n    \"___lock\": ___lock,\r\n    \"___setErrNo\": ___setErrNo,\r\n    \"___syscall10\": ___syscall10,\r\n    \"___syscall102\": ___syscall102,\r\n    \"___syscall118\": ___syscall118,\r\n    \"___syscall12\": ___syscall12,\r\n    \"___syscall122\": ___syscall122,\r\n    \"___syscall125\": ___syscall125,\r\n    \"___syscall140\": ___syscall140,\r\n    \"___syscall142\": ___syscall142,\r\n    \"___syscall144\": ___syscall144,\r\n    \"___syscall145\": ___syscall145,\r\n    \"___syscall146\": ___syscall146,\r\n    \"___syscall15\": ___syscall15,\r\n    \"___syscall168\": ___syscall168,\r\n    \"___syscall183\": ___syscall183,\r\n    \"___syscall191\": ___syscall191,\r\n    \"___syscall192\": ___syscall192,\r\n    \"___syscall194\": ___syscall194,\r\n    \"___syscall195\": ___syscall195,\r\n    \"___syscall196\": ___syscall196,\r\n    \"___syscall197\": ___syscall197,\r\n    \"___syscall199\": ___syscall199,\r\n    \"___syscall20\": ___syscall20,\r\n    \"___syscall201\": ___syscall201,\r\n    \"___syscall202\": ___syscall202,\r\n    \"___syscall209\": ___syscall209,\r\n    \"___syscall219\": ___syscall219,\r\n    \"___syscall220\": ___syscall220,\r\n    \"___syscall221\": ___syscall221,\r\n    \"___syscall268\": ___syscall268,\r\n    \"___syscall272\": ___syscall272,\r\n    \"___syscall3\": ___syscall3,\r\n    \"___syscall33\": ___syscall33,\r\n    \"___syscall340\": ___syscall340,\r\n    \"___syscall38\": ___syscall38,\r\n    \"___syscall39\": ___syscall39,\r\n    \"___syscall4\": ___syscall4,\r\n    \"___syscall40\": ___syscall40,\r\n    \"___syscall41\": ___syscall41,\r\n    \"___syscall42\": ___syscall42,\r\n    \"___syscall5\": ___syscall5,\r\n    \"___syscall54\": ___syscall54,\r\n    \"___syscall6\": ___syscall6,\r\n    \"___syscall63\": ___syscall63,\r\n    \"___syscall77\": ___syscall77,\r\n    \"___syscall85\": ___syscall85,\r\n    \"___syscall91\": ___syscall91,\r\n    \"___syscall96\": ___syscall96,\r\n    \"___syscall97\": ___syscall97,\r\n    \"___unlock\": ___unlock,\r\n    \"__exit\": __exit,\r\n    \"_abort\": _abort,\r\n    \"_atexit\": _atexit,\r\n    \"_clock_getres\": _clock_getres,\r\n    \"_clock_gettime\": _clock_gettime,\r\n    \"_emscripten_asm_const_i\": _emscripten_asm_const_i,\r\n    \"_emscripten_asm_const_iii\": _emscripten_asm_const_iii,\r\n    \"_emscripten_memcpy_big\": _emscripten_memcpy_big,\r\n    \"_execve\": _execve,\r\n    \"_exit\": _exit,\r\n    \"_fork\": _fork,\r\n    \"_getaddrinfo\": _getaddrinfo,\r\n    \"_getenv\": _getenv,\r\n    \"_getnameinfo\": _getnameinfo,\r\n    \"_getprotobyname\": _getprotobyname,\r\n    \"_getpwuid\": _getpwuid,\r\n    \"_gettimeofday\": _gettimeofday,\r\n    \"_gmtime_r\": _gmtime_r,\r\n    \"_kill\": _kill,\r\n    \"_llvm_trap\": _llvm_trap,\r\n    \"_localtime_r\": _localtime_r,\r\n    \"_mono_set_timeout\": _mono_set_timeout,\r\n    \"_mono_wasm_add_bool_var\": _mono_wasm_add_bool_var,\r\n    \"_mono_wasm_add_float_var\": _mono_wasm_add_float_var,\r\n    \"_mono_wasm_add_frame\": _mono_wasm_add_frame,\r\n    \"_mono_wasm_add_int_var\": _mono_wasm_add_int_var,\r\n    \"_mono_wasm_add_long_var\": _mono_wasm_add_long_var,\r\n    \"_mono_wasm_add_string_var\": _mono_wasm_add_string_var,\r\n    \"_mono_wasm_fire_bp\": _mono_wasm_fire_bp,\r\n    \"_nanosleep\": _nanosleep,\r\n    \"_pthread_cleanup_pop\": _pthread_cleanup_pop,\r\n    \"_pthread_cleanup_push\": _pthread_cleanup_push,\r\n    \"_pthread_cond_destroy\": _pthread_cond_destroy,\r\n    \"_pthread_cond_init\": _pthread_cond_init,\r\n    \"_pthread_cond_signal\": _pthread_cond_signal,\r\n    \"_pthread_cond_timedwait\": _pthread_cond_timedwait,\r\n    \"_pthread_cond_wait\": _pthread_cond_wait,\r\n    \"_pthread_getspecific\": _pthread_getspecific,\r\n    \"_pthread_key_create\": _pthread_key_create,\r\n    \"_pthread_key_delete\": _pthread_key_delete,\r\n    \"_pthread_mutex_destroy\": _pthread_mutex_destroy,\r\n    \"_pthread_mutex_init\": _pthread_mutex_init,\r\n    \"_pthread_mutexattr_destroy\": _pthread_mutexattr_destroy,\r\n    \"_pthread_mutexattr_init\": _pthread_mutexattr_init,\r\n    \"_pthread_mutexattr_settype\": _pthread_mutexattr_settype,\r\n    \"_pthread_setcancelstate\": _pthread_setcancelstate,\r\n    \"_pthread_setspecific\": _pthread_setspecific,\r\n    \"_putchar\": _putchar,\r\n    \"_puts\": _puts,\r\n    \"_schedule_background_exec\": _schedule_background_exec,\r\n    \"_sem_destroy\": _sem_destroy,\r\n    \"_sem_init\": _sem_init,\r\n    \"_sem_post\": _sem_post,\r\n    \"_sem_trywait\": _sem_trywait,\r\n    \"_sem_wait\": _sem_wait,\r\n    \"_setenv\": _setenv,\r\n    \"_sigaction\": _sigaction,\r\n    \"_sigemptyset\": _sigemptyset,\r\n    \"_strftime\": _strftime,\r\n    \"_sysconf\": _sysconf,\r\n    \"_time\": _time,\r\n    \"_unsetenv\": _unsetenv,\r\n    \"_utime\": _utime,\r\n    \"_utimes\": _utimes,\r\n    \"_waitpid\": _waitpid,\r\n    \"DYNAMICTOP_PTR\": DYNAMICTOP_PTR,\r\n    \"STACKTOP\": STACKTOP,\r\n    \"_environ\": _environ\r\n  };\r\n  var asm = Module[\"asm\"](Module.asmGlobalArg, Module.asmLibraryArg, buffer);\r\n  Module[\"asm\"] = asm;\r\n  ___errno_location = Module[\"___errno_location\"] = (function() {\r\n    return Module[\"asm\"][\"___errno_location\"].apply(null, arguments)\r\n  });\r\n\r\n  _emscripten_replace_memory = Module[\"_emscripten_replace_memory\"] = (function() {\r\n    return Module[\"asm\"][\"_emscripten_replace_memory\"].apply(null, arguments)\r\n  });\r\n\r\n  _free = Module[\"_free\"] = (function() {\r\n    return Module[\"asm\"][\"_free\"].apply(null, arguments)\r\n  });\r\n\r\n  _htonl = Module[\"_htonl\"] = (function() {\r\n    return Module[\"asm\"][\"_htonl\"].apply(null, arguments)\r\n  });\r\n\r\n  _htons = Module[\"_htons\"] = (function() {\r\n    return Module[\"asm\"][\"_htons\"].apply(null, arguments)\r\n  });\r\n\r\n  _malloc = Module[\"_malloc\"] = (function() {\r\n    return Module[\"asm\"][\"_malloc\"].apply(null, arguments)\r\n  });\r\n\r\n  _memalign = Module[\"_memalign\"] = (function() {\r\n    return Module[\"asm\"][\"_memalign\"].apply(null, arguments)\r\n  });\r\n\r\n  _memset = Module[\"_memset\"] = (function() {\r\n    return Module[\"asm\"][\"_memset\"].apply(null, arguments)\r\n  });\r\n\r\n  _mono_background_exec = Module[\"_mono_background_exec\"] = (function() {\r\n    return Module[\"asm\"][\"_mono_background_exec\"].apply(null, arguments)\r\n  });\r\n\r\n  _mono_print_method_from_ip = Module[\"_mono_print_method_from_ip\"] = (function() {\r\n    return Module[\"asm\"][\"_mono_print_method_from_ip\"].apply(null, arguments)\r\n  });\r\n\r\n  _mono_set_timeout_exec = Module[\"_mono_set_timeout_exec\"] = (function() {\r\n    return Module[\"asm\"][\"_mono_set_timeout_exec\"].apply(null, arguments)\r\n  });\r\n\r\n  _mono_wasm_assembly_find_class = Module[\"_mono_wasm_assembly_find_class\"] = (function() {\r\n    return Module[\"asm\"][\"_mono_wasm_assembly_find_class\"].apply(null, arguments)\r\n  });\r\n\r\n  _mono_wasm_assembly_find_method = Module[\"_mono_wasm_assembly_find_method\"] = (function() {\r\n    return Module[\"asm\"][\"_mono_wasm_assembly_find_method\"].apply(null, arguments)\r\n  });\r\n\r\n  _mono_wasm_assembly_load = Module[\"_mono_wasm_assembly_load\"] = (function() {\r\n    return Module[\"asm\"][\"_mono_wasm_assembly_load\"].apply(null, arguments)\r\n  });\r\n\r\n  _mono_wasm_current_bp_id = Module[\"_mono_wasm_current_bp_id\"] = (function() {\r\n    return Module[\"asm\"][\"_mono_wasm_current_bp_id\"].apply(null, arguments)\r\n  });\r\n\r\n  _mono_wasm_enum_frames = Module[\"_mono_wasm_enum_frames\"] = (function() {\r\n    return Module[\"asm\"][\"_mono_wasm_enum_frames\"].apply(null, arguments)\r\n  });\r\n\r\n  _mono_wasm_get_var_info = Module[\"_mono_wasm_get_var_info\"] = (function() {\r\n    return Module[\"asm\"][\"_mono_wasm_get_var_info\"].apply(null, arguments)\r\n  });\r\n\r\n  _mono_wasm_invoke_method = Module[\"_mono_wasm_invoke_method\"] = (function() {\r\n    return Module[\"asm\"][\"_mono_wasm_invoke_method\"].apply(null, arguments)\r\n  });\r\n\r\n  _mono_wasm_load_runtime = Module[\"_mono_wasm_load_runtime\"] = (function() {\r\n    return Module[\"asm\"][\"_mono_wasm_load_runtime\"].apply(null, arguments)\r\n  });\r\n\r\n  _mono_wasm_set_breakpoint = Module[\"_mono_wasm_set_breakpoint\"] = (function() {\r\n    return Module[\"asm\"][\"_mono_wasm_set_breakpoint\"].apply(null, arguments)\r\n  });\r\n\r\n  _mono_wasm_string_from_js = Module[\"_mono_wasm_string_from_js\"] = (function() {\r\n    return Module[\"asm\"][\"_mono_wasm_string_from_js\"].apply(null, arguments)\r\n  });\r\n\r\n  _mono_wasm_string_get_utf8 = Module[\"_mono_wasm_string_get_utf8\"] = (function() {\r\n    return Module[\"asm\"][\"_mono_wasm_string_get_utf8\"].apply(null, arguments)\r\n  });\r\n\r\n  _ntohs = Module[\"_ntohs\"] = (function() {\r\n    return Module[\"asm\"][\"_ntohs\"].apply(null, arguments)\r\n  });\r\n\r\n  _wasm_get_stack_base = Module[\"_wasm_get_stack_base\"] = (function() {\r\n    return Module[\"asm\"][\"_wasm_get_stack_base\"].apply(null, arguments)\r\n  });\r\n\r\n  _wasm_get_stack_size = Module[\"_wasm_get_stack_size\"] = (function() {\r\n    return Module[\"asm\"][\"_wasm_get_stack_size\"].apply(null, arguments)\r\n  });\r\n\r\n  stackAlloc = Module[\"stackAlloc\"] = (function() {\r\n    return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments)\r\n  });\r\n\r\n  stackRestore = Module[\"stackRestore\"] = (function() {\r\n    return Module[\"asm\"][\"stackRestore\"].apply(null, arguments)\r\n  });\r\n\r\n  stackSave = Module[\"stackSave\"] = (function() {\r\n    return Module[\"asm\"][\"stackSave\"].apply(null, arguments)\r\n  });\r\n\r\n  dynCall_v = Module[\"dynCall_v\"] = (function() {\r\n    return Module[\"asm\"][\"dynCall_v\"].apply(null, arguments)\r\n  });\r\n\r\n  dynCall_vi = Module[\"dynCall_vi\"] = (function() {\r\n    return Module[\"asm\"][\"dynCall_vi\"].apply(null, arguments)\r\n  });\r\n\r\n  Module.asm = asm;\r\n  Module.ccall = ccall;\r\n  Module.cwrap = cwrap;\r\n  Module.setValue = setValue;\r\n  Module.getValue = getValue;\r\n  Module.UTF8ToString = UTF8ToString;\r\n  Module.FS_createPath = FS.createPath;\r\n  Module.FS_createDataFile = FS.createDataFile;\r\n\r\n  function ExitStatus(status) {\r\n    this.name = \"ExitStatus\";\r\n    this.message = \"Program terminated with exit(\" + status + \")\";\r\n    this.status = status\r\n  }\r\n  ExitStatus.prototype = new Error;\r\n  ExitStatus.prototype.constructor = ExitStatus;\r\n  var initialStackTop;\r\n  dependenciesFulfilled = function runCaller() {\r\n    if (!Module[\"calledRun\"]) run();\r\n    if (!Module[\"calledRun\"]) dependenciesFulfilled = runCaller\r\n  };\r\n\r\n  function run(args) {\r\n    args = args || Module[\"arguments\"];\r\n    if (runDependencies > 0) {\r\n      return\r\n    }\r\n    preRun();\r\n    if (runDependencies > 0) return;\r\n    if (Module[\"calledRun\"]) return;\r\n\r\n    function doRun() {\r\n      if (Module[\"calledRun\"]) return;\r\n      Module[\"calledRun\"] = true;\r\n      if (ABORT) return;\r\n      ensureInitRuntime();\r\n      preMain();\r\n      if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"](resolve);\r\n      postRun()\r\n    }\r\n    if (Module[\"setStatus\"]) {\r\n      Module[\"setStatus\"](\"Running...\");\r\n      setTimeout((function() {\r\n        setTimeout((function() {\r\n          Module[\"setStatus\"](\"\")\r\n        }), 1);\r\n        doRun()\r\n      }), 1)\r\n    } else {\r\n      doRun()\r\n    }\r\n  }\r\n  Module[\"run\"] = run;\r\n\r\n  function exit(status, implicit) {\r\n    if (implicit && Module[\"noExitRuntime\"] && status === 0) {\r\n      return\r\n    }\r\n    if (Module[\"noExitRuntime\"]) {} else {\r\n      ABORT = true;\r\n      EXITSTATUS = status;\r\n      STACKTOP = initialStackTop;\r\n      exitRuntime();\r\n      if (Module[\"onExit\"]) Module[\"onExit\"](status)\r\n    }\r\n    /*if (ENVIRONMENT_IS_NODE) {\r\n      process[\"exit\"](status)\r\n    }*/\r\n\r\n    Module[\"quit\"](status, new ExitStatus(status))\r\n  }\r\n  Module[\"exit\"] = exit;\r\n\r\n  function abort(what) {\r\n    if (Module[\"onAbort\"]) {\r\n      Module[\"onAbort\"](what)\r\n    }\r\n    if (what !== undefined) {\r\n      //Module.print(what);\r\n      Module.printErr(what);\r\n      what = JSON.stringify(what)\r\n    } else {\r\n      what = \"\"\r\n    }\r\n    ABORT = true;\r\n    EXITSTATUS = 1;\r\n    throw \"abort(\" + what + \"). Build with -s ASSERTIONS=1 for more info.\"\r\n  }\r\n  Module[\"abort\"] = abort;\r\n  if (Module[\"preInit\"]) {\r\n    if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [Module[\"preInit\"]];\r\n    while (Module[\"preInit\"].length > 0) {\r\n      Module[\"preInit\"].pop()()\r\n    }\r\n  }\r\n  Module[\"noExitRuntime\"] = true;\r\n  run();\r\n\r\n\r\n});\r\n\r\nmodule.exports = {\r\n  initializeMonoEnvironment,\r\n  Module,\r\n  MonoRuntime,\r\n  WebAssemblyApp,\r\n};\r\n\n\n//# sourceURL=webpack:///./src/mono.js?");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"assert\");\n\n//# sourceURL=webpack:///external_%22assert%22?");

/***/ }),

/***/ "constants":
/*!****************************!*\
  !*** external "constants" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"constants\");\n\n//# sourceURL=webpack:///external_%22constants%22?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//# sourceURL=webpack:///external_%22crypto%22?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");\n\n//# sourceURL=webpack:///external_%22events%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"http\");\n\n//# sourceURL=webpack:///external_%22http%22?");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"https\");\n\n//# sourceURL=webpack:///external_%22https%22?");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"net\");\n\n//# sourceURL=webpack:///external_%22net%22?");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"os\");\n\n//# sourceURL=webpack:///external_%22os%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"stream\");\n\n//# sourceURL=webpack:///external_%22stream%22?");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"tls\");\n\n//# sourceURL=webpack:///external_%22tls%22?");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"url\");\n\n//# sourceURL=webpack:///external_%22url%22?");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");\n\n//# sourceURL=webpack:///external_%22util%22?");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"zlib\");\n\n//# sourceURL=webpack:///external_%22zlib%22?");

/***/ })

/******/ });